/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/add-patient-dialog.js":
/*!***********************************!*\
  !*** ./src/add-patient-dialog.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AddPatientDialog\": function() { return /* binding */ AddPatientDialog; }\n/* harmony export */ });\n\nclass AddPatientDialog\n{\n    /**\n     *\n     * @type {bootstrap.Modal}\n     */\n    modal = null;\n\n    /**\n     *\n     * @type HTMLElement\n     */\n    container = null;\n\n    /**\n     *\n     * @type {number}\n     */\n    pc_eid = null;\n\n    /**\n     *\n     * @type {string}\n     */\n    scriptLocation = null;\n\n    /**\n     *\n     * @type {function}\n     */\n    closeCallback = null;\n\n    __translations = null;\n\n    __idx = 0;\n\n    __apiCSRFToken = null;\n\n    __currentScreen = null;\n\n    __updatedCallerSettings = null;\n\n    __currentThirdParty = null;\n\n    constructor(apiCSRFToken, translations, pc_eid, scriptLocation, currentThirdParty, closeCallback) {\n        this.pc_eid = pc_eid;\n        this.scriptLocation = scriptLocation;\n        this.closeCallback = closeCallback;\n        this.__translations = translations;\n        this.__apiCSRFToken = apiCSRFToken;\n        this.__currentThirdParty = currentThirdParty;\n    }\n\n    cancelDialog() {\n        // just have us call the close dialog piece.\n        this.closeDialogAndSendCallerSettings();\n\n    }\n\n    sendSaveParticipant(saveData) {\n        let postData = Object.assign({eid: this.pc_eid}, saveData);\n        let scriptLocation = this.scriptLocation + \"?action=save_session_participant\";\n\n        window.top.restoreSession();\n        return window.fetch(scriptLocation,\n            {\n                method: 'POST'\n                ,headers: {\n                    'Content-Type': 'application/json'\n                }\n                ,body: JSON.stringify(postData)\n                ,redirect: 'manual'\n            })\n            .then(result => {\n                if (!(result.ok && result.status == 200))\n                {\n                    throw new Error(\"Failed to save participant in \" + this.pc_eid + \" with save data\");\n                } else {\n                    return result.json();\n                }\n            })\n            .then(jsonResult => {\n                let callerSettings = jsonResult.callerSettings || {};\n                this.showActionAlert('success', this.__translations.PATIENT_INVITATION_SUCCESS);\n                // let's show we were successful and close things up.\n                this.__updatedCallerSettings = callerSettings;\n                this.__currentThirdParty = callerSettings.thirdPartyPatient;\n                this.updateThirdPartyControls();\n                this.showPrimaryScreen();\n                setTimeout(() => {\n                    this.closeDialogAndSendCallerSettings();\n                }, 1000);\n            })\n    }\n\n    closeDialogAndSendCallerSettings() {\n        jQuery(this.container).on(\"hidden.bs.modal\", () => {\n            try {\n                jQuery(this.container).off(\"hidden.bs.modal\");\n                this.closeCallback(this.__updatedCallerSettings);\n            }\n            catch (error)\n            {\n                console.error(error);\n            }\n            try {\n                // make sure we destruct even if the callback fails\n                this.destruct();\n            }\n            catch (error) {\n                this.destruct();\n            }\n        });\n        this.modal.hide();\n    }\n\n    sendSearchResults(inputValues) {\n        // let url = '/apis/default/fhir/Patient/_search?given:contains=<fname>&family:contains=<lname>&birthDate=<dob>'\n        // TODO: @adunsulag note the local api SKIPS the site parameter.  I don't really like that but for now we will\n        // ignore the site parameter as well\n        // TODO: @adunsulag need to make sure we get the FQDN url here.\n        let url = '/apis/fhir/Patient';\n        let searchParams = [];\n\n        if (inputValues.pid) {\n            searchParams.push(\"identifier=\" + inputValues.pid);\n        }\n        if (inputValues.fname || inputValues.lname) {\n            let values = [];\n            if (inputValues.fname) {\n                values.push(inputValues.fname);\n            }\n            if (inputValues.lname) {\n                values.push(inputValues.lname);\n            }\n            searchParams.push(\"name:contains=\" + values.join(\",\"));\n        }\n\n        if (inputValues.DOB) {\n            // birthdate needs to be in Y-m-d prefix\n            searchParams.push(\"birthdate=\" + inputValues.DOB);\n        }\n\n        if (inputValues.email) {\n            searchParams.push(\"email:contains=\" + inputValues.email);\n        }\n\n        if (!searchParams.length) {\n            alert(this.__translations.SEARCH_REQUIRES_INPUT);\n            throw new Error(\"Failed to perform search due to missing search operator\");\n        }\n\n        url += \"?\" + searchParams.join(\"&\");\n        window.top.restoreSession();\n        let headers = {\n            'apicsrftoken': this.__apiCSRFToken\n        };\n        return window.fetch(url,\n            {\n                method: 'GET'\n                ,redirect: 'manual'\n                ,headers: headers\n            })\n            .then(result => {\n                if (!(result.ok && result.status == 200))\n                {\n                    // TODO: @adunsulag update the session title here...\n                    this.showActionAlert('danger', this.__translations.OPERATION_FAILED);\n                    throw new Error(\"Failed to save participant in \" + this.pc_eid + \" with save data\");\n                } else {\n                    return result.json();\n                }\n            })\n            .then(result => {\n                if (result.total == 0) {\n                    this.showActionAlert('info', this.__translations.SEARCH_RESULTS_NOT_FOUND);\n                    return [];\n                } else {\n                    // return the array of result entries.\n                    return result.entry;\n                }\n            })\n    }\n\n    showPrimaryScreen() {\n        let screens = this.container.querySelectorAll('.screen') || [];\n        screens.forEach(i => {\n            if (i.classList.contains('primary-screen')) {\n                i.classList.remove('d-none');\n            } else {\n                i.classList.add('d-none');\n            }\n        });\n        this.__currentScreen = 'primary-screen';\n        this.updateThirdPartyControls();\n    }\n\n    updateThirdPartyControls() {\n\n        // let's update if our pid is different\n        if (!this.__currentThirdParty) {\n            this.container.querySelector('.no-third-party-patient-row').classList.remove('d-none');\n            this.container.querySelector('.third-party-patient-row').classList.add('d-none');\n            return;\n        }\n        this.container.querySelector('.no-third-party-patient-row').classList.add('d-none');\n        this.container.querySelector('.third-party-patient-row').classList.remove('d-none');\n        // now we need to update our participant screen if the pid has changed\n        let thirdPartyRow = this.container.querySelector('.patient-thirdparty');\n        if (thirdPartyRow.dataset['pid'] && thirdPartyRow.dataset['pid'] != this.__currentThirdParty.pid) {\n            // time to do some update magic\n            thirdPartyRow.dataset['pid'] = this.__currentThirdParty.pid;\n            let name = (this.__currentThirdParty.fname || \"\") + \" \" + (this.__currentThirdParty.lname || \"\");\n            this.setNodeInnerText(thirdPartyRow, '.patient-name', name);\n            this.setNodeInnerText(thirdPartyRow, '.patient-dob', this.__currentThirdParty.DOB);\n            this.setNodeInnerText(thirdPartyRow, '.patient-email', this.__currentThirdParty.email);\n        }\n    }\n\n    showNewPatientScreen() {\n        this.showSecondaryScreen('create-patient');\n    }\n\n    showSearchPatientScreen() {\n        this.showSecondaryScreen('search-patient');\n    }\n\n    showSecondaryScreen(screenName) {\n        let selector = '.' + screenName;\n        let primaryScreen = this.container.querySelector('.primary-screen');\n        if (!primaryScreen) {\n            console.error(\"Failed to find primary-screen selector for add-patient-dialog container\");\n            return;\n        }\n\n        primaryScreen.classList.add('d-none');\n\n        let screen = this.container.querySelector(selector);\n        if (screen) {\n            screen.classList.remove('d-none');\n        } else {\n            console.error(\"Failed to find selector for add-patient-dialog container \" + selector);\n        }\n        this.__currentScreen = screenName;\n    }\n\n\n    getInputValues(screen, inputs) {\n        let inputValues = {};\n        inputs.forEach((i) => {\n            let node = this.container.querySelector(\".\" + screen + ' input[name=\"' + i + '\"]');\n            if (node) {\n                inputValues[i] = node.value;\n            } else {\n                console.error(\"Failed to find input node with name \" + i);\n                inputValues[i] = null;\n            }\n        });\n        return inputValues;\n    }\n\n    inviteSearchResultPatient(pid) {\n        // hide the search results\n        this.displaySearchList(false);\n        this.showActionAlert('info', this.__translations.PATIENT_INVITATION_PROCESSING);\n        this.sendSaveParticipant({pid: pid})\n        .catch(error => {\n            console.error(error);\n            this.showActionAlert('danger', this.__translations.OPERATION_FAILED);\n            // show the search results\n            this.displaySearchList(true);\n        })\n    }\n\n    displaySearchList(shouldDisplay) {\n        let selector = \".search-patient .search-patient-list\";\n        let patientList = this.container.querySelector(selector);\n        if (!patientList) {\n            console.error(\"Failed to find \",selector);\n            return;\n        }\n        if (shouldDisplay) {\n            patientList.classList.remove('d-none');\n        } else {\n            patientList.classList.add('d-none');\n        }\n    }\n\n    populateSearchResults(result) {\n        console.log(\"populatingSearchResults with result \", result);\n        let selector = \".search-patient .search-patient-list\";\n        let patientList = this.container.querySelector(selector);\n        if (!patientList) {\n            console.error(\"Failed to find \",selector);\n            return;\n        }\n\n        patientList.classList.remove('d-none');\n        let row = patientList.querySelector('.duplicate-match-row-template');\n\n        // clear out the table rows\n        let parentNode = row.parentNode;\n        parentNode.replaceChildren();\n        parentNode.appendChild(row);\n\n        // need to loop on the result and populate per row\n        result.forEach(r => {\n            let resource = r.resource;\n            let clonedNode = row.cloneNode(true);\n            clonedNode.classList.remove('duplicate-match-row-template');\n            parentNode.appendChild(clonedNode);\n\n            let pid = resource.identifier.find(i => i.type.coding.find(cd => cd.code == \"PT\") !== undefined);\n            let pidValue = pid.value || \"\";\n            this.setNodeInnerText(clonedNode, '.pid', pidValue);\n\n            let birthDate = resource.birthDate;\n            if (birthDate) {\n                this.setNodeInnerText(clonedNode, '.dob', birthDate);\n            }\n\n            let name = resource.name.find(n => n.use == 'official');\n            if (name) {\n                this.setNodeInnerText(clonedNode, '.fname', name.given.join(\" \"));\n                this.setNodeInnerText(clonedNode, '.lname', name.family);\n            }\n\n            let email = resource.telecom.find(t => t.system == 'email');\n            if (email) {\n                this.setNodeInnerText(clonedNode, '.email', email.value);\n            }\n\n            if (pidValue) {\n                clonedNode.querySelector('.btn-select-patient').addEventListener('click', () => {\n                    this.inviteSearchResultPatient(pidValue);\n                });\n            }\n            clonedNode.classList.remove('d-none');\n        });\n    }\n\n    setNodeInnerText(node, selector, value) {\n        let subNode = node.querySelector(selector);\n        if (!subNode) {\n            console.error(\"Failed to find node with selector \" + selector);\n            return;\n        }\n        subNode.textContent = value;\n    }\n\n    searchParticipantsAction()\n    {\n        let inputs = ['fname', 'lname', 'DOB', 'email', 'pid'];\n        let inputValues = this.getInputValues('search-patient', inputs);\n        // TODO: @adunsulag need to do form validation checking...\n        this.sendSearchResults(inputValues)\n            .then(result => {\n                if (result.length) {\n                    this.populateSearchResults(result);\n                }\n                else {\n                    // TODO: @adunsulag change this.\n                    this.populateSearchResults([]);\n                    let resultMessage = this.__translations.SEARCH_RESULTS_NOT_FOUND;\n                    setTimeout(function() {\n                        alert(resultMessage);\n                    }, 0);\n                }\n            })\n            .catch(error => {\n                console.error(error);\n            });\n    }\n\n    createPatientAction() {\n        let inputs = ['fname', 'lname', 'DOB', 'email'];\n        let inputValues = this.getInputValues('create-patient', inputs);\n        // for now we don't do the searching but we will do the invitation here...\n        this.clearActionAlerts();\n        this.showActionAlert('info', this.__translations.PATIENT_INVITATION_PROCESSING);\n        // TODO: need to disable the save button during the save.\n        this.sendSaveParticipant(inputValues)\n        .catch(error => {\n            this.showActionAlert('danger', this.__translations.OPERATION_FAILED);\n            // TODO: @adunsulag need to handle the errors here.\n            console.error(error);\n        });\n    }\n\n    clearActionAlerts() {\n        let alerts = this.container.querySelectorAll('.alert');\n        alerts.forEach(a => {\n            if (a.classList.contains('alert-template')) {\n                a.classList.add('d-none');\n            } else {\n                a.parentNode.removeChild(a);\n            }\n        });\n    }\n\n    showActionAlert(type, message) {\n        this.clearActionAlerts(); // for now we will just remove these, we could animate & stack if we wanted.\n        let template = this.container.querySelector('.alert.alert-template');\n        let alert = template.cloneNode(true);\n        alert.innerText = message;\n        alert.classList.remove('alert-template');\n        alert.classList.remove('d-none');\n        alert.classList.add('alert-' + type);\n        template.parentNode.insertBefore(alert, template);\n        alert.scrollIntoView();\n    }\n\n    setupModal() {\n        // see templates/comlink/conference-room.twig\n        let id = 'telehealth-container-invite-patient';\n        // let bootstrapModalTemplate = window.document.createElement('div');\n        // we use min-height 90vh until we get the bootstrap full screen modal in bootstrap 5\n        let node = document.getElementById(id);\n        // we are going to clone the node and add an index to this...\n        let clonedNode = node.cloneNode(true);\n        clonedNode.id = id + \"-\" + this.__idx++;\n        node.parentNode.appendChild(clonedNode);\n        this.container = clonedNode;\n\n        this.modal = new bootstrap.Modal(this.container, {keyboard: false, focus: true, backdrop: 'static'});\n\n        this.addActionToButton('.btn-telehealth-confirm-cancel', this.cancelDialog.bind(this));\n        this.addActionToButton('.btn-show-new-patient-screen', this.showNewPatientScreen.bind(this));\n        this.addActionToButton('.btn-show-search-patient-screen', this.showSearchPatientScreen.bind(this));\n        this.addActionToButton('.btn-cancel-screen-action', this.showPrimaryScreen.bind(this));\n        this.addActionToButton('.btn-create-patient', this.createPatientAction.bind(this));\n        this.addActionToButton('.btn-invite-search', this.searchParticipantsAction.bind(this));\n\n        let actionButton = this.container.querySelector('.btn-invite-search');\n        if (actionButton)\n        {\n            actionButton.addEventListener('click', this.__searchOrAddParticipant);\n        } else {\n            console.error(\"Could not find selector with .btn-telehealth-confirm-yes\");\n        }\n        this.updateThirdPartyControls();\n    }\n\n    addActionToButton(selector, action) {\n        let btns = this.container.querySelectorAll(selector);\n        for (var i = 0; i < btns.length; i++)\n        {\n            btns[i].addEventListener('click', action);\n        }\n    }\n\n    show() {\n        if (!this.modal) {\n            this.setupModal();\n        }\n\n        this.modal.show();\n    }\n\n    destruct() {\n        this.modal = null;\n        // we clean everything up by removing the node which also removes the event listeners.\n        this.container.parentNode.removeChild(this.container);\n        this.container = null;\n    }\n}\n\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/add-patient-dialog.js?");

/***/ }),

/***/ "./src/at-slot.js":
/*!************************!*\
  !*** ./src/at-slot.js ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ATSlot\": function() { return /* binding */ ATSlot; }\n/* harmony export */ });\nfunction ATSlot(videoId) {\n    /** @private */\n    this.__call = null;\n\n    /** @private */\n    this.__video = document.getElementById(videoId);\n    if (!this.__video)\n    {\n        throw new Error(\"Failed to find #\" + videoId + \" element\");\n    }\n\n    this.hasVideo = function() {\n        return !this.isAvailable();\n    };\n\n    this.getVideoStream = function() {\n        return this.__video.srcObject;\n    };\n\n    this.isAvailable = function() {\n        return this.__call == null;\n    };\n\n    this.getRemotePartyId = function() {\n        if (this.__call) {\n            return this.__call.getRemotePartyId();\n        }\n        return null;\n    };\n\n\n    this.attach = function(call, stream, displayTitle) {\n        this.__call = call;\n        if (call == null || stream == null)\n        {\n            console.error(\"Call or stream were null.  Cannot proceed\", {call: call, stream: stream});\n            throw new Error(\"call and stream cannot be null\");\n        }\n        // this.__call.setUserData(this);\n        this.__video.srcObject = stream;\n        this.__video.play();\n        // for now we will just have the hover title be the display title for now.\n        // eventually we could have this be a full DOM Node that is always displayed.\n        this.__video.title = displayTitle;\n    };\n\n    this.detach = function() {\n        if (this.__call) {\n            this.__call.setUserData(null);\n        }\n        this.__call = null;\n        this.__video.srcObject = null;\n    };\n\n    this.hide = function() {\n        this.__video.classList.add('d-none');\n    };\n    this.show = function() {\n        if (this.__video) {\n            this.__video.classList.remove('d-none');\n        }\n    };\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/at-slot.js?");

/***/ }),

/***/ "./src/caller-slot.js":
/*!****************************!*\
  !*** ./src/caller-slot.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CallerSlot\": function() { return /* binding */ CallerSlot; }\n/* harmony export */ });\n/* harmony import */ var _at_slot_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./at-slot.js */ \"./src/at-slot.js\");\n\n\nclass CallerSlot {\n\n    /**\n     *\n     * @type HTMLMediaElement\n     * @private\n     */\n    __videoNode = null;\n\n    /**\n     *\n     * @type HTMLVideoElement\n     * @private\n     */\n    __screenshareNode = null;\n\n    /**\n     * @type ATSlot\n     * @private\n     */\n    __videoSlot = null;\n\n    /**\n     *\n     * @type ATSlot\n     * @private\n     */\n    __screenshareSlot = null;\n\n    /**\n     *\n     * @type ATSlot\n     * @private\n     */\n    __currentSlot = null;\n\n    __containerId = null;\n\n    __boundInternalEvent = null;\n\n    /**\n     * The participant data object\n     * @private\n     */\n    __participant = null;\n\n    constructor(containerId, index) {\n        let domNode = document.getElementById(containerId);\n        let templateNode = document.getElementById('participant-list-template-node');\n\n        if (!domNode) {\n            throw new Error(\"Failed to find container id with \" + containerId);\n        }\n        if (!templateNode) {\n            throw new Error(\"Failed to find container id with \" + 'participant-list-template-node');\n        }\n        let videoId = 'participant-video-' + index;\n        let screenshareId = 'participant-screenshare-' + index;\n        let videoNode = templateNode.cloneNode();\n        videoNode.id = videoId;\n        domNode.appendChild(videoNode);\n        let screenshareNode = templateNode.cloneNode();\n        screenshareNode.id = screenshareId;\n        domNode.appendChild(screenshareNode);\n        this.__boundInternalEvent = this.handleSelectEvent.bind(this);\n        videoNode.addEventListener('click', this.__boundInternalEvent);\n        screenshareNode.addEventListener('click', this.__boundInternalEvent);\n\n        this.__videoSlot = new _at_slot_js__WEBPACK_IMPORTED_MODULE_0__.ATSlot(videoId);\n        this.__videoNode = videoNode;\n        this.__screenshareSlot = new _at_slot_js__WEBPACK_IMPORTED_MODULE_0__.ATSlot(screenshareId);\n        this.__screenshareNode = screenshareNode;\n        this.__currentSlot = this.__videoSlot;\n        this.__selectCallbacks = [];\n    }\n\n    handleSelectEvent(evt) {\n        this.__selectCallbacks.forEach(cb => cb(this));\n    }\n\n    addCallerSelectListener(callback) {\n        this.__selectCallbacks.push(callback);\n    }\n\n    getRemotePartyId() {\n        return this.__currentSlot.getRemotePartyId();\n    }\n\n    hide() {\n        if (this.__currentSlot) {\n            this.__currentSlot.hide();\n        }\n    }\n    show() {\n        if (this.__currentSlot) {\n            this.__currentSlot.show();\n        }\n    }\n\n    isAvailable() {\n        return this.__videoSlot.isAvailable();\n    }\n\n    isAvailableForCall(call) {\n        // we say things are available if the remote id is the same as the caller remote party id\n        // or if the video slot has no call\n        if (this.__videoSlot.isAvailable() || this.__videoSlot.getRemotePartyId() == call.getRemotePartyId())\n        {\n            return true;\n        }\n        return false;\n    }\n\n    getCurrentCallStream() {\n        if (this.__currentSlot ) {\n            return this.__currentSlot .getVideoStream();\n        }\n        return null;\n    }\n\n    getParticipant() {\n        return this.__participant;\n    }\n\n    attach(call, stream, participant) {\n        if (call == null || stream == null || participant == null)\n        {\n            console.error(\"Call, stream, or participant were null.  Cannot proceed\", {call: call, stream: stream\n                , participant: participant});\n            throw new Error(\"call, stream, and participant cannot be null\");\n        }\n\n        // let's us cleanup screensharing and video slots if we already have it allocated.\n        // this only happens if the same user calls into the call\n        if (call.isScreenSharing()) {\n            if (!this.__screenshareSlot.isAvailable()) {\n                this.__screenshareSlot.detach();\n            }\n            this.__screenshareSlot.attach(call, stream, participant.callerName || \"\");\n            this.showScreenshare();\n        } else {\n            if (!this.__videoSlot.isAvailable()) {\n                this.__videoSlot.detach();\n            }\n            this.__videoSlot.attach(call, stream, participant.callerName || \"\");\n            this.showVideo();\n        }\n        // set ourselves up as the user data\n        // TODO: @adunsulag I don't like how I setUserData here but clear it in the ATSlot object.\n        this.__participant = participant;\n        call.setUserData(this);\n    }\n\n    showScreenshare() {\n        this.__videoSlot.hide();\n        this.__screenshareSlot.show();\n        this.__currentSlot = this.__screenshareSlot;\n    }\n\n    showVideo() {\n        this.__videoSlot.show();\n        this.__screenshareSlot.hide();\n        this.__currentSlot = this.__videoSlot;\n    }\n\n    detachScreenshare() {\n        this.__screenshareSlot.detach();\n        if (this.__videoSlot) {\n            this.__videoSlot.show();\n            this.__currentSlot = this.__videoSlot;\n        }\n    }\n\n    detatchVideo() {\n        this.__videoSlot.detach();\n        this.__currentSlot = null;\n        this.__participant = null;\n    }\n\n    detach() {\n        this.detachScreenshare();\n        this.detatchVideo();\n    }\n\n    destruct() {\n        // do we really need a detach at this point?  We might as well just remove all of the nodes...\n        // TODO: @adunsulag look at refactoring this so we only have to call destruct\n        this.detach();\n        this.__selectCallbacks = [];\n        if (this.__screenshareNode) {\n            this.__screenshareNode.removeEventListener('click', this.__boundInternalEvent);\n            this.__screenshareNode.parentNode.removeChild(this.__screenshareNode);\n            this.__screenshareNode = null;\n        }\n        if (this.__videoNode) {\n            this.__videoNode.removeEventListener('click', this.__boundInternalEvent);\n            this.__videoNode.parentNode.removeChild(this.__videoNode);\n            this.__videoNode = null;\n        }\n    }\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/caller-slot.js?");

/***/ }),

/***/ "./src/conference-room.js":
/*!********************************!*\
  !*** ./src/conference-room.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConferenceRoom\": function() { return /* binding */ ConferenceRoom; }\n/* harmony export */ });\n/* harmony import */ var _confirm_session_close_dialog_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./confirm-session-close-dialog.js */ \"./src/confirm-session-close-dialog.js\");\n/* harmony import */ var _configure_session_call_dialog_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./configure-session-call-dialog.js */ \"./src/configure-session-call-dialog.js\");\n/* harmony import */ var _video_bar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./video-bar.js */ \"./src/video-bar.js\");\n/* harmony import */ var _caller_slot_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./caller-slot.js */ \"./src/caller-slot.js\");\n/* harmony import */ var _telehealth_bridge_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./telehealth-bridge.js */ \"./src/telehealth-bridge.js\");\n/* harmony import */ var _presentation_screen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./presentation-screen */ \"./src/presentation-screen.js\");\n/* harmony import */ var _cvb_min_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cvb.min.js */ \"./src/cvb.min.js\");\n/* harmony import */ var _add_patient_dialog__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./add-patient-dialog */ \"./src/add-patient-dialog.js\");\n/* harmony import */ var _minimized_conference_room__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./minimized-conference-room */ \"./src/minimized-conference-room.js\");\n\n\n\n\n\n\n\n\n\n\n// TODO: @adunsulag convert this to class nomenclature\nfunction ConferenceRoom(apiCSRFToken, enabledFeatures, translations, scriptLocation)\n{\n    let conf = this;\n\n    this.apiCSRFToken = apiCSRFToken;\n    this.waitingRoomTemplate = null;\n    this.conferenceRoomTemplate = null;\n    this.callerSettings = null;\n    this.features = enabledFeatures; // the features that are enabled from the server.\n    this.telehealthSessionData = null;\n    this.videoBar = null;\n    this.ROOM_TYPE_WAITING = 'waiting';\n    this.ROOM_TYPE_CONFERENCE = 'conference';\n\n    this.buttonSettings = {\n        microphoneEnabled: true\n        ,cameraEnabled: true\n        ,screensharingEnabled: false\n    };\n\n    /**\n     * Milliseconds to update the session information\n     * @type {number}\n     */\n    this.sessionUpdatePollingTime = 5000;\n\n    /**\n     * What type of room this conference room is\n     * @see ROOM_TYPE_WAITING\n     * @see ROOM_TYPE_CONFERENCE\n     * @type string\n     */\n    this.room = null;\n    // TODO: @adunsulag rename this variable to be roomModal\n    this.waitingRoomModal = null;\n\n    /**\n     * Are we currently in the conference room session\n     * @type {boolean}\n     */\n    this.inSession = false;\n\n    /**\n     * The minimized conference room handler\n     * @type {MinimizedConferenceRoom}\n     * @private\n     */\n    this.__minimizedConferenceRoom = null;\n\n    /**\n     * Tracking interval for the conference room session polling\n     * @type {number}\n     */\n    this.sessionUpdateInterval = null;\n\n    this.__hasLocalPermisions = false;\n    /** @private */\n    this.__bridge = null;\n\n    /** @private */\n    this.__localVideoElement = null;\n\n    /**\n     * @type CallerSlot[]\n     * @private\n     * */\n    this.__slots = [];\n\n    /**\n     *\n     * @type CallerSlot\n     * @private\n     */\n    this.__localCaller = null;\n\n    /**\n     *\n     * @type CallerSlot\n     * @private\n     */\n    this.__remoteCaller = null;\n\n    this.__remoteCallSlot = null;\n\n    this.__isShutdown = true;\n\n    this.__callerIdx = 0;\n\n    // let's allow for our max slots for now\n    this.__maxSlots = 3;\n\n    /**\n     *\n     * @type PresentationScreen\n     * @private\n     */\n    this.__presentationScreen = null;\n\n    /**\n     *\n     * @type cvb.VideoCall[]\n     * @private\n     */\n    this.__localScreenshareCalls = [];\n\n    /**\n     *\n     * @type string\n     * @private\n     */\n    this.__focusCallerUuid = null;\n\n\n    /**\n     * Is the conference room currently  minimized\n     * @type {boolean}\n     */\n    this.isMinimized = function() {\n        if (this.__minimizedConferenceRoom) {\n            return this.__minimizedConferenceRoom.isMinimized();\n        }\n        return false;\n    };\n\n\n    this.allocateSlot = function(call, stream) {\n        // as we can get multiple events we only want to allocate on the call if we don't have any stream data setup.\n        if (!call.getUserData()) {\n            // in the event of a network hiccup we go through and allocate the slot\n            let needNewSlot = true;\n            for (var i = 0; i < this.__slots.length; i++) {\n                if (this.__slots[i].isAvailableForCall(call)) {\n                    this.__slots[i].attach(call, stream, this.getParticipantForCall(call));\n                    needNewSlot = false;\n                    break;\n                }\n            }\n            if (needNewSlot && this.__slots.length <= this.__maxSlots) {\n                let newCaller = new _caller_slot_js__WEBPACK_IMPORTED_MODULE_3__.CallerSlot('participant-list-container', this.__callerIdx++);\n                newCaller.addCallerSelectListener(function(callerSlot) {\n                    conf.setCurrentCallerFocusId(callerSlot.getRemotePartyId());\n                    conf.updateParticipantDisplays();\n                });\n                this.__slots.push(newCaller);\n                newCaller.attach(call, stream);\n                if (this.__slots.length <= 2) {\n                    this.__presentationScreen.attach(newCaller);\n                    // TODO: @adunsulag fix this when we work with 3 callers\n                    newCaller.hide();\n                }\n            }\n            // now we need to update our focus caller and participant list if we have it\n            if (this.__slots.length == 1) {\n                // if we only have one person on the call they need to be the focus of the video\n                this.setCurrentCallerFocusId(call.getRemotePartyId());\n                // if the call is the primary patient we want them to be the focus for the provider\n            } else if (call.getRemotePartyId() == conf.callerSettings.calleeUuid) {\n                this.setCurrentCallerFocusId(call.getRemotePartyId());\n            }\n            this.updateParticipantDisplays();\n        }\n    };\n\n    this.updateParticipantDisplays = function() {\n        // based on the mode of the conference room we will update the presentation screen and the participant list\n        let hasPresentationScreen = false;\n        // if we only have one other participant... or the screen is minimized we want to hide the local speaker.\n        let twoWayCall = this.__slots.length <= 1;\n        let isMinimized = this.isMinimized();\n        for (var i = 0; i < this.__slots.length; i++) {\n            if (this.__slots[i].getRemotePartyId() == this.getCurrentCallerFocusId()) {\n                hasPresentationScreen = true;\n                this.__presentationScreen.attach(this.__slots[i]);\n                if (twoWayCall && !isMinimized) {\n                    // hide the remote caller in a two way call in the participant list ONLY if we are not minimized\n                    // as they show up in the presentation screen.\n                    this.__slots[i].hide();\n                } else {\n                    this.__slots[i].show();\n                }\n                // this condition never executes for now as we don't keep a local CallerSlot\n                // if we do, we will leave this in for now\n            } else if (isMinimized && this.__slots[i].getRemotePartyId() == this.getLocalPartyId()) {\n                this.__slots[i].hide(); // hide the local caller from the participant list when we are minimized\n            } else {\n                // make sure we are showing everyone, including ourselves if we don't hide the local speaker\n                this.__slots[i].show();\n            }\n        }\n        // only hide if we are minimized\n        if (this.__localVideoElement) {\n            if (isMinimized) {\n                this.__localVideoElement.classList.add('d-none');\n            } else {\n                this.__localVideoElement.classList.remove('d-none');\n            }\n        }\n\n        // if we get here we are going to just detatch\n        if (!hasPresentationScreen) {\n            this.__presentationScreen.detach();\n        }\n\n        if (this.__slots.length) {\n            this.buttonSettings.screensharingEnabled = true;\n        } else {\n            this.buttonSettings.screensharingEnabled = false;\n        }\n        this.resetConferenceVideoBar();\n    };\n\n    this.isAuthorizedParticipant = function(callerId) {\n        let participantList = this.callerSettings.participantList || [];\n        let participant = participantList.find((p => p.uuid == callerId));\n        return participant !== undefined;\n    };\n\n    this.getRemoteParticipantList = function() {\n        let participantList = this.callerSettings.participantList || [];\n        return participantList.filter(p => p.uuid !== conf.callerSettings.callerUuid);\n    };\n\n    this.getParticipantForCall = function(call) {\n        let participantList = this.callerSettings.participantList || [];\n        let participant = participantList.find((p => p.uuid == call.getRemotePartyId()));\n        return participant;\n    };\n\n    this.setParticipantInCallRoomStatus = function(callerId, status) {\n        status = status == 'Y' ? 'Y' : 'N';\n        let participantList = this.callerSettings.participantList || [];\n        let participant = participantList.find((p => p.uuid == callerId));\n        participant.inRoom = status;\n    };\n\n    this.getLocalPartyId = function() {\n        return conf.callerSettings.callerUuid;\n    };\n\n    /**\n     * Returns the caller slot with the caller id that is passed in.\n     * @param id\n     * @returns {CallerSlot|undefined}\n     */\n    this.findCallerSlotWithId = function(id) {\n        return this.__slots.find(s => s.getRemotePartyId() === id);\n    };\n\n    this.setCurrentCallerFocusId = function(uuid) {\n        this.__focusCallerUuid = uuid;\n    };\n\n    this.getCurrentCallerFocusId = function() {\n        // if we use audio monitoring we can switch, or if the user pins a speaker we can this this\n        // however, for now we focus on the callee for now\n        return this.__focusCallerUuid;\n    };\n\n    this.freeSlot = function(slot) {\n        if (slot !== null && !slot.isAvailable() == null)\n        {\n            console.error(\"freeSlot called with null slot \", {slot: slot});\n            return;\n        }\n        slot.__call.stop();\n        slot.detach();\n        // trying to leave code open in case we add more callers... but we add this in to clear our variables\n        if (slot == conf.__remoteCallSlot)\n        {\n            conf.__remoteCallSlot = null;\n        }\n    };\n\n    this.restartMediaStream = function() {\n        if (conf.__localVideoElement.srcObject) {\n            conf.__bridge.closeLocalMediaStream();\n        }\n\n        return conf.__bridge.getLocalMediaStream()\n            .then(stream => conf.handleLocalMediaStreamStarted(stream))\n            .catch(error => conf.handleLocalMediaStreamFailed(error));\n    };\n    this.handleLocalMediaStreamStarted = function(stream) {\n        conf.__localVideoElement.srcObject = stream;\n        conf.__localVideoElement.play();\n        conf.__hasLocalPermisions = true;\n        conf.toggleJoinButton(conf.shouldEnableJoinButton());\n        conf.togglePermissionBox(false);\n        return conf.__hasLocalPermisions;\n    };\n    this.handleLocalMediaStreamFailed = function(error) {\n        console.error(error);\n        conf.__hasLocalPermisions = false;\n        conf.toggleJoinButton(conf.shouldEnableJoinButton());\n        conf.togglePermissionBox(true);\n        return conf.__hasLocalPermisions;\n    };\n\n    this.startBridge = function() {\n        conf.__localVideoElement = document.getElementById('local-video');\n        conf.__localVideoElement.muted = true;\n\n        conf.__bridge = new _telehealth_bridge_js__WEBPACK_IMPORTED_MODULE_4__.TelehealthBridge(conf.callerSettings.callerUuid, conf.callerSettings.apiKey\n            , conf.callerSettings.serviceUrl);\n\n        let bridgeHandlers = {\n            onincomingcall: conf.handleIncomingCall.bind(conf)\n            ,onbridgeactive: (bridge) => {\n                conf.restartMediaStream();\n            }\n            ,onbridgeinactive: (bridge) => {\n                if (conf.__localVideoElement && conf.__localVideoElement.stop) {\n                    conf.__localVideoElement.stop();\n                    conf.__localVideoElement.srcObject = null;\n                }\n            }\n            ,onbridgefailure: (bridge) => {\n                if (conf.__localVideoElement && conf.__localVideoElement.stop) {\n                    conf.__localVideoElement.stop();\n                }\n                conf.__localVideoElement.srcObject = null;\n                alert(translations.BRIDGE_FAILED);\n            }\n        };\n\n        conf.__bridge.startBridge(bridgeHandlers);\n        conf.__isShutdown = false;\n    };\n\n    conf.shutdown = function()\n    {\n        if (conf.__isShutdown)\n        {\n            return;\n        }\n\n        conf.__bridge.shutdown();\n        conf.__localVideoElement.srcObject = null;\n        console.log(\"Shutting down \" +  conf.callerSettings.callerUuid)\n        conf.__isShutdown = true;\n    };\n\n    this.setCallHandlers = function(call) {\n        // Callback: streams updated\n        //\n        call.oncallstarted = (call) => {\n            conf.handleCallStartedEvent(call);\n        };\n        // Once we have the remote stream we'll allocate a video slot.\n        call.onstreamupdated =\n            (call, stream) => {\n                console.log(\"onstreamupdated \" + conf.callerSettings.calleeUuid);\n                conf.allocateSlot(call, stream);\n            };\n\n        // Callback: call ended\n        //\n        // When the call ends we free the video slot.\n        call.oncallended = (call) => {\n            conf.handleCallEndedEvent(call);\n        };\n    };\n\n    /**\n     * Used to make a video call to the bridge\n     * @param calleeId\n     */\n    this.makeCall = function(calleeId) {\n        const call = conf.__bridge.createVideoCall(calleeId);\n\n        conf.setCallHandlers(call);\n\n        // Callback: outbound call rejected\n        //\n        // If the call is rejected we do nothing. We know that in that case the\n        // stream will not have been created and, consequently, we will not have\n        // created the video element.\n        call.oncallrejected = (call) => {\n            console.log(call);\n            console.log(\"oncallrejected \" + conf.callerSettings.calleeUuid);\n            // if the call is rejected the provider dropped off before we connected so we go back to the conference\n            // room\n            conf.handleCallEndedEvent(call);\n        };\n\n        // Finally, start the call\n        call.start().catch((e) => {\n            alert(translations.CALL_CONNECT_FAILED);\n            console.log(\"call exception \" + conf.callerSettings.calleeUuid);\n            console.error(e);\n            conf.handleCallEndedEvent(call);\n        });\n        return call;\n    };\n\n    /**\n     * Returns true if the local caller is currently sharing the screen.\n     * @returns {boolean}\n     */\n    this.isScreensharing = function() {\n        return this.__localScreenshareCalls.length > 0;\n    };\n\n    this.removeLocalScreensharingCall = function(calleeId) {\n        let index = this.__localScreenshareCalls.findIndex(c => c.getRemotePartyId() == calleeId);\n        if (index >= 0) {\n            this.__localScreenshareCalls.splice(index, 1);\n        }\n    };\n\n    this.makeScreenshareCall = function(calleeId) {\n        const call = conf.__bridge.createScreenSharingCall(calleeId);\n        // conf.setCallHandlers(call);\n        // for now we duplicate this as we play around to see how this works.\n        this.__localScreenshareCalls.push(call);\n        call.start().catch((e) => {\n            alert(translations.CALL_CONNECT_FAILED);\n            console.log(\"call exception \" + conf.callerSettings.calleeUuid);\n            console.error(e);\n            // conf.handleCallEndedEvent(call);\n            this.removeLocalScreensharingCall(calleeId);\n\n        });\n        call.oncallended = (call) => {\n            this.removeLocalScreensharingCall(calleeId);\n        };\n    };\n\n    this.enableMicrophone = function(flag) {\n        conf.__bridge.enableMicrophone(flag);\n    };\n\n    this.enableCamera = function(flag) {\n        conf.__bridge.enableCamera(flag);\n    };\n\n    this.hasLocalPermissionsEnabled = function()\n    {\n        return conf.__hasLocalPermisions;\n    };\n\n\n    /**\n     * Checks to make sure that the user with the given calleeId is allowed to talk to the current conference room caller\n     * @param call The call that we are going to verify\n     * @returns {Promise<boolean>}\n     */\n    this.canReceiveCall = function(call)\n    {\n        let callerId = call.getRemotePartyId();\n        // TODO: @adunsulag check to make sure we don't need to hit the server... we already have the calleeUuid which we got\n        // from the server... we can double check again by hitting the server and verifying the session has started and accept\n        // the call, but that seems pretty paranoid to double check that...\n        if (this.isAuthorizedParticipant(callerId))\n        {\n            return Promise.resolve({call: call, canCall: true});\n        }\n        else\n        {\n            return Promise.resolve({call: call, canCall: false});\n        }\n    };\n\n    this.getRemoteScriptLocation = function()\n    {\n        return scriptLocation;\n    };\n\n    this.getTelehealthLaunchData = function(data)\n    {\n        var scriptLocation = this.getRemoteScriptLocation() + '?action=get_telehealth_launch_data&eid=' + encodeURIComponent(data.pc_eid);\n        window.top.restoreSession();\n        return window.fetch(scriptLocation, {redirect: \"manual\"});\n    };\n\n    this.setupProviderWaitingRoom = function()\n    {\n        let modal = this.createModalWithContent(conf.waitingRoomTemplate);\n        // // now we will attach all of our event listeners here onto the document content.\n        let container = document.getElementById('telehealth-container');\n        conf.initWaitingRoomEvents(container);\n        conf.waitingRoomModal = modal;\n        conf.waitingRoomModal.show();\n    };\n\n    this.setupWaitingRoom = function()\n    {\n        conf.setupProviderWaitingRoom();\n    };\n\n    this.handleIncomingCall = function(call)\n    {\n\n        // we will hit the server to verify that the caller can actually make this call\n        this.canReceiveCall(call)\n            .then((result) => {\n                if (!result.canCall) {\n                    console.log(\"Call from \" + result.call.getRemotePartyId() + \" not authorized by server for \"  + conf.callerSettings.callerUuid);\n                    result.call.reject();\n                    return;\n                }\n\n                conf.setCallHandlers(result.call);\n                result.call.accept();\n                console.log(\"Call accepted from \" + result.call.getRemotePartyId() + \" for \"  + conf.callerSettings.callerUuid);\n                // NOTE that result.call.accept does NOT fire the oncallstarted event for the call stream... so we have to\n                // toggle our remote video here instead.\n                conf.toggleRemoteVideo(true);\n\n                // mark the participant as being in the room\n                conf.setParticipantInCallRoomStatus(result.call.getRemotePartyId(), 'Y');\n            })\n            .catch(error => {\n                call.reject();\n            });\n    };\n\n    this.init = function(data)\n    {\n        if (!data.pc_eid)\n        {\n            alert(translations.SESSION_LAUNCH_FAILED);\n            return;\n        }\n\n        conf.telehealthSessionData = data;\n        // we grab everything up front as anything dealing with video playback needs to be triggered by a button on iOS devices\n        // so we have to make sure we grab everything here.\n\n        // we could also make sure we create users when we update... that would resolve the issue as well.\n        let getLaunchData = conf.getTelehealthLaunchData(data);\n\n        getLaunchData\n            .then(function(result) {\n                if (!(result.ok && result.status == 200)) {\n                    throw new Error(\"Failed to fetch data\");\n                }\n\n                return result.json();\n            })\n            .then(launchData => {\n                conf.inSession = true;\n                conf.callerSettings = launchData.callerSettings;\n                conf.setCurrentCallerFocusId(launchData.callerSettings.calleeUuid);\n                conf.waitingRoomTemplate = launchData.waitingRoom;\n                conf.conferenceRoomTemplate = launchData.conferenceRoom;\n                conf.setupWaitingRoom();\n                conf.startBridge();\n                conf.room = conf.ROOM_TYPE_WAITING;\n            })\n            .catch(function(error) {\n                console.error(error);\n                // null out our values if we never started our session.\n                if (!conf.__bridge) {\n                    alert(translations.SESSION_LAUNCH_FAILED);\n                    conf.destruct(); // shut things down if we don't have a valid session.\n                }\n            });\n    };\n\n    this.destruct = function()\n    {\n        // TODO: @adunsulag remove this debug\n        console.log(\"conference-room.destruct() called\");\n        conf.inSession = false;\n        conf.waitingRoomTemplate = null;\n        conf.conferenceRoomTemplate = null;\n        if (conf.videoBar) {\n            conf.videoBar.destruct();\n            conf.videoBar = null;\n        }\n        if (conf.room == conf.ROOM_TYPE_WAITING)\n        {\n            // TODO: do any cleanup needed here\n        }\n        else if (conf.room == conf.ROOM_TYPE_CONFERENCE)\n        {\n            // TODO: do any cleanup needed here.\n        }\n        if (conf.sessionUpdateInterval !== null)\n        {\n            clearInterval(conf.sessionUpdateInterval);\n            conf.sessionUpdateInterval = null;\n        }\n        let container = document.getElementById('telehealth-container');\n\n        if (conf.__bridge && conf.__bridge.shutdown)\n        {\n            // catch any problems from the library so we can still clean up.\n            try {\n                conf.__bridge.shutdown();\n            }\n            catch (error)\n            {\n                console.error(error);\n            }\n        }\n        if (container && container.parentNode)\n        {\n            container.parentNode.removeChild(container);\n        }\n\n        if (conf.isMinimized())\n        {\n            this.__minimizedConferenceRoom.destruct();\n            this.__minimizedConferenceRoom = null;\n        }\n        conf.callerSettings = null;\n        conf.telehealthSessionData = null;\n    };\n\n    this.initModalEvents = function(container)\n    {\n        var elements = document.getElementsByClassName('btn-telehealth-provider-close');\n        for (var i = 0; i < elements.length; i++)\n        {\n            elements[i].addEventListener('click', conf.handleCallHangup);\n        }\n    };\n\n    this.initWaitingRoomEvents = function(container)\n    {\n        conf.videoBar = new _video_bar_js__WEBPACK_IMPORTED_MODULE_2__.VideoBar(container, conf.getWaitingRoomVideoBarSettings());\n        conf.toggleJoinButton(conf.shouldEnableJoinButton());\n    };\n\n    this.togglePermissionBox = function(enabled)\n    {\n        let box = document.querySelector('#telehealth-container .permissions-box');\n        let boxRestartBtn = document.querySelector('#telehealth-container .permissions-box .restart-media-btn');\n        if (box && boxRestartBtn)\n        {\n            if (enabled) {\n                boxRestartBtn.addEventListener('click', conf.recaptureLocalMedia);\n                box.classList.remove('d-none');\n            } else {\n                box.classList.add('d-none');\n                boxRestartBtn.removeEventListener('click', conf.recaptureLocalMedia);\n            }\n        } else {\n            console.error(\"Could not find permissions box dom nodes\");\n        }\n    };\n\n    this.recaptureLocalMedia = function()\n    {\n        if (conf.__bridge && !conf.__bridge.isShutdown)\n        {\n            conf.__bridge.shutdown();\n        }\n        conf.startBridge(); // start the bridge over again since we couldn't capture the local media the first time.\n    };\n\n    this.shouldEnableJoinButton = function()\n    {\n        return conf.hasLocalPermissionsEnabled();\n    };\n\n    this.toggleJoinButton = function(enabled)\n    {\n        let btnJoin = document.querySelectorAll('.btn-comlink-conference-join');\n        if (btnJoin && btnJoin.length) {\n            for (let i = 0; i < btnJoin.length; i++) {\n                if (enabled) {\n                    btnJoin[i].addEventListener('click', conf.startConferenceRoom);\n                    btnJoin[i].classList.remove('disabled');\n                    btnJoin[i].disabled = false;\n                } else {\n                    btnJoin[i].removeEventListener('click', conf.startConferenceRoom);\n                    btnJoin[i].classList.add('disabled');\n                    btnJoin[i].disabled = true;\n                }\n            }\n        }\n    };\n\n    this.sessionClose = function()\n    {\n        let conf = this;\n        if (conf.isMinimized())\n        {\n            conf.destruct();\n        }\n        else {\n            // have to use jquery to grab the jquery event\n            jQuery(\"#telehealth-container\").on(\"hidden.bs.modal\", function () {\n                jQuery(\"#telehealth-container\").off(\"hidden.bs.modal\");\n                conf.destruct()\n            });\n            conf.waitingRoomModal.hide();\n        }\n    };\n\n    this.confirmSessionClose = function()\n    {\n        if (conf.room == conf.ROOM_TYPE_WAITING)\n        {\n            conf.sessionClose();\n        }\n        else {\n            let dialog = new _confirm_session_close_dialog_js__WEBPACK_IMPORTED_MODULE_0__.ConfirmSessionCloseDialog(translations, conf.telehealthSessionData.pc_eid, conf.getRemoteScriptLocation(), function() {\n                conf.sessionClose();\n            });\n            dialog.show();\n        }\n    };\n\n    this.shutdownProviderWaitingRoom =  function()\n    {\n        let container = document.getElementById('telehealth-container');\n        if (conf.__bridge && conf.__bridge.shutdown)\n        {\n            // catch any problems from the library so we can still clean up.\n            try {\n                conf.__bridge.shutdown();\n            }\n            catch (error)\n            {\n                console.error(error);\n            }\n        }\n        if (container && container.parentNode)\n        {\n            container.parentNode.removeChild(container);\n        }\n        conf.callerSettings = null;\n        conf.telehealthSessionData = null;\n    };\n\n    this.createModalWithContent = function(content)\n    {\n        let bootstrapModalTemplate = window.document.createElement('div');\n        // we use min-height 90vh until we get the bootstrap full screen modal in bootstrap 5\n        // TODO: @adunsulag now that both patient & portal are using the same dialog we can probably move this server side\n        // into the waiting room template.\n        bootstrapModalTemplate.innerHTML = `<div class=\"modal fade\" id=\"telehealth-container\" tabindex=\"-1\" aria-hidden=\"true\">\n              <div class=\"modal-dialog mw-100 ml-2 mr-2\">\n                <div class=\"modal-content\">\n                  <div class=\"modal-header\">\n                    <h5 class=\"modal-title\">` + jsText(translations.TELEHEALTH_MODAL_TITLE) + `</h5>\n                    <button type=\"button\" class=\"close btn-telehealth-provider-close\" aria-label=\"Close\">\n                      <span aria-hidden=\"true\">&times;</span>\n                    </button>\n                  </div>\n                  <div class=\"modal-body d-flex\">\n                  ${content}\n                  </div>\n                </div>\n              </div>\n            </div>`;\n        window.document.body.appendChild(bootstrapModalTemplate.firstElementChild);\n        var container = document.getElementById('telehealth-container');\n        conf.waitingRoomModal = new bootstrap.Modal(container, {keyboard: false, focus: true, backdrop: 'static'});\n        conf.initModalEvents(container);\n        return conf.waitingRoomModal;\n    };\n\n    this.startConferenceRoom = function()\n    {\n        conf.startProviderConferenceRoom();\n    };\n\n    this.startProviderConferenceRoom = function()\n    {\n        let container = document.getElementById('telehealth-container');\n        // now grab our video container in our modal\n        let video = document.getElementById(\"local-video\");\n\n        conf.videoBar.destruct();\n\n        // now we are going to replace the modal content\n        let modalBody = container.querySelector('.modal-body');\n        // clear out the modal body\n        do {\n            modalBody.removeChild(modalBody.firstChild);\n        } while (modalBody.childNodes.length);\n        modalBody.innerHTML = conf.conferenceRoomTemplate;\n\n        // now let's replace our template video container with our original video container from the waiting room.\n        let conferenceVideo = document.getElementById('local-video');\n        if (conferenceVideo && conferenceVideo.parentNode) {\n            conferenceVideo.parentNode.replaceChild(video, conferenceVideo);\n        }\n        conf.videoBar = new _video_bar_js__WEBPACK_IMPORTED_MODULE_2__.VideoBar(this.getVideoBarContainer(), conf.getFullConferenceVideoBarSettings());\n        conf.inConferenceRoom = true;\n        conf.room = conf.ROOM_TYPE_CONFERENCE;\n\n        this.sessionUpdateInterval = setInterval(conf.updateConferenceRoomSession.bind(conf), conf.sessionUpdatePollingTime);\n        this.__presentationScreen = new _presentation_screen__WEBPACK_IMPORTED_MODULE_5__.PresentationScreen('presentation-screen');\n        conf.updateConferenceRoomSession();\n    };\n\n    this.updateConferenceRoomSession = function() {\n        let appt = conf.callerSettings.appointment || {};\n        let eid = appt.eid || {};\n        // TODO: if we ever need to take action on the session update we would do that here.\n        // TODO: @adunsulag change eid here to be pc_eid\n        window.top.restoreSession();\n        window.fetch(conf.getRemoteScriptLocation() + '?action=conference_session_update&eid=' + encodeURIComponent(eid), {redirect: \"manual\"})\n            .then((request) => {\n                if (request.ok) {\n                    return request.json();\n                } else {\n                    throw new Error(\"Failed to update session\");\n                }\n            })\n            .catch(error => console.error(\"Conference session update \", error));\n    };\n\n    this.cancelUpdateConferenceRoomSession = function()\n    {\n        if (conf.sessionUpdateInterval)\n        {\n            window.clearInterval(conf.sessionUpdateInterval);\n        }\n    };\n\n    this.getDefaultVideoBarSettings = function()\n    {\n        var noop = function() {};\n\n        return {\n            notes: false\n            ,notesCallback: noop\n            ,microphone: conf.buttonSettings.microphoneEnabled\n            ,microphoneCallback: conf.toggleMicrophone.bind(conf)\n            ,video: conf.buttonSettings.cameraEnabled\n            ,videoCallback: conf.toggleVideo.bind(conf)\n            ,expand: false\n            ,expandCallback: noop\n            ,hangup: false\n            ,hangupCallback: noop\n            ,screenshare: conf.buttonSettings.screensharingEnabled\n            ,screenshareCallback: conf.toggleScreenSharing.bind(conf)\n        };\n    };\n\n    this.getWaitingRoomVideoBarSettings = function()\n    {\n        return conf.getDefaultVideoBarSettings();\n    };\n\n    this.getMinimizedConferenceVideoBarSettings = function()\n    {\n        let settings = conf.getDefaultVideoBarSettings();\n        settings.expandCallback = conf.maximizeProviderConferenceCall.bind(conf);\n        settings.hangupCallback = conf.handleCallHangup.bind(conf);\n        settings.expand = true;\n        settings.notes = false;\n        settings.hangup = true;\n        settings.screenshare = true;\n        return settings;\n    };\n\n    this.addSettingsForScreenshare = function(settings) {\n        if (this.__slots.length) {\n            settings.screenshare = true;\n        } else {\n            settings.screenshare = false;\n        }\n    };\n\n    this.addSettingsForThirdPartyInvitations = function(settings) {\n        if (conf.features && conf.features.thirdPartyInvitations)\n        {\n            settings.invite = true;\n            settings.inviteCallback = conf.handleInviteCallback.bind(conf);\n        } else {\n            settings.invite = false;\n        }\n    };\n\n    this.getFullConferenceVideoBarSettings = function()\n    {\n        let settings = conf.getDefaultVideoBarSettings();\n        settings.hangupCallback = conf.handleCallHangup.bind(conf);\n        settings.notesCallback = conf.minimizeProviderConferenceCall.bind(conf);\n        settings.expand = false;\n        settings.notes = true;\n        settings.hangup = true;\n        conf.addSettingsForThirdPartyInvitations(settings);\n        conf.addSettingsForScreenshare(settings);\n        return settings;\n    };\n\n    this.handleInviteCallback = function() {\n        let dialog = new _add_patient_dialog__WEBPACK_IMPORTED_MODULE_7__.AddPatientDialog(this.apiCSRFToken, translations, conf.telehealthSessionData.pc_eid\n            , conf.getRemoteScriptLocation(), conf.callerSettings.thirdPartyPatient, function(callerSettings) {\n            // make suer we update our caller settings with the newly allowed patient so the provider can receive the call\n            if (callerSettings) {\n                conf.callerSettings = callerSettings;\n            }\n            });\n        dialog.show();\n    };\n\n    this.handleCallStartedEvent = function(call)\n    {\n        conf.toggleRemoteVideo(true);\n    };\n\n    this.resetConferenceVideoBar = function() {\n        if (conf.videoBar) {\n            conf.videoBar.destruct();\n        }\n        if (conf.__isShutdown) {\n            return; // nothing to do here as we are shutting down.\n        }\n        if (this.isMinimized()) {\n            conf.videoBar = this.__minimizedConferenceRoom.resetConferenceVideoBar(conf.getMinimizedConferenceVideoBarSettings());\n        } else {\n            conf.videoBar = new _video_bar_js__WEBPACK_IMPORTED_MODULE_2__.VideoBar(this.getVideoBarContainer(), conf.getFullConferenceVideoBarSettings());\n        }\n    };\n\n    this.getVideoBarContainer = function() {\n        var container = document.getElementById('telehealth-container');\n        return container.querySelector('.conference-room .telehealth-button-bar');\n    };\n\n    this.removeCallFromConference = function(call) {\n        if (call.getUserData() != null) {\n            /**\n             *\n             * @type {CallerSlot|null}\n             */\n            let callerSlot = call.getUserData();\n            if (call.isScreenSharing()) {\n                callerSlot.detachScreenshare();\n            }\n            else {\n                this.removeSlotForCall(call);\n            }\n            conf.setParticipantInCallRoomStatus(call.getRemotePartyId(), 'N');\n            this.updateParticipantDisplays();\n        }\n    };\n\n    // todo: look at removing this\n    this.removeSlotForCall = function(call) {\n        // if the user data is allocated then this is an existing call\n        if (call.getUserData() != null) {\n            let callerSlot = call.getUserData();\n            let remotePartyId = callerSlot.getRemotePartyId();\n            callerSlot.destruct(); // remove everything\n            // cleanup the slots\n            this.__slots = this.__slots.filter(s => s !== callerSlot);\n            if (this.__slots.length && this.getCurrentCallerFocusId() == remotePartyId) {\n                // need to set our current caller focus id\n                // for now we will just set it to the first one on the call instead of trying to figure out\n                // the last known audio chatting\n                this.setCurrentCallerFocusId(this.__slots[0].getRemotePartyId());\n            }\n        }\n    };\n\n    this.hasRemoteParticipants = function() {\n        let hasParticipants = this.__slots.length > 0;\n        return hasParticipants;\n    }\n\n    // for the provider conference we end the call and we then show our waiting message\n    this.handleCallEndedEvent = function(call)\n    {\n        conf.removeCallFromConference(call);\n        // if we don't have any more slots available\n        if (!conf.hasRemoteParticipants()) {\n            if (!conf.__isShutdown) {\n                conf.toggleRemoteVideo(false);\n            }\n        }\n    };\n\n    this.handleCallHangup = function()\n    {\n        // if we hangup the call we maximize the window since the confirm dialog is embedded inside the\n        // main window.\n        if (conf.isMinimized()) {\n            conf.maximizeProviderConferenceCall({});\n        }\n        conf.confirmSessionClose();\n    };\n\n    this.minimizeProviderConferenceCall = function()\n    {\n        this.__minimizedConferenceRoom = new _minimized_conference_room__WEBPACK_IMPORTED_MODULE_8__.MinimizedConferenceRoom(document.getElementById('telehealth-container'));\n        this.__minimizedConferenceRoom.minimizeConferenceRoom(this.getMinimizedConferenceVideoBarSettings());\n        this.resetConferenceVideoBar(); // make sure we reset our controls here before we continue\n        conf.waitingRoomModal.hide();\n        this.updateParticipantDisplays();\n    };\n\n    this.maximizeProviderConferenceCall = function(evt)\n    {\n        if (this.isMinimized()) {\n            this.__minimizedConferenceRoom.maximizeConferenceRoom();\n            this.__minimizedConferenceRoom.destruct();\n            this.__minimizedConferenceRoom = null;\n\n\n            // everything's moved we can now display the larger video modal.\n            if (conf.waitingRoomModal) {\n                conf.waitingRoomModal.show();\n            } else {\n                console.error(\"Failed to find waitingRoomModal\");\n            }\n        }\n        this.updateParticipantDisplays();\n    };\n\n\n    this.toggleMicrophone = function(event)\n    {\n        let node = event.target;\n        if (!node.classList.contains('fa'))\n        {\n            node = node.querySelector('.fa');\n        }\n        let toggle = !conf.buttonSettings.microphoneEnabled;\n        conf.buttonSettings.microphoneEnabled = toggle;\n        node.dataset.enabled = toggle;\n        if (conf.__bridge && conf.__bridge.enableMicrophone) {\n            conf.__bridge.enableMicrophone(toggle);\n        } else {\n            console.error(\"__bridge is not initalized and cannot toggle microphone\");\n        }\n        toggleClass(node, toggle, 'fa-microphone','fa-microphone-slash');\n    };\n\n    this.toggleVideo = function(event)\n    {\n        let node = event.target;\n        if (!node.classList.contains('fa'))\n        {\n            node = node.querySelector('.fa');\n        }\n        let toggle = !conf.buttonSettings.cameraEnabled;\n        conf.buttonSettings.cameraEnabled = toggle;\n        // TODO: @adunsulag remove this reliance on the node.dataset here.\n        node.dataset.enabled = toggle;\n        if (conf.__bridge && conf.__bridge.enableCamera) {\n            conf.__bridge.enableCamera(toggle);\n        } else {\n            console.error(\"app is not initalized and cannot toggle microphone\");\n        }\n        toggleClass(node, toggle, 'fa-video','fa-video-slash');\n    };\n\n    this.toggleRemoteVideo = function(display)\n    {\n        var container = document.getElementById('telehealth-container');\n        var waitingContainer = container.querySelector('.waiting-container');\n        var remoteVideo = container.querySelector('.remote-video');\n\n        if (display)\n        {\n            waitingContainer.classList.add('d-none');\n            remoteVideo.classList.remove('d-none');\n        } else {\n            waitingContainer.classList.remove('d-none');\n            remoteVideo.classList.add('d-none');\n        }\n    };\n\n    this.toggleScreenSharing = function(evt) {\n        let participantList = this.getRemoteParticipantList();\n        participantList.forEach(p => {\n            // only call people who are in the room.\n            if (p.inRoom == 'Y') {\n                this.makeScreenshareCall(p.uuid);\n            }\n        });\n    };\n\n\n    // don't really need any class member variables here so we will let JS hoist this up.\n    function toggleClass(node, toggle, onClass, offClass)\n    {\n        if (toggle) {\n            node.classList.add(onClass);\n            node.classList.remove(offClass);\n        } else {\n            node.classList.add(offClass);\n            node.classList.remove(onClass);\n        }\n    }\n\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/conference-room.js?");

/***/ }),

/***/ "./src/configure-session-call-dialog.js":
/*!**********************************************!*\
  !*** ./src/configure-session-call-dialog.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConfigureSessionCallDialog\": function() { return /* binding */ ConfigureSessionCallDialog; }\n/* harmony export */ });\n\nclass ConfigureSessionCallDialog\n{\n    /**\n     *\n     * @type {bootstrap.Modal}\n     */\n    modal = null;\n\n    /**\n     *\n     * @type HTMLElement\n     */\n    container = null;\n\n    /**\n     *\n     * @type {number}\n     */\n    pc_eid = null;\n\n    /**\n     *\n     * @type {string}\n     */\n    scriptLocation = null;\n\n    /**\n     *\n     * @type {function}\n     */\n    closeCallback = null;\n\n    /**\n     * Because javascript is asinine in treating 'this' with bound functions we have these pointers.\n     * Modern JS allows us to 'overload' the 'get' parameter to handle this better but its still dumb.\n     * Makes me almost tempted to go back to jquery's on/off functionality.\n     * @type {function}\n     * @private\n     */\n    __cancelDialog = null;\n    __updateSettingsAndCloseDialog = null;\n\n    constructor(pc_eid, scriptLocation, closeCallback) {\n        this.pc_eid = pc_eid;\n        this.scriptLocation = scriptLocation;\n        this.closeCallback = closeCallback;\n        this.__cancelDialog = this.cancelDialog.bind(this);\n        this.__updateSettingsAndCloseDialog = this.updateSettingsAndCloseDialog.bind(this);\n    }\n\n    cancelDialog() {\n        let modal = this.modal;\n        this.destruct();\n        modal.hide();\n    }\n\n    processConfirmYesAction(evt) {\n        this.container.querySelector('.row-confirm').classList.add('d-none');\n        this.container.querySelector('.row-update-status').classList.remove('d-none');\n    }\n\n    sendSettingsSave(settings)\n    {\n        console.log(\"Saving session settings to \", settings);\n        let postData = Object.assign({pc_eid: this.pc_eid}, settings);\n        let scriptLocation = this.scriptLocation + \"action=save_session_settings\";\n\n        window.top.restoreSession();\n        window.fetch(scriptLocation,\n            {\n                method: 'POST'\n                ,headers: {\n                    'Content-Type': 'application/json'\n                }\n                ,body: postData\n                ,redirect: 'manual'\n            })\n            .then(result => {\n                if (!(result.ok && result.status == 200))\n                {\n                    // TODO: @adunsulag update the session title here...\n                    alert(translations.APPOINTMENT_STATUS_UPDATE_FAILED);\n                    console.error(\"Failed to update session \" + this.pc_eid + \" with settings \" + settings);\n                }\n            });\n    };\n\n    getSettings() {\n        let thirdPartyEnabledNode = document.querySelector(\"input[name='enable-participant-invite']\");\n        let checked = thirdPartyEnabledNode && thirdPartyEnabledNode.checked;\n        let settings = {\n            \"enableThirdParty\": checked == true\n        };\n        return settings;\n    }\n    updateSettingsAndCloseDialog()\n    {\n\n        jQuery(this.container).on(\"hidden.bs.modal\", () => {\n            try {\n                jQuery(this.container).off(\"hidden.bs.modal\");\n                // settings saved and being returned to the callback.\n                this.closeCallback(this.getSettings());\n            }\n            catch (error)\n            {\n                console.error(error);\n            }\n            try {\n                this.sendSettingsSave(this.getSettings());\n            }\n            catch (updateError)\n            {\n                console.error(updateError);\n            }\n        });\n        this.modal.hide();\n    }\n\n    setupModal() {\n        let id = 'telehealth-container-configure-session';\n        // let bootstrapModalTemplate = window.document.createElement('div');\n        // we use min-height 90vh until we get the bootstrap full screen modal in bootstrap 5\n        this.container = document.getElementById(id);\n        this.modal = new bootstrap.Modal(this.container, {keyboard: false, focus: true, backdrop: 'static'});\n\n        let btns = this.container.querySelectorAll('.btn-telehealth-confirm-cancel');\n        for (var i = 0; i < btns.length; i++)\n        {\n            btns[i].addEventListener('click', this.__cancelDialog);\n        }\n        let updateSettings = this.container.querySelector('.btn-telehealth-session-update');\n        if (updateSettings)\n        {\n            updateSettings.addEventListener('click', this.__updateSettingsAndCloseDialog);\n        } else {\n            console.error(\"Could not find selector with .btn-telehealth-confirm-yes\");\n        }\n    }\n\n    resetModal() {\n    }\n\n    show() {\n        if (!this.modal) {\n            this.setupModal();\n        }\n\n        this.modal.show();\n    }\n\n    destruct() {\n        let btns = this.container.querySelectorAll('.btn-telehealth-confirm-cancel');\n        for (var i = 0; i < btns.length; i++)\n        {\n            btns[i].removeEventListener('click', this.__cancelDialog);\n        }\n        let updateSettings = this.container.querySelector('.btn-telehealth-session-update');\n        if (updateSettings)\n        {\n            updateSettings.removeEventListener('click', this.__updateSettingsAndCloseDialog);\n        } else {\n            console.error(\"Could not find selector with .btn-telehealth-confirm-yes\");\n        }\n    }\n}\n\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/configure-session-call-dialog.js?");

/***/ }),

/***/ "./src/confirm-session-close-dialog.js":
/*!*********************************************!*\
  !*** ./src/confirm-session-close-dialog.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConfirmSessionCloseDialog\": function() { return /* binding */ ConfirmSessionCloseDialog; }\n/* harmony export */ });\n\nfunction ConfirmSessionCloseDialog(translations, pc_eid, scriptLocation, closeCallback)\n{\n    let dialog = this;\n    let modal = null;\n    let container = null;\n\n    this.cancelDialog = function()\n    {\n        // reset everything here.\n        let sections = container.querySelectorAll(\".hangup-section\");\n        let startSection = container.querySelector('.hangup-section.hangup-section-start');\n        if (sections && sections.length)\n        {\n            for (let i =0; i < sections.length; i++)\n            {\n                sections[i].classList.add(\"d-none\");\n            }\n        }\n        if (startSection)\n        {\n            startSection.classList.remove(\"d-none\");\n        }\n\n        modal.hide();\n    };\n\n    this.processConfirmYesAction = function(evt) {\n        container.querySelector('.row-confirm').classList.add('d-none');\n        container.querySelector('.row-update-status').classList.remove('d-none');\n    };\n\n    this.sendAppointmentStatusUpdate = function(status)\n    {\n        console.log(\"Setting appointment to status \", status);\n        let postData = \"action=set_appointment_status&pc_eid=\" + encodeURIComponent(pc_eid) + \"&status=\" + encodeURIComponent(status);\n        window.top.restoreSession();\n        window.fetch(scriptLocation,\n            {\n                method: 'POST'\n                ,headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n                ,body: postData\n                ,redirect: 'manual'\n            })\n            .then(result => {\n                if (!(result.ok && result.status == 200))\n                {\n                    alert(translations.APPOINTMENT_STATUS_UPDATE_FAILED);\n                    console.error(\"Failed to update appointment \" + pc_eid + \" to status \" + status);\n                }\n            });\n    };\n\n    this.updateAppointmentStatusAndClose = function(status)\n    {\n\n        jQuery(container).on(\"hidden.bs.modal\", function () {\n            try {\n                jQuery(container).off(\"hidden.bs.modal\");\n                closeCallback();\n            }\n            catch (error)\n            {\n                console.error(error);\n            }\n            try {\n                if (status != 'CloseWithoutUpdating')\n                {\n                    dialog.sendAppointmentStatusUpdate(status);\n                }\n            }\n            catch (updateError)\n            {\n                console.error(updateError);\n            }\n        });\n        modal.hide();\n    };\n\n    this.processHangupSetting = function(evt)\n    {\n        let target = evt.currentTarget;\n        let status = target.dataset['status'] || 'CloseWithoutUpdating'; // - means none\n        dialog.updateAppointmentStatusAndClose(status);\n    };\n\n    this.processSetStatusFromSelector = function(evt)\n    {\n        let selector = container.querySelector('.appointment-status-update');\n        if (selector && selector.value)\n        {\n            dialog.updateAppointmentStatusAndClose(selector.value);\n        } else {\n            console.error(\"Failed to find selector .appointment-status-update node or value is not defined for node\");\n        }\n    };\n\n    this.show = function() {\n        let id = 'telehealth-container-hangup-confirm';\n        // let bootstrapModalTemplate = window.document.createElement('div');\n        // we use min-height 90vh until we get the bootstrap full screen modal in bootstrap 5\n        container = document.getElementById(id);\n        modal = new bootstrap.Modal(container, {keyboard: false, focus: true, backdrop: 'static'});\n\n        let btns = container.querySelectorAll('.btn-telehealth-confirm-cancel');\n        for (var i = 0; i < btns.length; i++)\n        {\n            btns[i].addEventListener('click', dialog.cancelDialog);\n        }\n        let confirmYes = container.querySelector('.btn-telehealth-confirm-yes');\n        if (confirmYes)\n        {\n            confirmYes.addEventListener('click', dialog.processConfirmYesAction);\n        } else {\n            console.error(\"Could not find selector with .btn-telehealth-confirm-yes\");\n        }\n\n        let statusOtherUpdateBtn = container.querySelector('.btn-telehealth-session-select-update');\n        if (statusOtherUpdateBtn)\n        {\n            statusOtherUpdateBtn.addEventListener('click', dialog.processSetStatusFromSelector);\n        }\n\n        btns = container.querySelectorAll('.btn-telehealth-session-close');\n        for (var i = 0; i < btns.length; i++)\n        {\n            btns[i].addEventListener('click', dialog.processHangupSetting);\n        }\n        modal.show();\n    }\n}\n\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/confirm-session-close-dialog.js?");

/***/ }),

/***/ "./src/cvb.min.js":
/*!************************!*\
  !*** ./src/cvb.min.js ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VideoBridge\": function() { return /* binding */ l; },\n/* harmony export */   \"VideoCall\": function() { return /* binding */ c; },\n/* harmony export */   \"getVersion\": function() { return /* binding */ o; }\n/* harmony export */ });\nfunction t(t, i) {\n    if (!t) throw new Error(i)\n}\n\nclass i {\n    static invokeAndIgnoreExceptions(t) {\n        try {\n            t()\n        } catch (t) {\n            console.log(\"Ignoring exception in user callback: \" + t)\n        }\n    }\n}\n\nclass s {\n    constructor(t) {\n        this.t = t, this.i = \"\", this.h = new TextDecoder(\"utf-8\"), this.o = !1\n    }\n\n    cancel() {\n        this.t.cancel()\n    }\n\n    eof() {\n        return this.o\n    }\n\n    l() {\n        const t = this.i.indexOf(\"\\r\\n\");\n        if (-1 == t) return null;\n        const i = this.i.substr(0, t);\n        return this.i = this.i.substr(t + 2), i\n    }\n\n    u() {\n        return this.t.read().then((t => {\n            if (t.done) return this.o = !0, Promise.resolve(this.i);\n            this.i += this.h.decode(t.value);\n            const i = this.l();\n            return i ? Promise.resolve(i) : this.u()\n        }))\n    }\n\n    readEvent() {\n        if (this.o) return Promise.reject();\n        const t = this.l();\n        return t ? Promise.resolve(t) : this.u()\n    }\n}\n\nclass e {\n    constructor(t) {\n        this._ = t\n    }\n\n    v(t, i) {\n        return fetch(this._ + t, {\n            method: \"POST\",\n            cache: \"no-cache\",\n            headers: {\"Content-Type\": \"application/json\"},\n            body: JSON.stringify(i)\n        }).then((t => t.ok ? t.json() : Promise.reject(t.status)))\n    }\n\n    p(t, i) {\n        return fetch(this._ + t, {\n            method: \"POST\",\n            cache: \"no-cache\",\n            headers: {\"Content-Type\": \"application/json\"},\n            body: JSON.stringify(i)\n        })\n    }\n\n    createBridge(t, i, s) {\n        const e = {userId: t, passwordHash: i, type: s};\n        return fetch(this._ + \"/client/createBridge\", {\n            method: \"POST\",\n            cache: \"no-cache\",\n            headers: {\"Content-Type\": \"application/json\"},\n            body: JSON.stringify(e)\n        })\n    }\n\n    invite(t) {\n        return this.p(\"/client/invite\", {callId: t})\n    }\n\n    call(t, i, s) {\n        return this.v(\"/client/call\", {callerId: t, calleeId: i, isScreenSharing: s})\n    }\n\n    accept(t, i) {\n        return this.p(\"/client/accept\", {callId: t, token: i})\n    }\n\n    reject(t, i) {\n        return this.p(\"/client/reject\", {callId: t, token: i})\n    }\n\n    offer(t, i, s) {\n        return this.p(\"/client/offer\", {callId: t, sdp: s, token: i})\n    }\n\n    answer(t, i, s) {\n        return this.p(\"/client/answer\", {callId: t, sdp: s, token: i})\n    }\n\n    ice(t, i, s) {\n        return this.p(\"/client/ice\", {callId: t, candidate: i, token: s})\n    }\n\n    end(t, i) {\n        return this.p(\"/client/end\", {callId: t, token: i})\n    }\n}\n\nconst h = new class {\n    constructor() {\n        this.g = [], this.I = 0, this.m = -1\n    }\n\n    C() {\n        this.g.forEach((t => t.func()))\n    }\n\n    S() {\n        this.m = setInterval((() => this.C()), 1e3)\n    }\n\n    k() {\n        clearInterval(this.m), this.m = -1\n    }\n\n    addTask(t) {\n        const i = this.I++, s = {id: i, func: t};\n        return this.g.push(s), 1 == this.g.length && this.S(), i\n    }\n\n    removeTask(t) {\n        const i = this.g.findIndex((i => i.id == t));\n        -1 != i && (this.g.splice(i, 1), 0 == this.g.length && this.k())\n    }\n}, n = new class {\n    newAudioContext() {\n        return new (window.AudioContext || window.webkitAudioContext)\n    }\n};\n\nclass r {\n    constructor() {\n        this.P = -1, this.V = n.newAudioContext(), this.T = this.V.createAnalyser(), this.T.fftSize = 2048, this.L = new Uint8Array(this.T.frequencyBinCount), this.A = null, this.db = 0, this.ondbthresholdexceeded = t => {\n        }, this.dbthreshold = 65\n    }\n\n    connect(t) {\n        -1 == this.P && (this.P = h.addTask((() => this.j()))), this.A && this.A.disconnect(), this.A = this.V.createMediaStreamSource(t), this.A.connect(this.T)\n    }\n\n    disconnect() {\n        -1 != this.P && (h.removeTask(this.P), this.A.disconnect(), this.A = null, this.P = -1)\n    }\n\n    j() {\n        const t = this.L.length;\n        let s = 0;\n        this.T.getByteTimeDomainData(this.L);\n        for (let i = 0; i < t; i++) {\n            const t = .0078125 * (this.L[i] - 128);\n            s += t * t\n        }\n        this.db = 10 * Math.log10(s / t), console.log(\"db=\" + this.db), this.db >= this.dbthreshold && i.invokeAndIgnoreExceptions((() => this.ondbthresholdexceeded(this)))\n    }\n}\n\nconst a = \"Copyright (c) 2023 Comlink Inc.\";\n\nfunction o() {\n    return \"1.1.2\"\n}\n\nclass c {\n    constructor(t) {\n        this.B = t.isInbound, this.O = t.isScreenSharing, this.R = t.remotePartyId, this.U = t.bridge, this.M = t.callId, this.N = t.config, this.D = t.token, this.J = null, this.H = null, this.K = null, this.t = null, this.F = null, this.G = null, this.W = [], t.isInbound ? this.q = 1 : this.q = 0, this.oncallstarted = t => this.X(\"Unhandled event: call started: \" + t.M), this.oncallrejected = t => this.X(\"Unhandled event: call rejected: \" + t.M), this.oncallended = t => this.X(\"Unhandled event: call ended: \" + t.M), this.onstreamupdated = (t, i) => this.X(\"Unhandled event: stream updated: \" + t.M), this.onparticipantlistupdated = (t, i) => this.X(\"Unhandled event: participant list updated: \" + t.M), this.onviewportlayoutupdated = (t, i) => this.X(\"Unahndled event: viewport layout updated: \" + i), this.onfacialrecognizerresults = (t, i) => this.X(\"Unhandled event: facial recognizer results: \" + i)\n    }\n\n    Y(t) {\n        console.log(\"VC/\" + this.M + \": \" + t)\n    }\n\n    Z(t) {\n        console.error(\"VC/\" + this.M + \": \" + t)\n    }\n\n    X(t) {\n        console.warn(\"VC/\" + this.M + \": \" + t)\n    }\n\n    $() {\n        return this.J = new RTCPeerConnection(this.N), this.J.onicecandidate = t => this.tt(t), this.J.ontrack = t => this.it(t), this.J.onremovetrack = t => this.st(t), this.O ? this.B ? Promise.resolve(this) : this.et() : this.ht()\n    }\n\n    ht() {\n        return this.U.getLocalMediaStream().then((t => {\n            t.getTracks().forEach((i => this.J.addTrack(i, t))), t.oninactive = () => this.nt()\n        }))\n    }\n\n    et() {\n        return navigator.mediaDevices.getDisplayMedia({video: {cursor: \"always\"}, audio: !0}).then((t => {\n            t.getTracks().forEach((i => this.J.addTrack(i, t))), t.oninactive = () => this.nt()\n        }))\n    }\n\n    rt() {\n        6 != this.q && (this.K && (this.K.disconnect(), this.K = null), this.q = 6, this.U.ot(this), this.J.close())\n    }\n\n    ct(i) {\n        switch (t(\"CALL\" == i.type, 'Bad event type. \"CALL\" expected.'), i.name) {\n            case\"accept\":\n                this.lt();\n                break;\n            case\"end\":\n                this.dt();\n                break;\n            case\"reject\":\n                this.ut();\n                break;\n            case\"sdp\":\n                this._t(i.sdp, i.action);\n                break;\n            case\"ice\":\n                this.vt(i.iceCandidate);\n                break;\n            case\"participants\":\n                this.gt(i.userIds);\n                break;\n            case\"viewportLayout\":\n                this.bt({frameWidth: i.frameWidth, frameHeight: i.frameHeight, viewports: i.viewports});\n                break;\n            case\"facialRecognition\":\n                this.ft({callId: i.tagCallId, tag: i.tag, confidence: i.confidence});\n                break;\n            default:\n                throw new Error(\"Bad call state\")\n        }\n    }\n\n    gt(t) {\n        this.F = t, i.invokeAndIgnoreExceptions((() => this.onparticipantlistupdated(this, this.F)))\n    }\n\n    bt(t) {\n        this.G = t, i.invokeAndIgnoreExceptions((() => this.onviewportlayoutupdated(this, this.G)))\n    }\n\n    ft(t) {\n        i.invokeAndIgnoreExceptions((() => this.onfacialrecognizerresults(this, t)))\n    }\n\n    vt(t) {\n        this.J.remoteDescription ? this.J.addIceCandidate(t) : this.W.push(t)\n    }\n\n    it(t) {\n        this.t = t.streams[0], this.K && this.K.connect(this.t), i.invokeAndIgnoreExceptions((() => this.onstreamupdated(this, this.t)))\n    }\n\n    st(t) {\n    }\n\n    nt() {\n        i.invokeAndIgnoreExceptions((() => this.oncallended(this))), this.stop()\n    }\n\n    dt() {\n        i.invokeAndIgnoreExceptions((() => this.oncallended(this))), this.stop()\n    }\n\n    lt() {\n        this.J.createOffer({\n            offerToReceiveVideo: !0,\n            offerToReceiveAudio: !0\n        }).then((t => this.J.setLocalDescription(t))).then((() => this.U.wt.offer(this.M, this.D, this.J.localDescription.sdp))).catch((t => {\n            throw this.It(t), t\n        })), i.invokeAndIgnoreExceptions((() => this.oncallstarted(this)))\n    }\n\n    ut() {\n        this.U.ot(this), this.q = 4, i.invokeAndIgnoreExceptions((() => this.oncallrejected(this)))\n    }\n\n    _t(t, i) {\n        const s = new RTCSessionDescription({type: i, sdp: t});\n        \"offer\" == i ? this.J.setRemoteDescription(s).then((() => (this.yt(), this.J.createAnswer()))).then((t => this.J.setLocalDescription(t))).then((() => this.U.wt.answer(this.M, this.D, this.J.localDescription.sdp))).then((t => (this.q = 3, t))).catch((t => {\n            throw this.It(t), t\n        })) : \"answer\" == i && this.J.setRemoteDescription(s).then((() => {\n            this.yt(), this.q = 3\n        })).catch((t => {\n            throw this.It(t), t\n        }))\n    }\n\n    yt() {\n        this.W.forEach((t => {\n            this.J.addIceCandidate(t)\n        })), this.W = []\n    }\n\n    tt(t) {\n        if (t.candidate) try {\n            this.U.wt.ice(this.M, t.candidate, this.D)\n        } catch (t) {\n            this.X(\"failed to transmit ICE candidate\")\n        }\n    }\n\n    It(t) {\n        this.q = 4, this.Z(\"panic: \" + t.message)\n    }\n\n    getParticipantList() {\n        return this.F\n    }\n\n    getViewportLayout() {\n        return this.G\n    }\n\n    getCallId() {\n        return this.M\n    }\n\n    getVideoBridge() {\n        return this.U\n    }\n\n    getRemotePartyId() {\n        return this.R\n    }\n\n    isInbound() {\n        return this.B\n    }\n\n    setUserData(t) {\n        this.H = t\n    }\n\n    getUserData() {\n        return this.H\n    }\n\n    isScreenSharing() {\n        return this.O\n    }\n\n    attachActivityMonitor(s, e) {\n        t(null == this.K, \"Activity notifier already attached\"), t(null != e, \"Activity monitor callback not defined\"), this.K = new r, this.K.dbtheshold = s, this.K.ondbthresholdexceeded = t => i.invokeAndIgnoreExceptions((() => e(this))), this.t && this.K.connect(this.t)\n    }\n\n    getSoundLevel() {\n        return this.K || this.K.db\n    }\n\n    start() {\n        return t(0 == this.q, \"Call already initialized\"), this.q = 1, this.Y(\"starting\"), this.U.wt.call(this.U.getUserId(), this.R, this.O).then((t => (this.M = t.callId, this.N = t.config, this.D = t.token, this.$()))).then((() => this.U.wt.invite(this.M))).then((() => (this.q = 2, this.U.Ct(this), this))).catch((t => {\n            throw this.It(t), t\n        }))\n    }\n\n    accept() {\n        return t(1 == this.q, \"Invalid call state\"), t(this.B, \"Not an inbound call\"), this.Y(\"accepting\"), this.$().then((() => this.U.wt.accept(this.M, this.D))).then((t => (this.q = 2, this))).catch((t => {\n            throw this.It(t), t\n        }))\n    }\n\n    reject() {\n        return t(1 == this.q, \"Invalid call state\"), t(this.B, \"Not an inbound call\"), this.Y(\"rejecting\"), this.U.wt.reject(this.M, this.D).then((t => (this.q = 5, this.U.ot(this), this))).catch((t => {\n            throw this.It(t), t\n        }))\n    }\n\n    stop() {\n        return 6 != this.q && 4 != this.q ? (this.rt(), this.U.wt.end(this.M, this.D).then((() => this))) : Promise.resolve(this)\n    }\n\n    muteRemoteAudio(i) {\n        t(\"boolean\" == typeof i, \"Expected a boolean value\"), this.J.getReceivers().forEach((t => {\n            \"audio\" == t.track.kind && (t.track.enabled = i)\n        }))\n    }\n}\n\nclass l {\n    constructor(t) {\n        this.St = t.userId, this.kt = t.type, this.Et = t.passwordHash, this.wt = new e(t.serviceUrl || \"\"), this.Pt = !1, this.Vt = {}, this.Tt = !1, this.Lt = !1, this.At = null, this.jt = null, this.onbridgeactive = t => console.log(\"onbridgeactive event not handled\"), this.onbridgeinactive = t => console.log(\"onbridgeinactive event not handled\"), this.onbridgefailure = t => console.log(\"onbridgefailure event not handled\"), this.onincomingcall = t => {\n            console.log(\"Inbound call event not handled; call rejected.\"), t.reject()\n        }\n    }\n\n    It(t) {\n        console.log(\"Catastrophic bridge failure: \" + t), i.invokeAndIgnoreExceptions((() => this.onbridgefailure(this))), this.shutdown()\n    }\n\n    Bt() {\n        this.Pt ? this.It(new Error(\"Event stream closed unexpectedly\")) : (i.invokeAndIgnoreExceptions((() => this.onbridgeinactive(this))), this.shutdown())\n    }\n\n    Ot() {\n        this.At.readEvent().then((t => {\n            if (this.At.eof()) this.Bt(); else {\n                try {\n                    const i = JSON.parse(t);\n                    this.ct(i)\n                } catch (t) {\n                    return void this.It(t)\n                }\n                this.Ot()\n            }\n        }))\n    }\n\n    Rt(t) {\n        const i = this.Vt[t.callId];\n        i ? i.ct(t) : console.log(\"Invalid call identifier in the event stream: \" + t.callId)\n    }\n\n    Ut(t) {\n        const s = new c({\n            bridge: this,\n            callId: t.callId,\n            isInbound: !0,\n            isScreenSharing: t.isScreenSharing,\n            remotePartyId: t.callerId,\n            config: t.config,\n            token: t.token\n        });\n        this.Ct(s), i.invokeAndIgnoreExceptions((() => this.onincomingcall(s)))\n    }\n\n    xt(t) {\n        this.Pt || (this.Pt = !0, i.invokeAndIgnoreExceptions((() => this.onbridgeactive(this))))\n    }\n\n    ct(t) {\n        switch (console.log(t), t.type) {\n            case\"INCOMING\":\n                this.Ut(t);\n                break;\n            case\"KEEPALIVE\":\n                this.xt(t);\n                break;\n            case\"CALL\":\n                this.Rt(t);\n                break;\n            default:\n                this.It(new Error(\"Bad event type: \" + t.type + \". Corrupt stream?\"))\n        }\n    }\n\n    Mt() {\n        Object.values(this.Vt).forEach((t => t.rt())), this.Vt = {}\n    }\n\n    Ct(t) {\n        this.Vt[t.getCallId()] = t\n    }\n\n    ot(t) {\n        const i = t.getCallId();\n        this.Vt.hasOwnProperty(i) && delete this.Vt[i]\n    }\n\n    getUserId() {\n        return this.St\n    }\n\n    getCalls() {\n        return Object.values(this.Vt)\n    }\n\n    hasCamera() {\n        return this.Tt\n    }\n\n    hasMicrophone() {\n        return this.Lt\n    }\n\n    getCallById(t) {\n        return this.Vt[t]\n    }\n\n    isActive() {\n        return this.Pt\n    }\n\n    getLocalMediaStream() {\n        return t(this.Pt, \"VideoBridge not active\"), this.jt ? Promise.resolve(this.jt) : navigator.mediaDevices.enumerateDevices().then((t => {\n            var i = {};\n            return null != t.find((t => \"videoinput\" == t.kind)) && (this.Tt = !0, i.video = {\n                width: 800,\n                height: 600\n            }), null != t.find((t => \"audioinput\" == t.kind)) && (this.Lt = !0, i.audio = {channels: 1}), navigator.mediaDevices.getUserMedia(i)\n        })).then((t => (this.jt = t, t)))\n    }\n\n    closeLocalMediaStream() {\n        t(this.Pt, \"VideoBridge not active\"), this.jt && (this.jt.getTracks().forEach((t => t.stop())), this.jt = null, this.Lt = !1, this.Tt = !1)\n    }\n\n    enableCamera(i) {\n        t(this.Pt, \"Video bridge not active\"), t(\"boolean\" == typeof i, \"Expected a boolean value\"), this.Tt && this.jt.getTracks().forEach((t => {\n            \"live\" == t.readyState && \"video\" === t.kind && (t.enabled = i)\n        }))\n    }\n\n    enableMicrophone(i) {\n        t(this.Pt, \"Video bridge not active\"), t(\"boolean\" == typeof i, \"Expected a boolean value\"), this.Lt && this.jt.getTracks().forEach((t => {\n            \"live\" == t.readyState && \"audio\" === t.kind && (t.enabled = i)\n        }))\n    }\n\n    start() {\n        t(!this.Pt, \"Video bridge already active\"), console.log(\"CVB v1.1.2. \" + a), this.wt.createBridge(this.St, this.Et, this.kt).then((t => t.body)).then((t => {\n            this.At = new s(t.getReader()), this.Ot()\n        })).catch((t => {\n            console.error(\"Video bridge creation failure: \" + t), i.invokeAndIgnoreExceptions((() => this.onbridgefailure(this))), this.It(t)\n        }))\n    }\n\n    shutdown() {\n        t(this.Pt, \"Video bridge not active\"), console.log(\"CVB v1.1.2. \" + a), Object.values(this.Vt).slice().forEach((t => t.stop())), this.Vt = {}, this.At.cancel(), this.closeLocalMediaStream(), this.Pt = !1\n    }\n\n    createVideoCall(i) {\n        return t(this.Pt, \"Video bridge not active\"), new c({\n            bridge: this,\n            isInbound: !1,\n            isScreenSharing: !1,\n            remotePartyId: i\n        })\n    }\n\n    createScreenSharingCall(i) {\n        return t(this.Pt, \"Video bridge not activbe\"), new c({\n            bridge: this,\n            isInboud: !1,\n            isScreenSharing: !0,\n            remotePartyId: i\n        })\n    }\n}\n\n\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/cvb.min.js?");

/***/ }),

/***/ "./src/minimized-conference-room.js":
/*!******************************************!*\
  !*** ./src/minimized-conference-room.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MinimizedConferenceRoom\": function() { return /* binding */ MinimizedConferenceRoom; }\n/* harmony export */ });\n/* harmony import */ var _video_bar_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./video-bar.js */ \"./src/video-bar.js\");\n\n\nclass MinimizedConferenceRoom {\n    __isMinimized = false;\n    container = null;\n\n    /**\n     *\n     * @type {HTMLElement}\n     */\n    participantList = null;\n\n    /**\n     *\n     * @type {VideoBar}\n     */\n    videoBar = null;\n\n    minimizedConferenceNode = null;\n\n    constructor(container) {\n        this.container = container;\n    }\n\n    isMinimized() {\n        return this.__isMinimized;\n    }\n\n    resetConferenceVideoBar(minimizedSettings) {\n        if (this.videoBar) {\n            this.videoBar.destruct();\n            this.videoBar = null;\n        }\n        let conferenceVideoBar = this.minimizedConferenceNode.querySelector(\".telehealth-button-bar\");\n        this.videoBar = new _video_bar_js__WEBPACK_IMPORTED_MODULE_0__.VideoBar(conferenceVideoBar, minimizedSettings);\n        return this.videoBar;\n    };\n\n    minimizeConferenceRoom(minimizedVideoButtonSettings) {\n\n        let className = \"minimized-telehealth-video-template\";\n        let templateNode = this.container.querySelector(\".\" + className);\n        if (!templateNode) {\n            throw new Error(\"Failed to find template node with class .\" + className);\n        }\n        let template = templateNode.cloneNode(true);\n\n        // grab every dom node in the waiting room that is not the patient video\n        // grab the video and shrink it to bottom left window\n        // shrink container to be the size of the video\n        template.id = \"minimized-telehealth-video\";\n        template.classList.remove('d-none');\n        template.classList.remove(className);\n\n        window.document.body.appendChild(template);\n        this.minimizedConferenceNode = template;\n\n        // let's grab the participant list and append it\n        this.participantList = this.container.querySelector('.participant-list-container');\n        template.prepend(this.participantList);\n        if (this.participantList.dataset['classMinimize']) {\n            this.participantList.className = this.participantList.dataset['classMinimize'];\n        }\n\n        // now make the video container draggable\n        if (window.initDragResize)\n        {\n            // let's initialize our drag action here.\n            window.initDragResize();\n        }\n\n        this.__isMinimized = true;\n    }\n\n    maximizeConferenceRoom() {\n        // remove the event listener\n        var remoteVideoContainer = this.container.querySelector('.remote-video-container');\n\n        // now let's move the video and cleanup the old container here\n        // if (remoteVideo && remoteVideoContainer) {\n        if (this.participantList && remoteVideoContainer) {\n\n            // var oldContainer = remoteVideo.parentNode;\n            var oldContainer = this.minimizedConferenceNode;\n            this.videoBar.destruct();\n            // remoteVideoContainer.prepend(remoteVideo);\n            remoteVideoContainer.parentNode.prepend(this.participantList);\n            if (this.participantList.dataset['classMaximize']) {\n                this.participantList.className = this.participantList.dataset['classMaximize'];\n            }\n\n            // need to clean up the original minimize container we created here\n            if (oldContainer && oldContainer.parentNode)\n            {\n                oldContainer.parentNode.removeChild(oldContainer);\n            }\n            this.minimizedConferenceNode = null;\n        } else {\n            console.error(\"Failed to find remote video or remote video container\");\n        }\n        this.__isMinimized = false;\n    }\n\n    destruct() {\n        // clean up our node pointers\n        this.participantList = null;\n        this.container = null;\n\n        // clean up minimized elements now too if we have them.\n        let minimizedContainer = document.getElementById('minimized-telehealth-video');\n        if (minimizedContainer && minimizedContainer.parentNode)\n        {\n            minimizedContainer.parentNode.removeChild(minimizedContainer);\n        }\n        this.__isMinimized = false;\n    }\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/minimized-conference-room.js?");

/***/ }),

/***/ "./src/patient-conference-room.js":
/*!****************************************!*\
  !*** ./src/patient-conference-room.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PatientConferenceRoom\": function() { return /* binding */ PatientConferenceRoom; }\n/* harmony export */ });\n/* harmony import */ var _conference_room_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./conference-room.js */ \"./src/conference-room.js\");\n\n\nfunction PatientConferenceRoom(apiCSRFToken, enabledFeatures, translations,scriptLocation) {\n    let patientConferenceRoom = new _conference_room_js__WEBPACK_IMPORTED_MODULE_0__.ConferenceRoom(apiCSRFToken, enabledFeatures, translations, scriptLocation);\n    let parentDestruct = patientConferenceRoom.destruct;\n    let checkProviderReadyForPatientInterval = null;\n    let providerIsReady = false;\n\n    function checkProviderReadyForPatient()\n    {\n        let pc_eid = patientConferenceRoom.telehealthSessionData.pc_eid;\n        window.top.restoreSession();\n        window.fetch(scriptLocation + '?action=patient_appointment_ready&eid=' + encodeURIComponent(pc_eid), {redirect: \"manual\"})\n            .then(result => {\n                if (result.ok) {\n                    return result.json();\n                } else {\n                    throw new Error(\"Failed to get response back from server\")\n                }\n            })\n            .then(apptReadyData => {\n                if (apptReadyData.session)\n                {\n                    // provider being ready is just one test, local camera permissions also must be checked\n                    providerIsReady = apptReadyData.session.providerReady === \"1\";\n\n                    // we update the calleeUuid here in case another provider takes over the appointment session of\n                    // the patient.  This occurs if a provider is out of town and the patient is currently waiting\n                    // for the session to start.\n\n                    if (apptReadyData.session.participantList) {\n                        patientConferenceRoom.callerSettings.participantList = apptReadyData.session.participantList;\n                        let provider = patientConferenceRoom.callerSettings.participantList.find(p => p.role == 'provider');\n                        if (!provider) {\n                            throw new Error(\"No provider in participant list.  Provider is not ready and cannot continue\");\n                        }\n                        patientConferenceRoom.callerSettings.calleeUuid = provider.uuid;\n                        patientConferenceRoom.setCurrentCallerFocusId(provider.uuid);\n                    }\n\n                    patientConferenceRoom.toggleJoinButton(patientConferenceRoom.shouldEnableJoinButton());\n                }\n            })\n            .catch(error => {\n                let errorMessage = document.querySelector('.waiting-room-server-communication');\n                if (errorMessage) {\n                    errorMessage.classList.remove(('d-none'));\n                }\n                console.error(error);\n            });\n    }\n\n\n    patientConferenceRoom.getFullConferenceVideoBarSettings = function()\n    {\n        let settings = patientConferenceRoom.getDefaultVideoBarSettings();\n        settings.hangupCallback = patientConferenceRoom.handleCallHangup.bind(patientConferenceRoom);\n        settings.expand = false;\n        settings.notes = false; // patient doesn't get notes.\n        settings.invite = false; // patient doesn't get invite participant at least for now.\n        settings.hangup = true;\n        patientConferenceRoom.addSettingsForScreenshare(settings);\n        return settings;\n    };\n\n    patientConferenceRoom.startConferenceRoom = function()\n    {\n        patientConferenceRoom.stopProviderReadyCheck();\n        patientConferenceRoom.startProviderConferenceRoom(); // not sure there is much difference here\n\n        // we need to make a call to all the other participants...\n        let participantList = patientConferenceRoom.getRemoteParticipantList();\n        if (participantList) {\n            // if the participant is in the room, let's make a call to that user.\n            participantList.forEach(pl => {\n                if (pl.inRoom == 'Y') {\n                    if (pl.role == 'provider') {\n                        // TODO: here is where we say we want this person to be the focus screen.\n                    }\n                    patientConferenceRoom.makeCall(pl.uuid);\n                }\n            });\n        }\n        // patientConferenceRoom.makeCall(patientConferenceRoom.callerSettings.calleeUuid);\n\n        // patientConferenceRoom.makeScreenshareCall(patientConferenceRoom.callerSettings.calleeUuid);\n    };\n\n    patientConferenceRoom.canReceiveCall = function(call) {\n        let callerId = call.getRemotePartyId();\n        console.log(\"Received call \", call);\n        // only allow calls from one of the participants allowed in the room...\n        let canCall = patientConferenceRoom.isAuthorizedParticipant(callerId);\n        return Promise.resolve({call: call, canCall: canCall});\n    };\n\n    patientConferenceRoom.handleCallEndedEvent = function(call)\n    {\n        let detachedCallRemoteUserId = null;\n        // if the user data is allocated then this is an existing call\n        if (call.getUserData() != null) {\n\n            /**\n             *\n             * @type {CallerSlot|null}\n             */\n            let callerSlot = call.getUserData();\n            detachedCallRemoteUserId = callerSlot.getRemotePartyId();\n            patientConferenceRoom.removeCallFromConference(call);\n        }\n\n        // we only fall back to the waiting room if we aren't in the middle of a session destruction.\n        if (patientConferenceRoom.inSession && !patientConferenceRoom.hasProviderParticipant()) {\n\n            // we shouldn't ever have the case where there are no participants but the provider is still here...\n            // for safety reasons though we want to put this in\n            alert(translations.HOST_LEFT);\n            // for patient conference if the provider leaves the call we need to send them back to the waiting room\n            patientConferenceRoom.replaceConferenceRoomWithWaitingRoom();\n            // cancel our session update sequence that happens during the conference room.\n            patientConferenceRoom.cancelUpdateConferenceRoomSession();\n        }\n    };\n\n    patientConferenceRoom.hasProviderParticipant = function() {\n        // TODO: @adunsulag when we switch to 3rd party we can return the provider caller uuid\n        return patientConferenceRoom.findCallerSlotWithId(patientConferenceRoom.callerSettings.calleeUuid) !== undefined;\n    };\n\n    patientConferenceRoom.replaceConferenceRoomWithWaitingRoom = function()\n    {\n        let telehealthSessionData = patientConferenceRoom.telehealthSessionData;\n        let modalDialog = patientConferenceRoom.waitingRoomModal;\n        var container = document.getElementById('telehealth-container');\n        var body = container.querySelector('.modal-body');\n        var video = document.getElementById('local-video');\n\n        patientConferenceRoom.videoBar.destruct();\n        body.innerHTML = patientConferenceRoom.waitingRoomTemplate;\n        var replaceVideo = document.getElementById('local-video');\n        if (replaceVideo) {\n            replaceVideo.parentNode.replaceChild(video, replaceVideo);\n        } else {\n            console.error(\"Failed to find child video to replace\");\n            return;\n        }\n        providerIsReady = false;\n        patientConferenceRoom.initWaitingRoomEvents(container);\n        patientConferenceRoom.startProviderReadyCheck();\n    };\n\n    patientConferenceRoom.handleCallHangup = function()\n    {\n        if (patientConferenceRoom.room == patientConferenceRoom.ROOM_TYPE_WAITING)\n        {\n            patientConferenceRoom.sessionClose();\n        } else {\n            // since we are already tied to the hidden event we can just hide the modal and it will destroy everything\n            // for the patient side of things.\n            if (confirm(translations.CONFIRM_SESSION_CLOSE)) {\n                patientConferenceRoom.sessionClose();\n            }\n        }\n    };\n\n    patientConferenceRoom.setWaitingRoomModal = function(waitingRoomModal)\n    {\n        patientConferenceRoom.waitingRoomModal = waitingRoomModal;\n    };\n\n    patientConferenceRoom.setupWaitingRoom = function()\n    {\n        // do the provider work and let's enable our join button only if the provider is ready\n        patientConferenceRoom.setupProviderWaitingRoom();\n        patientConferenceRoom.startProviderReadyCheck();\n    };\n    patientConferenceRoom.destruct = function()\n    {\n        patientConferenceRoom.stopProviderReadyCheck();\n        // TODO: look at merging the two dialogs from patient versus provider\n        if (window.dlgclose) {\n            window.dlgclose();\n        }\n        parentDestruct.bind(patientConferenceRoom)();\n    };\n    patientConferenceRoom.stopProviderReadyCheck = function()\n    {\n        if (checkProviderReadyForPatientInterval) {\n            clearInterval(checkProviderReadyForPatientInterval);\n            checkProviderReadyForPatientInterval = null;\n        }\n    };\n    patientConferenceRoom.startProviderReadyCheck = function()\n    {\n        checkProviderReadyForPatientInterval = setInterval(checkProviderReadyForPatient, 2000);\n    };\n    patientConferenceRoom.shouldEnableJoinButton = function()\n    {\n        return providerIsReady && patientConferenceRoom.hasLocalPermissionsEnabled();\n    };\n    return patientConferenceRoom;\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/patient-conference-room.js?");

/***/ }),

/***/ "./src/presentation-screen.js":
/*!************************************!*\
  !*** ./src/presentation-screen.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PresentationScreen\": function() { return /* binding */ PresentationScreen; }\n/* harmony export */ });\nclass PresentationScreen\n{\n    /**\n     *\n     * @type HTMLVideoElement\n     */\n    videoElement = null;\n\n    /**\n     *\n     * @type CallerSlot\n     */\n    callerSlot = null;\n\n    constructor(domNodeId)\n    {\n        /**\n         *\n         * @type HTMLVideoElement\n         */\n        this.videoElement = document.getElementById(domNodeId);\n        if (!this.videoElement) {\n            throw new Error(\"Failed to find presentation screen dom node with id \" + domNodeId);\n        }\n    }\n\n    updateCallerSlotScreen() {\n        if (this.callerSlot && this.callerSlot.getCurrentCallStream() != null) {\n            this.videoElement.srcObject = this.callerSlot.getCurrentCallStream();\n            this.videoElement.play(); // TODO: do we need this?\n        }\n    }\n\n    attach(callerSlot) {\n        // if we have something let's remove it.\n        if (this.callerSlot) {\n            this.detach();\n        }\n        if (callerSlot && callerSlot.getCurrentCallStream() != null) {\n            let displayTitle = callerSlot.getParticipant() ? callerSlot.getParticipant().callerName : \"\";\n            this.videoElement.srcObject = callerSlot.getCurrentCallStream();\n            this.videoElement.play();\n            this.videoElement.title = displayTitle;\n            this.callerSlot = callerSlot;\n        }\n    }\n\n    getVideoElement() {\n        return this.videoElement;\n    }\n\n    detach() {\n        this.callerSlot = null;\n        this.videoElement.srcObject = null;\n    }\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/presentation-screen.js?");

/***/ }),

/***/ "./src/registration-checker.js":
/*!*************************************!*\
  !*** ./src/registration-checker.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RegistrationChecker\": function() { return /* binding */ RegistrationChecker; }\n/* harmony export */ });\n\nfunction RegistrationChecker(scriptLocation)\n{\n    var checker = this;\n    var timeoutId;\n    var settings;\n    var currentCheckCount = 0;\n    var maxCheck = 10;\n\n    this.checkRegistration = function()\n    {\n        if (currentCheckCount++ > maxCheck)\n        {\n            console.error(\"Failed to get a valid telehealth registration for user\");\n            return;\n        }\n\n        let location = scriptLocation + '?action=check_registration';\n\n        window.top.restoreSession();\n        window.fetch(location)\n            .then(result => {\n                if (!result.ok)\n                {\n                    throw new Error(\"Registration check failed\");\n                }\n                return result.json();\n            })\n            .then(registrationSettings => {\n                if (registrationSettings && registrationSettings.hasOwnProperty('errorCode')) {\n                    if (registrationSettings.errorCode == 402) {\n                        // user is not enrolled and so we will skip trying to register the user\n                        checker.settings = {};\n                    }\n                }\n                checker.settings = registrationSettings;\n            })\n            .catch(error => {\n                console.error(\"Failed to execute check_registration action\", error);\n                timeoutId = setTimeout(checker.checkRegistration.bind(checker), 2000);\n            });\n    };\n    return this;\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/registration-checker.js?");

/***/ }),

/***/ "./src/telehealth-bridge.js":
/*!**********************************!*\
  !*** ./src/telehealth-bridge.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TelehealthBridge\": function() { return /* binding */ TelehealthBridge; }\n/* harmony export */ });\n/* harmony import */ var _cvb_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cvb.min */ \"./src/cvb.min.js\");\n\n\nclass TelehealthBridge\n{\n    isShutdown = false;\n    userId = null;\n    passwordHash = null;\n    serviceUrl = null;\n    /**\n     *\n     * @type cvb.VideoBridge\n     */\n    bridge = null;\n\n    constructor(userId, passwordHash, serviceUrl) {\n        this.userId = userId;\n        this.passwordHash = passwordHash;\n        this.serviceUrl = serviceUrl;\n        this.isRunning = false;\n    }\n\n    noop() {\n    }\n\n    startBridge(handlers) {\n        handlers = handlers || {};\n        handlers.onincomingcall = handlers.onincomingcall || this.noop;\n        handlers.onbridgeactive = handlers.onbridgeactive || this.noop;\n        handlers.onbridgeinactive = handlers.onbridgeinactive || this.noop;\n        handlers.onbridgefailure = handlers.onbridgefailure || this.noop;\n\n        this.bridge = new _cvb_min__WEBPACK_IMPORTED_MODULE_0__.VideoBridge({\n            userId: this.userId,\n            passwordHash: this.passwordHash,\n            type: 'normal',\n            serviceUrl: this.serviceUrl\n        });\n        console.log(\"Instantiated bridge \"  + this.userId);\n\n\n        // Callback: incoming call\n        //\n        // When a new call comes in we'll ask the user if they want to accept or\n        // reject it.\n        this.bridge.onincomingcall = (call) => {\n            console.log(\"Receiving call from \" + call.getRemotePartyId() + \" for \"  + this.userId);\n            handlers.onincomingcall(call);\n        };\n\n        // Callback: bridge active\n        //\n        // When the bridge becomes active we'll ask it for the local media stream\n        // which we will then play in the local video element.\n        this.bridge.onbridgeactive = (bridge) => {\n            console.log(\"The bridge is active \" + this.userId);\n            handlers.onbridgeactive(bridge);\n        };\n\n        // Callback: bridge inactive\n        //\n        // When the bridge becomes inactive we'll stop the local stream video\n        // element.\n        this.bridge.onbridgeinactive = (bridge) => {\n            console.log(\"The bridge is inactive \" + this.userId);\n            handlers.onbridgeinactive(bridge);\n        };\n\n        // Callback: bridge failure\n        //\n        // Similarly, if the bridge suffers a catastrophic failure we'll stop the\n        // local stream video element.\n        this.bridge.onbridgefailure = (bridge) => {\n            console.error(\"The bridge failed \" + this.userId);\n            if (!this.isShutdown) {\n                try {\n                    // we only call this once\n                    handlers.onbridgefailure(bridge);\n                }\n                catch (e) {\n                    console.error(\"Failure occurred in bridge shutdown handler\", e);\n                }\n            }\n            this.isShutdown = true;\n            this.shutdown();\n        };\n\n        // Finally spin up the bridge.\n        this.bridge.start();\n        console.log(\"Started bridge \"  + this.userId);\n        this.isShutdown = false;\n    }\n\n    hasLocalPermissionsEnabled() {\n        if (!this.bridge) {\n            return false;\n        }\n\n        return this.bridge.hasLocalPermissionsEnabled();\n    }\n\n    shutdown() {\n        // if we are already shut down, don't need to do anything here.\n        if (!this.isShutdown) {\n            this.bridge.shutdown();\n            this.isShutdown = true;\n        }\n    }\n\n    restartMediaStream() {\n        if (this.isShutdown) {\n            console.error(\"Bridge is shutdown.  Cannot restart media stream\");\n        }\n    }\n\n    getLocalMediaStream() {\n        return this.bridge.getLocalMediaStream();\n    }\n\n    enableMicrophone(toggle) {\n        return this.bridge.enableMicrophone(toggle);\n    }\n\n    enableCamera(toggle) {\n        return this.bridge.enableCamera(toggle);\n    }\n\n    createScreenSharingCall(calleeUuid) {\n        return this.bridge.createScreenSharingCall(calleeUuid);\n    }\n\n    createVideoCall(calleeUuid) {\n        return this.bridge.createVideoCall(calleeUuid);\n    }\n\n    setCallHandlers(call) {\n        return this.bridge.setCallHandlers(call);\n    }\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/telehealth-bridge.js?");

/***/ }),

/***/ "./src/telehealth.js":
/*!***************************!*\
  !*** ./src/telehealth.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _registration_checker_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./registration-checker.js */ \"./src/registration-checker.js\");\n/* harmony import */ var _conference_room_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./conference-room.js */ \"./src/conference-room.js\");\n/* harmony import */ var _patient_conference_room_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./patient-conference-room.js */ \"./src/patient-conference-room.js\");\n\n\n\n\n\n/**\n * Core TeleHealth javascript library for communicating with OpenEMR to start and stop TeleHealth sessions.\n *\n * @package openemr\n * @link      http://www.open-emr.org\n * @author    Stephen Nielson <snielson@discoverandchange.com>\n * @copyright Copyright (c) 2022 Comlink Inc <https://comlinkinc.com/>\n * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3\n */\n\n(function(window, comlink, bootstrap, jQuery) {\n\n    /**\n     *\n     * @type {ConferenceRoom}\n     */\n    let conferenceRoom = false;\n\n    // make sure we don't error out here\n    comlink.settings = comlink.settings || {};\n\n    /**\n     * @type {string} The path of where the module is installed at.  In a multisite we pull this from the server configuration, otherwise we default here\n     */\n    let moduleLocation = comlink.settings.modulePath || '/interface/modules/custom_modules/oe-module-comlink-telehealth/';\n\n    /**\n     * @var VideoBar\n     */\n    let videoBar = null;\n\n    /**\n     * Handler from setInterval used as polling handle that checks to see if the provider has entered into the\n     * conference room and is ready to chat with the patient.\n     * @type number\n     */\n    let checkProviderReadyForPatientInterval = null;\n\n    /**\n     *\n     * @type {RegistrationChecker}\n     */\n    let checker = null;\n\n    let telehealthRegistrationInterval = null;\n\n    let registrationSettings;\n\n    let defaultTranslations = {\n        'CALL_CONNECT_FAILED': \"Failed to connect the call.\",\n        'SESSION_LAUNCH_FAILED': \"There was an error in launching your telehealth session.  Please try again or contact support\",\n        'APPOINTMENT_STATUS_UPDATE_FAILED': 'There was an error in saving the telehealth appointment status.  Please contact support or update the appointment manually in the calendar',\n        'DUPLICATE_SESSION': \"You are already in a conference session.  Please hangup the current call to start a new telehealth session\",\n        'HOST_LEFT': \"Host left the call\",\n        \"CONFIRM_SESSION_CLOSE\": \"Are you sure you want to close this session?\",\n        \"TELEHEALTH_MODAL_TITLE\": \"TeleHealth Session\",\n        \"TELEHEALTH_MODAL_CONFIRM_TITLE\": \"Confirm Session Close\",\n        \"UPDATE_APPOINTMENT_STATUS\" : \"Update appointment status\",\n        \"STATUS_NO_SHOW\" : \"No Show\",\n        \"STATUS_CANCELED\" : \"Canceled\",\n        \"STATUS_CHECKED_OUT\" : \"Checked Out\",\n        \"STATUS_SKIP_UPDATE\": \"Skip Update\",\n        \"CONFIRM\" : \"Confirm\",\n        \"STATUS_NO_UPDATE\": \"No Change\",\n        \"STATUS_OTHER\": \"Other\"\n    };\n    let translations = comlink.translations || defaultTranslations;\n\n    /**\n     * Returns the API endpoint to call for a patient or a provider for telehealth communication\n     * @param forPatient\n     */\n    function getTeleHealthScriptLocation(forPatient)\n    {\n        if (forPatient === true)\n        {\n            return moduleLocation + 'public/index-portal.php';\n        } else {\n            return moduleLocation + 'public/index.php';\n        }\n    }\n\n    // TODO: @adunsulag eventually we can merge this into our conference room app.\n    function ATApp(conferenceRoom, params)\n    {\n\n        return this;\n    }\n\n    function launchProviderVideoMessage(data)\n    {\n        if (conferenceRoom)\n        {\n            if (conferenceRoom.inSession) {\n                alert(translations.DUPLICATE_SESSION);\n                return;\n            }\n            else\n            {\n                // destroy the session.\n                conferenceRoom.destruct();\n                conferenceRoom = null;\n            }\n        }\n        conferenceRoom = new _conference_room_js__WEBPACK_IMPORTED_MODULE_1__.ConferenceRoom(comlink.settings.apiCSRFToken, comlink.settings.features\n            , translations, getTeleHealthScriptLocation(false));\n        conferenceRoom.init(data);\n    }\n\n\n    function showPatientPortalDialog(appointmentEventId) {\n            let telehealthSessionData = {\n                pc_eid: appointmentEventId\n            };\n        // we don't let patients use the local OpenEMR api so this value is empty\n        // if we at some point allow the api to be used by patients we would need to populate this.\n        let csrfToken = comlink.settings.apiCSRFToken;\n        conferenceRoom = new _patient_conference_room_js__WEBPACK_IMPORTED_MODULE_2__.PatientConferenceRoom(csrfToken, comlink.settings.features,\n            translations, getTeleHealthScriptLocation(true));\n        conferenceRoom.init(telehealthSessionData);\n    }\n\n    function launchRegistrationChecker(isPatient)\n    {\n        checker = new _registration_checker_js__WEBPACK_IMPORTED_MODULE_0__.RegistrationChecker(getTeleHealthScriptLocation(isPatient));\n        checker.checkRegistration();\n    }\n\n    // now to export our object here\n    comlink.telehealth = {\n        showPatientPortalDialog: showPatientPortalDialog,\n        launchProviderVideoMessage: launchProviderVideoMessage,\n        launchRegistrationChecker: launchRegistrationChecker,\n    };\n    // now reassign our comlink object or create it new if there are no other comlink extensions.\n    window.comlink = comlink;\n})(window, window.comlink || {}, bootstrap, $, window.dlgopen || function() {});\n\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/telehealth.js?");

/***/ }),

/***/ "./src/video-bar-button.js":
/*!*********************************!*\
  !*** ./src/video-bar-button.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VideoBarButton\": function() { return /* binding */ VideoBarButton; }\n/* harmony export */ });\nfunction VideoBarButton(node, defaultValue, callback)\n{\n    let btn = this;\n    btn.node = node;\n    btn.value = defaultValue;\n    btn.callback = callback;\n    btn.enabled = defaultValue === true;\n\n    btn.init = function()\n    {\n        if (btn.enabled)\n        {\n            btn.attach();\n        }\n        else\n        {\n            btn.detatch();\n        }\n    };\n\n    btn.attach = function() {\n        if (this.node)\n        {\n            this.node.addEventListener('click', this.callback);\n            this.node.classList.remove('d-none');\n        }\n    };\n\n    btn.detatch = function()\n    {\n        if (this.node)\n        {\n            this.node.removeEventListener('click', this.callback);\n            this.node.classList.add('d-none');\n        }\n    };\n    btn.destruct = function()\n    {\n        // remove event handlers and cleanup memory.\n        btn.detatch();\n        btn.node = null;\n        btn.callback = null;\n    }\n    btn.toggle = function()\n    {\n        btn.enabled = !btn.enabled;\n        if (btn.enabled)\n        {\n            this.attach();\n        }\n        else\n        {\n            this.detatch();\n        }\n    };\n    btn.init();\n    return btn;\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/video-bar-button.js?");

/***/ }),

/***/ "./src/video-bar.js":
/*!**************************!*\
  !*** ./src/video-bar.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VideoBar\": function() { return /* binding */ VideoBar; }\n/* harmony export */ });\n/* harmony import */ var _video_bar_button_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./video-bar-button.js */ \"./src/video-bar-button.js\");\n\n\nfunction VideoBar(container, options)\n{\n    var bar = this;\n    /**\n     * @var VideoBarButton[]\n     */\n    bar.__buttons = {};\n\n    /**\n     * @var HTMLElement\n     */\n    bar.__container = container;\n\n    function noop() {}\n\n    function init() {\n        options = options || {};\n        setDefaultValue(options,'notes', false);\n        setDefaultValue(options,'notesCallback', noop);\n\n        setDefaultValue(options,'microphone', true);\n        setDefaultValue(options,'microphoneCallback', noop);\n        setDefaultValue(options,'video', true);\n        setDefaultValue(options,'videoCallback', noop);\n        setDefaultValue(options,'expand', false);\n        setDefaultValue(options,'expandCallback', noop);\n        setDefaultValue(options,'hangup', false);\n        setDefaultValue(options,'hangupCallback', noop);\n        setDefaultValue(options,'screenshare', true);\n        setDefaultValue(options,'screenshareCallback', noop);\n        setDefaultValue(options,'invite', false);\n        setDefaultValue(options,'inviteCallback', noop);\n\n\n        let btns = ['notes', 'microphone', 'video', 'expand', 'hangup', 'screenshare', 'invite'];\n        btns.forEach(btn => {\n            let node = bar.__container.querySelector(\".telehealth-btn-\" + btn);\n            let callback = options[btn + 'Callback'] || noop;\n\n            if (!node)\n            {\n                console.error(\"Failed to find node for telehealth-btn-\" + btn);\n                return;\n            }\n            bar.__buttons[btn] = new _video_bar_button_js__WEBPACK_IMPORTED_MODULE_0__.VideoBarButton(node, options[btn], callback);\n        });\n\n        // we always make sure our microphone and video is displayed, but we swap the icons if they are disabled.\n        if (!bar.__buttons['microphone'].enabled)\n        {\n            let btn = bar.__buttons['microphone'];\n            let node = btn.node.querySelector('.fa');\n            if (btn && node) {\n                btn.toggle();\n                node.classList.add('fa-microphone-slash');\n                node.classList.remove('fa-microphone');\n            } else {\n                console.error(\"Failed to find microphone node and fa icon\");\n            }\n        }\n        if (!bar.__buttons['video'].enabled)\n        {\n            let btn = bar.__buttons['video'];\n            let node = btn.node.querySelector('.fa');\n            if (btn && node) {\n                btn.toggle();\n                node.classList.add('fa-video-slash');\n                node.classList.remove('fa-video');\n            } else {\n                console.error(\"Failed to find video node and fa icon\");\n            }\n        }\n    }\n\n    function destruct()\n    {\n        Object.values(bar.__buttons).forEach(button => button.detatch());\n        bar.__container = null;\n    }\n\n    function setDefaultValue(obj, property, value)\n    {\n        if (!obj.hasOwnProperty(property))\n        {\n            obj[property] = value;\n        }\n    }\n\n    function toggleButtons(toggleBtns)\n    {\n        toggleBtns.forEach(btn => {\n            if (bar.__buttons[btn])\n            {\n                bar.__buttons[btn].toggle();\n            }\n            else\n            {\n                console.error('Failed to find button to toggle for button ' + btn);\n            }\n\n        });\n    }\n\n\n    bar.init = init;\n    bar.destruct = destruct;\n    bar.toggleButtons = toggleButtons;\n\n    bar.init();\n    return bar;\n}\n\n//# sourceURL=webpack://comlink-telehealth-js/./src/video-bar.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/telehealth.js");
/******/ 	
/******/ })()
;