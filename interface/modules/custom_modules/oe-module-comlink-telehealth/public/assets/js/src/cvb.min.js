function t(t, i) {
    if (!t) throw new Error(i)
}

class i {
    static invokeAndIgnoreExceptions(t) {
        try {
            t()
        } catch (t) {
            console.log("Ignoring exception in user callback: " + t)
        }
    }
}

class s {
    constructor(t) {
        this.t = t, this.i = "", this.h = new TextDecoder("utf-8"), this.o = !1
    }

    cancel() {
        this.t.cancel()
    }

    eof() {
        return this.o
    }

    l() {
        const t = this.i.indexOf("\r\n");
        if (-1 == t) return null;
        const i = this.i.substr(0, t);
        return this.i = this.i.substr(t + 2), i
    }

    u() {
        return this.t.read().then((t => {
            if (t.done) return this.o = !0, Promise.resolve(this.i);
            this.i += this.h.decode(t.value);
            const i = this.l();
            return i ? Promise.resolve(i) : this.u()
        }))
    }

    readEvent() {
        if (this.o) return Promise.reject();
        const t = this.l();
        return t ? Promise.resolve(t) : this.u()
    }
}

class e {
    constructor(t) {
        this._ = t
    }

    v(t, i) {
        return fetch(this._ + t, {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(i)
        }).then((t => t.ok ? t.json() : Promise.reject(t.status)))
    }

    p(t, i) {
        return fetch(this._ + t, {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(i)
        })
    }

    createBridge(t, i, s) {
        const e = {userId: t, passwordHash: i, type: s};
        return fetch(this._ + "/client/createBridge", {
            method: "POST",
            cache: "no-cache",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(e)
        })
    }

    invite(t) {
        return this.p("/client/invite", {callId: t})
    }

    call(t, i, s) {
        return this.v("/client/call", {callerId: t, calleeId: i, isScreenSharing: s})
    }

    accept(t, i) {
        return this.p("/client/accept", {callId: t, token: i})
    }

    reject(t, i) {
        return this.p("/client/reject", {callId: t, token: i})
    }

    offer(t, i, s) {
        return this.p("/client/offer", {callId: t, sdp: s, token: i})
    }

    answer(t, i, s) {
        return this.p("/client/answer", {callId: t, sdp: s, token: i})
    }

    ice(t, i, s) {
        return this.p("/client/ice", {callId: t, candidate: i, token: s})
    }

    end(t, i) {
        return this.p("/client/end", {callId: t, token: i})
    }
}

const h = new class {
    constructor() {
        this.g = [], this.I = 0, this.C = -1
    }

    m() {
        this.g.forEach((t => t.func()))
    }

    S() {
        this.C = setInterval((() => this.m()), 1e3)
    }

    k() {
        clearInterval(this.C), this.C = -1
    }

    addTask(t) {
        const i = this.I++, s = {id: i, func: t};
        return this.g.push(s), 1 == this.g.length && this.S(), i
    }

    removeTask(t) {
        const i = this.g.findIndex((i => i.id == t));
        -1 != i && (this.g.splice(i, 1), 0 == this.g.length && this.k())
    }
}, n = new class {
    newAudioContext() {
        return new (window.AudioContext || window.webkitAudioContext)
    }
};

class r {
    constructor() {
        this.P = -1, this.V = n.newAudioContext(), this.T = this.V.createAnalyser(), this.T.fftSize = 2048, this.A = new Uint8Array(this.T.frequencyBinCount), this.L = null, this.db = 0, this.ondbthresholdexceeded = t => {
        }, this.dbthreshold = 65
    }

    connect(t) {
        -1 == this.P && (this.P = h.addTask((() => this.j()))), this.L && this.L.disconnect(), this.L = this.V.createMediaStreamSource(t), this.L.connect(this.T)
    }

    disconnect() {
        -1 != this.P && (h.removeTask(this.P), this.L.disconnect(), this.L = null, this.P = -1)
    }

    j() {
        const t = this.A.length;
        let s = 0;
        this.T.getByteTimeDomainData(this.A);
        for (let i = 0; i < t; i++) {
            const t = .0078125 * (this.A[i] - 128);
            s += t * t
        }
        this.db = 10 * Math.log10(s / t), console.log("db=" + this.db), this.db >= this.dbthreshold && i.invokeAndIgnoreExceptions((() => this.ondbthresholdexceeded(this)))
    }
}

const a = "Copyright (c) 2022 Comlink Inc.";

function o() {
    return "1.1"
}

class c {
    constructor(t) {
        this.B = t.isInbound, this.O = t.isScreenSharing, this.U = t.remotePartyId, this.R = t.bridge, this.M = t.callId, this.N = t.config, this.D = t.token, this.J = null, this.H = null, this.K = null, this.t = null, this.F = null, this.G = null, this.W = [], t.isInbound ? this.q = 1 : this.q = 0, this.oncallstarted = t => this.X("Unhandled event: call started: " + t.M), this.oncallrejected = t => this.X("Unhandled event: call rejected: " + t.M), this.oncallended = t => this.X("Unhandled event: call ended: " + t.M), this.onstreamupdated = (t, i) => this.X("Unhandled event: stream updated: " + t.M), this.onparticipantlistupdated = (t, i) => this.X("Unhandled event: participant list updated: " + t.M), this.onviewportlayoutupdated = (t, i) => this.X("Unahndled event: viewport layout updated: " + i), this.onfacialrecognizerresults = (t, i) => this.X("Unhandled event: facial recognizer results: " + i)
    }

    Y(t) {
        console.log("VC/" + this.M + ": " + t)
    }

    Z(t) {
        console.error("VC/" + this.M + ": " + t)
    }

    X(t) {
        console.warn("VC/" + this.M + ": " + t)
    }

    $() {
        return this.J = new RTCPeerConnection(this.N), this.J.onicecandidate = t => this.tt(t), this.J.ontrack = t => this.it(t), this.O ? this.B ? Promise.resolve(this) : this.st() : this.et()
    }

    et() {
        return this.R.getLocalMediaStream().then((t => {
            t.getTracks().forEach((i => this.J.addTrack(i, t)))
        }))
    }

    st() {
        return navigator.mediaDevices.getDisplayMedia({video: {cursor: "always"}, audio: !0}).then((t => {
            t.getTracks().forEach((i => this.J.addTrack(i, t)))
        }))
    }

    ht() {
        this.K && (this.K.disconnect(), this.K = null), this.q = 6, this.R.nt(this), this.J.close()
    }

    rt(i) {
        switch (t("CALL" == i.type, 'Bad event type. "CALL" expected.'), i.name) {
            case"accept":
                this.ot();
                break;
            case"end":
                this.ct();
                break;
            case"reject":
                this.lt();
                break;
            case"sdp":
                this.dt(i.sdp, i.action);
                break;
            case"ice":
                this.ut(i.iceCandidate);
                break;
            case"participants":
                this._t(i.userIds);
                break;
            case"viewportLayout":
                this.vt({frameWidth: i.frameWidth, frameHeight: i.frameHeight, viewports: i.viewports});
                break;
            case"facialRecognition":
                this.gt({callId: i.tagCallId, tag: i.tag, confidence: i.confidence});
                break;
            default:
                throw new Error("Bad call state")
        }
    }

    _t(t) {
        this.F = t, i.invokeAndIgnoreExceptions((() => this.onparticipantlistupdated(this, this.F)))
    }

    vt(t) {
        this.G = t, i.invokeAndIgnoreExceptions((() => this.onviewportlayoutupdated(this, this.G)))
    }

    gt(t) {
        i.invokeAndIgnoreExceptions((() => this.onfacialrecognizerresults(this, t)))
    }

    ut(t) {
        this.J.remoteDescription ? this.J.addIceCandidate(t) : this.W.push(t)
    }

    it(t) {
        this.t = t.streams[0], this.K && this.K.connect(this.t), i.invokeAndIgnoreExceptions((() => this.onstreamupdated(this, this.t)))
    }

    ct() {
        i.invokeAndIgnoreExceptions((() => this.oncallended(this))), this.ht()
    }

    ot() {
        this.J.createOffer({
            offerToReceiveVideo: !0,
            offerToReceiveAudio: !0
        }).then((t => this.J.setLocalDescription(t))).then((() => this.R.bt.offer(this.M, this.D, this.J.localDescription.sdp))).catch((t => {
            throw this.ft(t), t
        })), i.invokeAndIgnoreExceptions((() => this.oncallstarted(this)))
    }

    lt() {
        this.R.nt(this), this.q = 4, i.invokeAndIgnoreExceptions((() => this.oncallrejected(this)))
    }

    dt(t, i) {
        const s = new RTCSessionDescription({type: i, sdp: t});
        "offer" == i ? this.J.setRemoteDescription(s).then((() => (this.wt(), this.J.createAnswer()))).then((t => this.J.setLocalDescription(t))).then((() => this.R.bt.answer(this.M, this.D, this.J.localDescription.sdp))).then((t => (this.q = 3, t))).catch((t => {
            throw this.ft(t), t
        })) : "answer" == i && this.J.setRemoteDescription(s).then((() => {
            this.wt(), this.q = 3
        })).catch((t => {
            throw this.ft(t), t
        }))
    }

    wt() {
        this.W.forEach((t => {
            this.J.addIceCandidate(t)
        })), this.W = []
    }

    tt(t) {
        if (t.candidate) try {
            this.R.bt.ice(this.M, t.candidate, this.D)
        } catch (t) {
            this.X("failed to transmit ICE candidate")
        }
    }

    ft(t) {
        this.q = 4, this.Z("panic: " + t.message)
    }

    getParticipantList() {
        return this.F
    }

    getViewportLayout() {
        return this.G
    }

    getCallId() {
        return this.M
    }

    getVideoBridge() {
        return this.R
    }

    getRemotePartyId() {
        return this.U
    }

    isInbound() {
        return this.B
    }

    setUserData(t) {
        this.H = t
    }

    getUserData() {
        return this.H
    }

    isScreenSharing() {
        return this.O
    }

    attachActivityMonitor(s, e) {
        t(null == this.K, "Activity notifier already attached"), t(null != e, "Activity monitor callback not defined"), this.K = new r, this.K.dbtheshold = s, this.K.ondbthresholdexceeded = t => i.invokeAndIgnoreExceptions((() => e(this))), this.t && this.K.connect(this.t)
    }

    getSoundLevel() {
        return this.K || this.K.db
    }

    start() {
        return t(0 == this.q, "Call already initialized"), this.q = 1, this.Y("starting"), this.R.bt.call(this.R.getUserId(), this.U, this.O).then((t => (this.M = t.callId, this.N = t.config, this.D = t.token, this.$()))).then((() => this.R.bt.invite(this.M))).then((() => (this.q = 2, this.R.It(this), this))).catch((t => {
            throw this.ft(t), t
        }))
    }

    accept() {
        return t(1 == this.q, "Invalid call state"), this.Y("accepting"), this.$().then((() => this.R.bt.accept(this.M, this.D))).then((t => (this.q = 2, this))).catch((t => {
            throw this.ft(t), t
        }))
    }

    reject() {
        return t(1 == this.q, "Invalid call state"), this.Y("rejecting"), this.R.bt.reject(this.M, this.D).then((t => (this.q = 5, this.R.nt(this), this))).catch((t => {
            throw this.ft(t), t
        }))
    }

    stop() {
        return 6 != this.q && 4 != this.q ? (this.ht(), this.R.bt.end(this.M, this.D).then((() => this))) : Promise.resolve(this)
    }

    muteRemoteAudio(i) {
        t("boolean" == typeof i, "Expected a boolean value"), this.J.getReceivers().forEach((t => {
            "audio" == t.track.kind && (t.track.enabled = i)
        }))
    }
}

class l {
    constructor(t) {
        this.yt = t.userId, this.Ct = t.type, this.St = t.passwordHash, this.bt = new e(t.serviceUrl || ""), this.kt = !1, this.Et = {}, this.Pt = !1, this.Vt = !1, this.Tt = null, this.At = null, this.onbridgeactive = t => console.log("onbridgeactive event not handled"), this.onbridgeinactive = t => console.log("onbridgeinactive event not handled"), this.onbridgefailure = t => console.log("onbridgefailure event not handled"), this.onincomingcall = t => {
            console.log("Inbound call event not handled; call rejected."), t.reject()
        }
    }

    ft(t) {
        console.log("Catastrophic bridge failure: " + t), i.invokeAndIgnoreExceptions((() => this.onbridgefailure(this))), this.shutdown()
    }

    Lt() {
        this.kt ? this.ft(new Error("Event stream closed unexpectedly")) : (i.invokeAndIgnoreExceptions((() => this.onbridgeinactive(this))), this.shutdown())
    }

    jt() {
        this.Tt.readEvent().then((t => {
            if (this.Tt.eof()) this.Lt(); else {
                try {
                    const i = JSON.parse(t);
                    this.rt(i)
                } catch (t) {
                    return void this.ft(t)
                }
                this.jt()
            }
        }))
    }

    Bt(t) {
        const i = this.Et[t.callId];
        i ? i.rt(t) : console.log("Invalid call identifier in the event stream: " + t.callId)
    }

    Ot(t) {
        const s = new c({
            bridge: this,
            callId: t.callId,
            isInbound: !0,
            isScreenSharing: t.isScreenSharing,
            remotePartyId: t.callerId,
            config: t.config,
            token: t.token
        });
        this.It(s), i.invokeAndIgnoreExceptions((() => this.onincomingcall(s)))
    }

    Ut(t) {
        this.kt || (this.kt = !0, i.invokeAndIgnoreExceptions((() => this.onbridgeactive(this))))
    }

    rt(t) {
        switch (console.log(t), t.type) {
            case"INCOMING":
                this.Ot(t);
                break;
            case"KEEPALIVE":
                this.Ut(t);
                break;
            case"CALL":
                this.Bt(t);
                break;
            default:
                this.ft(new Error("Bad event type: " + t.type + ". Corrupt stream?"))
        }
    }

    xt() {
        Object.values(this.Et).forEach((t => t.ht())), this.Et = {}
    }

    It(t) {
        this.Et[t.getCallId()] = t
    }

    nt(t) {
        const i = t.getCallId();
        this.Et.hasOwnProperty(i) && delete this.Et[i]
    }

    getUserId() {
        return this.yt
    }

    getCalls() {
        return Object.values(this.Et)
    }

    hasCamera() {
        return this.Pt
    }

    hasMicrophone() {
        return this.Vt
    }

    getCallById(t) {
        return this.Et[t]
    }

    isActive() {
        return this.kt
    }

    getLocalMediaStream() {
        return t(this.kt, "VideoBridge not active"), this.At ? Promise.resolve(this.At) : navigator.mediaDevices.enumerateDevices().then((t => {
            var i = {};
            return null != t.find((t => "videoinput" == t.kind)) && (this.Pt = !0, i.video = {
                width: 800,
                height: 600
            }), null != t.find((t => "audioinput" == t.kind)) && (this.Vt = !0, i.audio = {channels: 1}), navigator.mediaDevices.getUserMedia(i)
        })).then((t => (this.At = t, t)))
    }

    closeLocalMediaStream() {
        t(this.kt, "VideoBridge not active"), this.At && (this.At.getTracks().forEach((t => t.stop())), this.At = null, this.Vt = !1, this.Pt = !1)
    }

    enableCamera(i) {
        t(this.kt, "Video bridge not active"), t("boolean" == typeof i, "Expected a boolean value"), this.Pt && this.At.getTracks().forEach((t => {
            "live" == t.readyState && "video" === t.kind && (t.enabled = i)
        }))
    }

    enableMicrophone(i) {
        t(this.kt, "Video bridge not active"), t("boolean" == typeof i, "Expected a boolean value"), this.Vt && this.At.getTracks().forEach((t => {
            "live" == t.readyState && "audio" === t.kind && (t.enabled = i)
        }))
    }

    start() {
        t(!this.kt, "Video bridge already active"), console.log("CVB v1.1. " + a), this.bt.createBridge(this.yt, this.St, this.Ct).then((t => t.body)).then((t => {
            this.Tt = new s(t.getReader()), this.jt()
        })).catch((t => {
            console.error("Video bridge creation failure: " + t), i.invokeAndIgnoreExceptions((() => this.onbridgefailure(this))), this.ft(t)
        }))
    }

    shutdown() {
        t(this.kt, "Video bridge not active"), console.log("CVB v1.1. " + a), Object.values(this.Et).forEach((t => t.stop())), this.Et = {}, this.Tt.cancel(), this.closeLocalMediaStream(), this.kt = !1
    }

    createVideoCall(i) {
        return t(this.kt, "Video bridge not active"), new c({
            bridge: this,
            isInbound: !1,
            isScreenSharing: !1,
            remotePartyId: i
        })
    }

    createScreenSharingCall(i) {
        return t(this.kt, "Video bridge not activbe"), new c({
            bridge: this,
            isInboud: !1,
            isScreenSharing: !0,
            remotePartyId: i
        })
    }
}

export {l as VideoBridge, c as VideoCall, o as getVersion};
