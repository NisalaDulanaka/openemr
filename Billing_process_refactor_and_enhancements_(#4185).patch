Index: controllers/C_X12Partner.class.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/controllers/C_X12Partner.class.php b/controllers/C_X12Partner.class.php
--- a/controllers/C_X12Partner.class.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/controllers/C_X12Partner.class.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -1,5 +1,19 @@
 <?php
 
+/**
+ * controller class for x-12 partner screen
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+use OpenEMR\Common\Crypto\CryptoGen;
+
 class C_X12Partner extends Controller
 {
 
@@ -10,7 +24,7 @@
     function __construct($template_mod = "general")
     {
         parent::__construct();
-        $this->x12_partner = array();
+        $this->x12_partners = array();
         $this->template_mod = $template_mod;
         $this->assign("FORM_ACTION", $GLOBALS['webroot'] . "/controller.php?" . attr($_SERVER['QUERY_STRING']));
         $this->assign("CURRENT_ACTION", $GLOBALS['webroot'] . "/controller.php?" . "practice_settings&x12_partner&");
@@ -32,6 +46,12 @@
             $this->x12_partners[0] = new X12Partner();
         }
 
+        // If we have an SFTP password set, decrypt it
+        if ($this->x12_partners[0]->get_x12_sftp_pass()) {
+            $cryptoGen = new CryptoGen();
+            $this->x12_partners[0]->set_x12_sftp_pass($cryptoGen->decryptStandard($this->x12_partners[0]->get_x12_sftp_pass()));
+        }
+
         $this->assign("partner", $this->x12_partners[0]);
         return $this->fetch($GLOBALS['template_dir'] . "x12_partners/" . $this->template_mod . "_edit.html");
     }
@@ -59,16 +79,22 @@
 
         //print_r($_POST);
         if (is_numeric($_POST['id'])) {
-            $this->x12_partner[0] = new X12Partner($_POST['id']);
+            $this->x12_partners[0] = new X12Partner($_POST['id']);
         } else {
-            $this->x12_partner[0] = new X12Partner();
+            $this->x12_partners[0] = new X12Partner();
         }
 
-        parent::populate_object($this->x12_partner[0]);
+        parent::populate_object($this->x12_partners[0]);
+
+        // If we are setting the SFTP password, encrypt it
+        if (!empty($_POST['x12_sftp_pass'])) {
+            $cryptoGen = new CryptoGen();
+            $this->x12_partners[0]->x12_sftp_pass = $cryptoGen->encryptStandard($this->x12_partners[0]->x12_sftp_pass);
+        }
 
-        $this->x12_partner[0]->persist();
+        $this->x12_partners[0]->persist();
         //insurance numbers need to be repopulated so that insurance_company_name recieves a value
-        $this->x12_partner[0]->populate();
+        $this->x12_partners[0]->populate();
 
         //echo "action processeed";
         $_POST['process'] = "";
Index: interface/billing/billing_process.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/billing/billing_process.php b/interface/billing/billing_process.php
--- a/interface/billing/billing_process.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/interface/billing/billing_process.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -19,13 +19,8 @@
  */
 
 require_once("../globals.php");
-require_once("$srcdir/patient.inc");
 
-use OpenEMR\Billing\BillingUtilities;
-use OpenEMR\Billing\Hcfa1500;
-use OpenEMR\Billing\X125010837I;
-use OpenEMR\Billing\X125010837P;
-use OpenEMR\Common\Crypto\CryptoGen;
+use OpenEMR\Billing\BillingProcessor\BillingProcessor;
 use OpenEMR\Common\Csrf\CsrfUtils;
 use OpenEMR\Core\Header;
 
@@ -33,470 +28,9 @@
     CsrfUtils::csrfNotVerified();
 }
 
-if ($GLOBALS['ub04_support']) {
-    require_once("./ub04_dispose.php");
-}
-$EXPORT_INC = "$webserver_root/custom/BillingExport.php";
-if (file_exists($EXPORT_INC)) {
-    include_once($EXPORT_INC);
-    $BILLING_EXPORT = true;
-}
-
-$bill_info = array();
-
-$bat_type = ''; // will be edi or hcfa
-$bat_sendid = '';
-$bat_recvid = '';
-$bat_content = '';
-$bat_gscount = 0;
-$bat_stcount = 0;
-$bat_time = time();
-$bat_hhmm = date('Hi', $bat_time);
-$bat_yymmdd = date('ymd', $bat_time);
-$bat_yyyymmdd = date('Ymd', $bat_time);
-// Seconds since 1/1/1970 00:00:00 GMT will be our interchange control number
-// but since limited to 9 char must be without leading 1
-$bat_icn = substr((string)$bat_time, 1, 9);
-$bat_filename = date("Y-m-d-Hi", $bat_time) . "-batch.";
-$bat_filename .= (isset($_POST['bn_process_hcfa']) || isset($_POST['bn_process_hcfa_form']) || isset($_POST['bn_process_ub04']) || isset($_POST['bn_process_ub04_form'])) ? 'pdf' : 'txt';
-$template = array();
-$ub04id = array();
-$validatePass = false;
-
-if (isset($_POST['bn_process_hcfa']) || isset($_POST['bn_process_hcfa_form'])) {
-    $pdf = new Cezpdf('LETTER');
-    $pdf->ezSetMargins(trim($_POST['top_margin']) + 0, 0, trim($_POST['left_margin']) + 0, 0);
-    $pdf->selectFont('Courier');
-}
-
-function append_claim(&$segs)
-{
-    global $bat_content, $bat_sendid, $bat_recvid, $bat_sender, $bat_stcount;
-    global $bat_gscount, $bat_yymmdd, $bat_yyyymmdd, $bat_hhmm, $bat_icn;
-
-    foreach ($segs as $seg) {
-        if (!$seg) {
-            continue;
-        }
-        $elems = explode('*', $seg);
-        if ($elems[0] == 'ISA') {
-            if (!$bat_content) {
-                $bat_sendid = trim($elems[6]);
-                $bat_recvid = trim($elems[8]);
-                $bat_sender = (!empty($GS02)) ? $GS02 : $bat_sendid;
-                $bat_content = substr($seg, 0, 70) . "$bat_yymmdd*$bat_hhmm*" . $elems[11] . "*" . $elems[12] . "*$bat_icn*" . $elems[14] . "*" . $elems[15] . "*:~";
-            }
-            continue;
-        } elseif (!$bat_content) {
-            die("Error:<br />\nInput must begin with 'ISA'; " . "found '" . text($elems[0]) . "' instead");
-        }
-        if ($elems[0] == 'GS') {
-            if ($bat_gscount == 0) {
-                ++$bat_gscount;
-                $bat_content .= "GS*HC*" . $elems[2] . "*" . $elems[3] . "*$bat_yyyymmdd*$bat_hhmm*1*X*" . $elems[8] . "~";
-            }
-            continue;
-        }
-        if ($elems[0] == 'ST') {
-            ++$bat_stcount;
-            $bat_st_02 = sprintf("%04d", $bat_stcount);
-            $bat_content .= "ST*837*" . $bat_st_02;
-            if (!empty($elems[3])) {
-                $bat_content .= "*" . $elems[3];
-            }
-
-            $bat_content .= "~";
-            continue;
-        }
-
-        if ($elems[0] == 'BHT') {
-            // needle is set in OpenEMR\Billing\X125010837P
-            $bat_content .= substr_replace($seg, '*' . $bat_icn . $bat_st_02 . '*', strpos($seg, '*0123*'), 6);
-            $bat_content .= "~";
-            continue;
-        }
-
-        if ($elems[0] == 'SE') {
-            $bat_content .= sprintf("SE*%d*%04d~", $elems[1], $bat_stcount);
-            continue;
-        }
-
-        if ($elems[0] == 'GE' || $elems[0] == 'IEA') {
-            continue;
-        }
-
-        $bat_content .= $seg . '~';
-    }
-}
-
-function append_claim_close()
-{
-    global $bat_content, $bat_stcount, $bat_gscount, $bat_icn;
-    if ($bat_gscount) {
-        $bat_content .= "GE*$bat_stcount*1~";
-    }
-
-    $bat_content .= "IEA*$bat_gscount*$bat_icn~";
-}
-
-function send_batch()
-{
-    global $bat_content, $bat_filename;
-    // If a writable edi directory exists, log the batch to it.
-    // I guarantee you'll be glad we did this. :-)
-    $fh = @fopen($GLOBALS['OE_SITE_DIR'] . "/documents/edi/$bat_filename", 'a');
-    if ($fh) {
-        fwrite($fh, $bat_content);
-        fclose($fh);
-    }
-    header("Pragma: public");
-    header("Expires: 0");
-    header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
-    header("Content-Type: application/force-download");
-    header("Content-Disposition: attachment; filename=$bat_filename");
-    header("Content-Description: File Transfer");
-    header("Content-Length: " . strlen($bat_content));
-    echo $bat_content;
-}
-
-function validate_payer_reset(&$payer_id_held, $patient_id, $encounter)
-{
-    if ($payer_id_held > -1) {
-        sqlStatement("UPDATE billing SET payer_id = ? WHERE " .
-            "pid= ? AND encounter = ? AND activity = 1", array($payer_id_held, $patient_id, $encounter));
-        $payer_id_held = -1;
-    }
-}
-
-process_form($_POST);
-
-function process_form($ar)
-{
-    global $bill_info, $bat_filename, $pdf, $template;
-    global $ub04id, $validatePass;
-
-    // Set up crypto object
-    $cryptoGen = new CryptoGen();
-
-    if (
-        isset($ar['bn_x12']) || isset($ar['bn_x12_encounter']) || isset($ar['bn_process_hcfa']) || isset($ar['bn_hcfa_txt_file']) || isset($ar['bn_process_hcfa_form'])
-        || isset($ar['bn_process_ub04_form']) || isset($ar['bn_process_ub04']) || isset($ar['bn_ub04_x12'])
-    ) {
-        if ($GLOBALS['billing_log_option'] == 1) {
-            if (file_exists($GLOBALS['OE_SITE_DIR'] . "/documents/edi/process_bills.log")) {
-                $hlog = file_get_contents($GLOBALS['OE_SITE_DIR'] . "/documents/edi/process_bills.log");
-            }
-            if ($cryptoGen->cryptCheckStandard($hlog)) {
-                $hlog = $cryptoGen->decryptStandard($hlog, null, 'database');
-            }
-        } else { // ($GLOBALS['billing_log_option'] == 2)
-            $hlog = '';
-        }
-    }
-
-
-    if (isset($ar['bn_external'])) {
-        // Open external billing file for output.
-        $be = new BillingExport();
-    }
-
-    if (empty($ar['claims'])) {
-        $ar['claims'] = array();
-    }
-    $bat_content = "";
-    $claim_count = 0;
-    foreach ($ar['claims'] as $claimid => $claim_array) {
-        $ta = explode("-", $claimid);
-        $patient_id = $ta[0];
-        $encounter = $ta[1];
-        $payer_id = substr($claim_array['payer'], 1);
-        $payer_type = substr(strtoupper($claim_array['payer']), 0, 1);
-        if ($payer_type == 'P') {
-            $payer_type = 1;
-        } elseif ($payer_type == 'S') {
-            $payer_type = 2;
-        } elseif ($payer_type == 'T') {
-            $payer_type = 3;
-        } else {
-            $payer_type = 0;
-        }
-
-        if (isset($claim_array['bill'])) {
-            if (isset($ar['bn_external'])) {
-                // Write external claim.
-                $be->addClaim($patient_id, $encounter);
-            } else {
-                $sql = "SELECT x.processing_format from x12_partners as x where x.id =?";
-                $result = sqlQuery($sql, [$claim_array['partner']]);
-                $target = "x12";
-                if (!empty($result['processing_format'])) {
-                    $target = $result['processing_format'];
-                }
-            }
-
-            $clear_claim = isset($ar['btn-clear']);
-            $validate_claim = isset($ar['btn-validate']);
-            $validatePass = $validate_claim || $clear_claim;
-            $payer_id_held = -1;
-            $tmp = 1;
-            if (!$validate_claim) {
-                if ($clear_claim) {
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 2); // $sql .= " billed = 1, ";
-                }
-                if (isset($ar['bn_x12']) || isset($ar['bn_x12_encounter']) && !$clear_claim) {
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 2, 1, '', $target, $claim_array['partner']);
-                } elseif (isset($ar['bn_ub04_x12'])) {
-                    $ub04id = get_ub04_array($patient_id, $encounter);
-                    $ub_save = json_encode($ub04id);
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 2, 1, '', $target, $claim_array['partner'] . '-837I', 0, $ub_save);
-                } elseif (isset($ar['bn_process_ub04_form']) || isset($ar['bn_process_ub04'])) {
-                    $ub04id = get_ub04_array($patient_id, $encounter);
-                    $ub_save = json_encode($ub04id);
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 2, 1, '', 'ub04', -1, 0, $ub_save);
-                } elseif (isset($ar['bn_process_hcfa']) || isset($ar['bn_hcfa_txt_file']) || isset($ar['bn_process_hcfa_form']) && !$clear_claim) {
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 2, 1, '', 'hcfa');
-                } elseif (isset($ar['bn_mark'])) {
-                    // $sql .= " billed = 1, ";
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 2);
-                } elseif (isset($ar['bn_reopen'])) {
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 1, 0);
-                } elseif (isset($ar['bn_external'])) {
-                    // $sql .= " billed = 1, ";
-                    $tmp = BillingUtilities::updateClaim(true, $patient_id, $encounter, $payer_id, $payer_type, 2);
-                }
-            } else {
-                // so if we validate lets validate against currently set payer.
-                // will reset to current payer once claim processed(below).
-                $payer_id_held = sqlQueryNoLog("SELECT payer_id FROM billing WHERE " .
-                    "pid= ? AND encounter = ? AND activity = 1", array($patient_id, $encounter))['payer_id'];
-                sqlStatementNoLog("UPDATE billing SET payer_id = ? WHERE " .
-                    "pid= ? AND encounter = ? AND activity = 1", array($payer_id, $patient_id, $encounter));
-            }
-            if (!$tmp) {
-                die(xlt("Claim ") . text($claimid) . xlt(" update failed, not in database?"));
-            } else {
-                if ($validate_claim) {
-                    $hlog .= xl("Validating Claim") . " " . $claimid . " " . xl("existing claim status is not altered.") . "\n";
-                }
-                if ($clear_claim) {
-                    $hlog .= xl("Validating Claim") . " " . $claimid . " " . xl("and resetting claim status.") . "\n";
-                }
-                if (isset($ar['bn_mark'])) {
-                    $bill_info[] = xl("Claim ") . $claimid . xl(" was marked as billed only.") . "\n";
-                } elseif (isset($ar['bn_reopen'])) {
-                    $bill_info[] = xl("Claim ") . $claimid . xl(" has been re-opened.") . "\n";
-                } elseif (isset($ar['bn_x12']) || isset($ar['bn_x12_encounter'])) {
-                    $log = '';
-                    $segs = explode("~\n", X125010837P::genX12837P($patient_id, $encounter, $log, isset($ar['bn_x12_encounter'])));
-                    $hlog .= $log;
-                    append_claim($segs);
-                    if ($validatePass) {
-                        validate_payer_reset($payer_id_held, $patient_id, $encounter);
-                        continue;
-                    }
-                    if (!BillingUtilities::updateClaim(false, $patient_id, $encounter, -1, -1, 2, 2, $bat_filename)) {
-                        $bill_info[] = xl("Internal error: claim ") . $claimid . xl(" not found!") . "\n";
-                    }
-                } elseif (isset($ar['bn_ub04_x12'])) {
-                    $log = '';
-                    $segs = explode("~\n", X125010837I::generateX12837I($patient_id, $encounter, $log, $ub04id));
-                    $hlog .= $log;
-                    append_claim($segs);
-                    if ($validatePass) {
-                        validate_payer_reset($payer_id_held, $patient_id, $encounter);
-                        continue;
-                    }
-                    if (!BillingUtilities::updateClaim(false, $patient_id, $encounter, -1, -1, 2, 2, $bat_filename, 'X12-837I', -1, 0, json_encode($ub04id))) {
-                        $bill_info[] = xl("Internal error: claim ") . $claimid . xl(" not found!") . "\n";
-                    }
-                } elseif (isset($ar['bn_process_hcfa'])) {
-                    $log = '';
-                    $hcfa = new Hcfa1500();
-                    $lines = $hcfa->genHcfa1500($patient_id, $encounter, $log);
-                    $hlog .= $log;
-                    $alines = explode("\014", $lines); // form feeds may separate pages
-                    foreach ($alines as $tmplines) {
-                        if ($claim_count++) {
-                            $pdf->ezNewPage();
-                        }
-                        $pdf->ezSetY($pdf->ez['pageHeight'] - $pdf->ez['topMargin']);
-                        $pdf->ezText($tmplines, 12, array(
-                            'justification' => 'left',
-                            'leading' => 12
-                        ));
-                    }
-                    if ($validatePass) {
-                        validate_payer_reset($payer_id_held, $patient_id, $encounter);
-                        continue;
-                    }
-                    if (!BillingUtilities::updateClaim(false, $patient_id, $encounter, -1, -1, 2, 2, $bat_filename)) {
-                        $bill_info[] = xl("Internal error: claim ") . $claimid . xl(" not found!") . "\n";
-                    }
-                } elseif (isset($ar['bn_process_hcfa_form'])) {
-                    $log = '';
-                    $hcfa = new Hcfa1500();
-                    $lines = $hcfa->genHcfa1500($patient_id, $encounter, $log);
-                    $hcfa_image = $GLOBALS['images_static_absolute'] . "/cms1500.png";
-                    $hlog .= $log;
-                    $alines = explode("\014", $lines); // form feeds may separate pages
-                    foreach ($alines as $tmplines) {
-                        if ($claim_count++) {
-                            $pdf->ezNewPage();
-                        }
-                        $pdf->ezSetY($pdf->ez['pageHeight'] - $pdf->ez['topMargin']);
-                        $pdf->addPngFromFile("$hcfa_image", 0, 0, 612, 792);
-                        $pdf->ezText($tmplines, 12, array(
-                            'justification' => 'left',
-                            'leading' => 12
-                        ));
-                    }
-                    if ($validatePass) {
-                        validate_payer_reset($payer_id_held, $patient_id, $encounter);
-                        continue;
-                    }
-                    if (!BillingUtilities::updateClaim(false, $patient_id, $encounter, -1, -1, 2, 2, $bat_filename)) {
-                        $bill_info[] = xl("Internal error: claim ") . $claimid . xl(" not found!") . "\n";
-                    }
-                } elseif (isset($ar['bn_process_ub04_form']) || isset($ar['bn_process_ub04'])) {
-                    $claim_count++;
-                    $log = "";
-                    $template[] = buildTemplate($patient_id, $encounter, "", "", $log);
-                    $hlog .= $log;
-                    if ($validatePass) {
-                        validate_payer_reset($payer_id_held, $patient_id, $encounter);
-                        continue;
-                    }
-                    if (!BillingUtilities::updateClaim(false, $patient_id, $encounter, -1, -1, 2, 2, $bat_filename, 'ub04', -1, 0, json_encode($ub04id))) {
-                        $bill_info[] = xl("Internal error: claim ") . $claimid . xl(" not found!") . "\n";
-                    }
-                } elseif (isset($ar['bn_hcfa_txt_file'])) {
-                    $log = '';
-                    $hcfa = new Hcfa1500();
-                    $lines = $hcfa->genHcfa1500($patient_id, $encounter, $log);
-                    $hlog .= $log;
-                    $bat_content .= $lines;
-                    if ($validatePass) {
-                        validate_payer_reset($payer_id_held, $patient_id, $encounter);
-                        continue;
-                    }
-                    if (!BillingUtilities::updateClaim(false, $patient_id, $encounter, -1, -1, 2, 2, $bat_filename)) {
-                        $bill_info[] = xl("Internal error: claim ") . $claimid . xl(" not found!") . "\n";
-                    }
-                } else {
-                    $bill_info[] = xl("Claim ") . $claimid . xl(" was queued successfully.") . "\n";
-                }
-            }
-        } // end if this claim has billing
-    } // end foreach
-
-    if (!empty($hlog)) {
-        if ($GLOBALS['drive_encryption']) {
-            $hlog = $cryptoGen->encryptStandard($hlog, null, 'database');
-        }
-        file_put_contents($GLOBALS['OE_SITE_DIR'] . "/documents/edi/process_bills.log", $hlog);
-    }
-
-    if (isset($ar['bn_process_ub04_form']) || isset($ar['bn_process_ub04'])) {
-        if (isset($ar['bn_process_ub04'])) {
-            $action = "noform";
-        } elseif (isset($ar['bn_process_ub04_form'])) {
-            $action = "form";
-        }
-        ub04Dispose('download', $template, $bat_filename, $action);
-        exit();
-    }
-
-    if ($validatePass) {
-        if (isset($ar['bn_hcfa_txt_file'])) {
-            $format_bat = $bat_content;
-            $wrap = "<!DOCTYPE html><html><head></head><body><div><pre>" . text($format_bat) . "</pre></div></body></html>";
-            echo $wrap;
-            exit();
-        } elseif (isset($ar['bn_x12']) || isset($ar['bn_x12_encounter']) || isset($ar['bn_ub04_x12'])) {
-            global $bat_content;
-            append_claim_close();
-            $format_bat = str_replace('~', PHP_EOL, $bat_content);
-            $wrap = "<!DOCTYPE html><html><head></head><body><div style='overflow: hidden;'><pre>" . text($format_bat) . "</pre></div></body></html>";
-            echo $wrap;
-            exit();
-        } else {
-            $fname = tempnam($GLOBALS['temporary_files_dir'], 'PDF');
-            file_put_contents($fname, $pdf->ezOutput());
-            // Send the content for view.
-            header("Pragma: public");
-            header("Expires: 0");
-            header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
-            header('Content-type: application/pdf');
-            header('Content-Disposition: inline; filename="' . $bat_filename . '"');
-            header('Content-Transfer-Encoding: binary');
-            header('Content-Length: ' . filesize($fname));
-            ob_end_clean();
-            @readfile($fname);
-            unlink($fname);
-            exit();
-        }
-        die(xlt("Unknown Selection"));
-    } else {
-        if (isset($ar['bn_x12']) || isset($ar['bn_x12_encounter']) || isset($ar['bn_ub04_x12'])) {
-            append_claim_close();
-            send_batch();
-            exit();
-        }
-        if (isset($ar['bn_process_hcfa'])) {
-            // If a writable edi directory exists (and it should), write the pdf to it.
-            $fh = @fopen($GLOBALS['OE_SITE_DIR'] . "/documents/edi/$bat_filename", 'a');
-            if ($fh) {
-                fwrite($fh, $pdf->ezOutput());
-                fclose($fh);
-            }
-            // Send the PDF download.
-            $pdf->ezStream(array(
-                'Content-Disposition' => $bat_filename
-            ));
-            exit();
-        }
-        if (isset($ar['bn_process_hcfa_form'])) {
-            // If a writable edi directory exists (and it should), write the pdf to it.
-            $fh = @fopen($GLOBALS['OE_SITE_DIR'] . "/documents/edi/$bat_filename", 'a');
-            if ($fh) {
-                fwrite($fh, $pdf->ezOutput());
-                fclose($fh);
-            }
-            // Send the PDF download.
-            header("Pragma: public");
-            header("Expires: 0");
-            header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
-            header("Content-Type: application/force-download");
-            header("Content-Disposition: attachment; filename=$bat_filename");
-            header("Content-Description: File Transfer");
-            // header("Content-Length: " . strlen($bat_content));
-            echo $pdf->ezOutput();
-
-            exit();
-        }
-        if (isset($ar['bn_hcfa_txt_file'])) {
-            $fh = @fopen($GLOBALS['OE_SITE_DIR'] . "/documents/edi/$bat_filename", 'a');
-            if ($fh) {
-                fwrite($fh, $bat_content);
-                fclose($fh);
-            }
-            header("Pragma: public");
-            header("Expires: 0");
-            header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
-            header("Content-Type: application/force-download");
-            header("Content-Disposition: attachment; filename=$bat_filename");
-            header("Content-Description: File Transfer");
-            header("Content-Length: " . strlen($bat_content));
-            echo $bat_content;
-            exit();
-        }
-        if (isset($ar['bn_external'])) {
-            // Close external billing file.
-            $be->close();
-        }
-    }
-}
-
+// Initialize billing processor with the post variables from the billing manager form
+$billingProcessor = new BillingProcessor($_POST);
+$logger = $billingProcessor->execute();
 ?>
 <html>
 <head>
@@ -515,19 +49,17 @@
             <div class="col-12">
                 <h3><?php echo xlt('Billing queue results'); ?>:</h3>
                 <ul>
-                    <li>
-                        <?php
-                        foreach ($bill_info as $infoline) {
-                            echo nl2br($infoline);
-                        }
-                        ?>
-                    </li>
+                    <?php  foreach ($logger->bill_info() as $infoline) { ?>
+                        <li>
+                            <?php echo nl2br(text($infoline)); ?>
+                        </li>
+                    <?php } ?>
                 </ul>
-                <button class="btn btn-secondary btn-sm btn-cancel" id="close-link">
-                    <?php echo xlt('Close'); ?>
-                </button>
             </div>
         </div>
     </div>
-</body>
 </html>
+<?php
+    $logger->onLogComplete();
+?>
+</body>
Index: interface/billing/billing_report.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/billing/billing_report.php b/interface/billing/billing_report.php
--- a/interface/billing/billing_report.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/interface/billing/billing_report.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -139,32 +139,32 @@
         function doSubmit(action) {
             top.restoreSession();
             return new Promise(function(resolve, reject) {
-                if (action !== 'btn-continue') {
-                    var showLog = function() {
-                        $("#view-log-link").click();
-                    };
-                    // Pre-open a dialog and target dialogs iframe for content from billing_process
-                    // text or PDF.
-                    dlgopen('', 'ValidateShowBatch', 875, 500, false, '', {
-                        buttons: [{
-                                text: '<?php echo xlt("Logs"); ?>',
-                                close: false,
-                                style: 'default btn-sm',
-                                click: showLog
-                            },
-                            {
-                                text: '<i class="fa fa-thumbs-up"></i>&nbsp;<?php echo xlt("Close"); ?>',
-                                close: true,
-                                style: 'default btn-sm'
-                            }
-                        ],
-                        //onClosed: 'SubmitTheScreen', // future and/or example of onClosed.
-                        sizeHeight: 'full'
-                    });
-                    // target content from submit to dialogs iframe
-                    document.update_form.target = 'ValidateShowBatch';
-                }
+                var showLog = function() {
+                    $("#view-log-link").click();
+                };
+                // Pre-open a dialog and target dialogs iframe for content from billing_process
+                // text or PDF.
+                dlgopen('', 'ValidateShowBatch', 875, 500, false, '', {
+                    buttons: [{
+                            text: '<?php echo xlt("Logs"); ?>',
+                            close: false,
+                            style: 'default btn-sm',
+                            click: showLog
+                        },
+                        {
+                            text: '<i class="fa fa-thumbs-up"></i>&nbsp;<?php echo xlt("Close"); ?>',
+                            close: true,
+                            style: 'default btn-sm'
+                        }
+                    ],
+                    //onClosed: 'SubmitTheScreen', // future and/or example of onClosed.
+                    sizeHeight: 'full'
+                });
+                // target content from submit to dialogs iframe
+                document.update_form.target = 'ValidateShowBatch';
+
                 // Now submit form and populate dialog.
+                top.restoreSession(); // Not sure if this is needed but something in billing is causing 'SITE ID' error
                 document.update_form.submit();
                 // go fulfill the promise.
                 resolve(true);
@@ -728,7 +728,7 @@
                             <?php } ?>
                             <?php if ($GLOBALS['ub04_support']) { ?>
                             <li class="nav-item">
-                                <button type="submit" class="btn nav-link btn-link btn-download" name="bn_ub04_x12" title="<?php echo xla('Generate Institutional X12 837I') ?>">
+                                <button type="submit" class="btn nav-link btn-link btn-download" name="bn_ub04_x12" onclick="confirmActions(event, '1');" title="<?php echo xla('Generate Institutional X12 837I') ?>">
                                     <?php echo xlt('Generate X12 837I') ?>
                                 </button>
                             </li>
Index: interface/billing/billing_tracker.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/billing/billing_tracker.php b/interface/billing/billing_tracker.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/interface/billing/billing_tracker.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,188 @@
+<?php
+
+/**
+ * Interface that provides tracking information for a claim batch
+ *
+ * The back-end ajax that goes with this datatables implementation is
+ * located in library/ajax/billing_tracker_ajax.php
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+require_once(__DIR__ . "/../globals.php");
+require_once "$srcdir/options.inc.php";
+
+use OpenEMR\Common\Acl\AclMain;
+use OpenEMR\Common\Csrf\CsrfUtils;
+use OpenEMR\Core\Header;
+use OpenEMR\OeUI\OemrUI;
+?>
+<html>
+<head>
+    <?php Header::setupHeader(['datatables', 'datatables-colreorder', 'datatables-dt', 'datatables-bs']); ?>
+    <title><?php echo xlt("Claim File Tracker"); ?></title>
+    <style>
+        table.dataTable td.details-control:before {
+            content: '\f152';
+            font-family: 'Font Awesome\ 5 Free';
+            cursor: pointer;
+            font-size: 22px;
+            color: #55a4be;
+        }
+        table.dataTable tr.shown td.details-control:before {
+            content: '\f150';
+            color: black;
+        }
+    </style>
+    <script type="text/javascript">
+        $(document).ready(function() {
+            const serverUrl = "<?php echo $GLOBALS['webroot']; ?>/library/ajax/billing_tracker_ajax.php?csrf_token_form=" + <?php echo js_url(CsrfUtils::collectCsrfToken()); ?>;
+            const oTable = $('#billing-tracker-table').DataTable({
+                "processing": true,
+                // next 2 lines invoke server side processing
+                "ajax": {
+                    "type" : "GET",
+                    "url" : serverUrl,
+                    "dataSrc": function (json) {
+                        return json.data;
+                    }
+                },
+                "columns": [
+                    {
+                        "class": 'details-control',
+                        "orderable": false,
+                        "data": null,
+                        "defaultContent": ''
+                    },
+                    {
+                        "data": "status",
+                        "render": function(data, type, row, meta) {
+                            // Format the status with a nice looking badge
+                            if (type === 'display') {
+                                if (data == 'success') {
+                                    data = '<span class="badge badge-success">' + jsText(data) + '</span>';
+                                } else if (data == 'waiting') {
+                                    data = '<span class="badge badge-info">' + jsText(data) + '</span>';
+                                } else {
+                                    data = '<span class="badge badge-warning">' + jsText(data) + '</span>';
+                                }
+                            }
+
+                            return data;
+                        }
+                    },
+                    { "data": "x12_partner_name" },
+                    {
+                        "data": "x12_filename",
+                        "render": function(data, type, row, meta) {
+                            // Build the URL so the user can download the claim batch file
+                            if (type === 'display') {
+                                const url = '<?php echo $GLOBALS['webroot']; ?>/interface/billing/get_claim_file.php?' +
+                                    'key=' + encodeURIComponent(data) +
+                                    '&csrf_token_form=' + <?php echo js_url(CsrfUtils::collectCsrfToken()); ?> +
+                                    '&partner=' + encodeURIComponent(row.x12_partner_id);
+                                data = '<a href="' + jsAttr(url) + '">' + jsText(data) + '</a>';
+                            }
+
+                            return data;
+                        }
+                    },
+                    { "data": "created_at" },
+                    { "data": "updated_at" },
+                ],
+                "order": [[4, 'asc']] // Order by 'Date Created' with newest first
+            });
+
+            oTable.on('preXhr.dt', function (e, settings, data) {
+                console.log("before ajax call");
+                top.restoreSession();
+            });
+
+            /* Formatting function for row details - modify as you need */
+            function format (d) {
+                // `d` is the original data object for the row
+                // First output any messages from the SFTP
+                let output = '';
+                if (d.messages !== null) {
+                    d.messages.forEach(message => {
+                        output += '<div class="alert alert-info">' + jsText(message) + '</div>';
+                    });
+                }
+
+                // Now output the claims in this batch
+                output += '<table class="table" cellpadding="5" cellspacing="0" border="0" style="padding-left:50px;">';
+                output +=
+                    '<thead>' +
+                        '<tr>' +
+                            '<th>' + jsText(<?php echo xlj('Patient ID'); ?>) + '</th>' +
+                            '<th>' + jsText(<?php echo xlj('Encounter ID'); ?>) + '</th>' +
+                            '<th>' + jsText(<?php echo xlj('Payor ID'); ?>) + '</th>' +
+                        '</tr>' +
+                    '</thead>';
+                output += '<tbody>';
+                d.claims.forEach(claim => {
+                    output +=
+                        '<tr>' +
+                            '<td>' + jsText(claim.pid) + '</td>' +
+                            '<td>' + jsText(claim.encounter) + '</td>' +
+                            '<td>' + jsText(claim.payor_id) + '</td>' +
+                        '</tr>';
+                });
+                output += '</tbody>';
+
+                return output;
+            }
+
+            // Add event listener for opening and closing details
+            $('#billing-tracker-table tbody').on('click', 'td.details-control', function () {
+                var tr = $(this).parents('tr');
+                var row = oTable.row( tr );
+
+                if ( row.child.isShown() ) {
+                    // This row is already open - close it
+                    row.child.hide();
+                    tr.removeClass('shown');
+                }
+                else {
+                    // Open this row
+                    row.child( format(row.data()) ).show();
+                    tr.addClass('shown');
+                }
+            } );
+        });
+    </script>
+</head>
+<body>
+    <div id="container_div" class="mt-3">
+         <div class="w-100 p-4">
+
+             <table id="billing-tracker-table">
+                 <thead>
+                 <tr>
+                     <th>&nbsp;</th>
+                     <th><?php echo xlt('Status') ?></th>
+                     <th><?php echo xlt('X-12 Partner') ?></th>
+                     <th><?php echo xlt('File') ?></th>
+                     <th><?php echo xlt('Date Created') ?></th>
+                     <th><?php echo xlt('Date Updated') ?></th>
+                 </tr>
+                 </thead>
+                 <tfoot>
+                 <tr>
+                     <th>&nbsp;</th>
+                     <th><?php echo xlt('Status') ?></th>
+                     <th><?php echo xlt('X-12 Partner') ?></th>
+                     <th><?php echo xlt('File') ?></th>
+                     <th><?php echo xlt('Date Created') ?></th>
+                     <th><?php echo xlt('Date Updated') ?></th>
+                 </tr>
+                 </tfoot>
+             </table>
+        </div>
+    </div>
+</body>
+</html>
Index: interface/billing/get_claim_file.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/billing/get_claim_file.php b/interface/billing/get_claim_file.php
--- a/interface/billing/get_claim_file.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/interface/billing/get_claim_file.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -20,19 +20,65 @@
 }
 
 $content_type = "text/plain";
-$claim_file_dir = $GLOBALS['OE_SITE_DIR'] . "/documents/edi/";
 
+// The key contains the filename
 $fname = $_GET['key'];
-$fname = preg_replace("[/]", "", $fname);
-$fname = preg_replace("[\.\.]", "", $fname);
-$fname = preg_replace("[\\\\]", "", $fname);
+
+// Because of the way the billing tables are constructed (as of 2021)
+// We may not know exactly where the file is, so we need to try a couple
+// different places. This is mainly because the full path is not stored
+// in the database. Also, the file could have been generated with the
+// 'gen_x12_based_on_ins_co' global set to 'on' but if it was turned off,
+// we still want to be able to download the file. So, we have to do a bit
+// of searching.
+// The edi directory is the default location.
+
+// the loc, if set, may tell us where the file is
+$location = $_GET['location'];
+$claim_file_found = false;
+if ($location === 'tmp') {
+    $claim_file_dir = rtrim($GLOBALS['temporary_files_dir'], DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
+    if (file_exists($claim_file_dir . $fname)) {
+        $claim_file_found = true;
+    }
+}
+
+// See if the file exists in the x-12 partner's SFTP directory
+// If it's not there, try the edi directory
+if (
+    false === $claim_file_found &&
+    isset($_GET['partner'])
+) {
+    $x12_partner_id = $_GET['partner'];
+    // First look in the database for the file so we know
+    // which partner directory to check
+    $sql = "SELECT `X`.`id`, `X`.`x12_sftp_local_dir`
+        FROM `x12_partners` `X`
+        WHERE `X`.`id` = ?
+        LIMIT 1";
+    $row = sqlQuery($sql, [$x12_partner_id]);
+    if ($row) {
+        $claim_file_dir = $row['x12_sftp_local_dir'];
+    }
+
+    if (file_exists($claim_file_dir . $fname)) {
+        $claim_file_found = true;
+    }
+}
+
+if ($claim_file_found === false) {
+    $claim_file_dir = $GLOBALS['OE_SITE_DIR'] . "/documents/edi/";
+    $fname = preg_replace("[/]", "", $fname);
+    $fname = preg_replace("[\.\.]", "", $fname);
+    $fname = preg_replace("[\\\\]", "", $fname);
+}
+
+$fname = $claim_file_dir . $fname;
 
 if (strtolower(substr($fname, (strlen($fname) - 4))) == ".pdf") {
     $content_type = "application/pdf";
 }
 
-$fname = $claim_file_dir . $fname;
-
 if (!file_exists($fname)) {
     echo xlt("The claim file: ") . text($_GET['key']) . xlt(" could not be accessed.");
 } else {
@@ -47,6 +93,16 @@
 
     // dump the picture and stop the script
     fpassthru($fp);
+
+    // If the caller sets the delete flag, delete the file when we're done serving it
+    // This is the common case of a temporary file when validation-only is performed
+    // by the BillingProcessor
+    if (
+        isset($_GET['delete']) &&
+        $_GET['delete'] == 1
+    ) {
+        unlink($fname);
+    }
 }
 
 exit;
Index: interface/billing/ub04_dispose.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/billing/ub04_dispose.php b/interface/billing/ub04_dispose.php
--- a/interface/billing/ub04_dispose.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/interface/billing/ub04_dispose.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -17,44 +17,46 @@
 use OpenEMR\Billing\X125010837I;
 use OpenEMR\Pdf\PdfCreator;
 
-$dispose = isset($_POST['handler']) ? $_POST['handler'] : $_GET['handler'];
-
-if ($dispose) {
-    if ($dispose == "edit_save") {
-        $ub04id = isset($_POST['ub04id']) ? $_POST['ub04id'] : $_GET['ub04id'];
-        $pid = isset($_POST['pid']) ? $_POST['pid'] : $_GET['pid'];
-        $encounter = isset($_POST['encounter']) ? $_POST['encounter'] : $_GET['encounter'];
-        $action = $_REQUEST['action'];
-        $ub04id = json_decode($ub04id, true);
-        saveTemplate($encounter, $pid, $ub04id, $action);
-        exit();
-    } elseif ($dispose == "payer_save") {
-        $ub04id = isset($_POST['ub04id']) ? $_POST['ub04id'] : $_GET['ub04id'];
-        $payerid = isset($_POST['payerid']) ? $_POST['payerid'] : $_GET['payerid'];
-        savePayerTemplate($payerid, $ub04id);
-        exit("done");
-    } elseif ($dispose == "batch_save") {
-        $pid = isset($_POST['pid']) ? $_POST['pid'] : $_GET['pid'];
-        $encounter = isset($_POST['encounter']) ? $_POST['encounter'] : $_GET['encounter'];
-        $ub04id = isset($_POST['ub04id']) ? $_POST['ub04id'] : $_GET['ub04id'];
-        saveTemplate($encounter, $pid, $ub04id, $dispose);
-        exit("done");
-    } elseif ($dispose == "reset_claim") {
-        $pid = isset($_POST['pid']) ? $_POST['pid'] : $_GET['pid'];
-        $encounter = isset($_POST['encounter']) ? $_POST['encounter'] : $_GET['encounter'];
-        // clear claim first otherwise get ub04 returns cuurent version.
-        //
-        $flg = exist_ub04_claim($pid, $encounter, true);
-        if ($flg === true) {
-            BillingUtilities::updateClaim(false, $pid, $encounter, - 1, - 1, - 1, - 1, '', 'ub04', - 1, 0, "");
-        }
-        $ub04id = get_ub04_array($pid, $encounter);
-        $ub04id = json_encode($ub04id);
+function ub04_dispose()
+{
+    $dispose = isset($_POST['handler']) ? $_POST['handler'] : $_GET['handler'];
+    if ($dispose) {
+        if ($dispose == "edit_save") {
+            $ub04id = isset($_POST['ub04id']) ? $_POST['ub04id'] : $_GET['ub04id'];
+            $pid = isset($_POST['pid']) ? $_POST['pid'] : $_GET['pid'];
+            $encounter = isset($_POST['encounter']) ? $_POST['encounter'] : $_GET['encounter'];
+            $action = $_REQUEST['action'];
+            $ub04id = json_decode($ub04id, true);
+            saveTemplate($encounter, $pid, $ub04id, $action);
+            exit();
+        } elseif ($dispose == "payer_save") {
+            $ub04id = isset($_POST['ub04id']) ? $_POST['ub04id'] : $_GET['ub04id'];
+            $payerid = isset($_POST['payerid']) ? $_POST['payerid'] : $_GET['payerid'];
+            savePayerTemplate($payerid, $ub04id);
+            exit("done");
+        } elseif ($dispose == "batch_save") {
+            $pid = isset($_POST['pid']) ? $_POST['pid'] : $_GET['pid'];
+            $encounter = isset($_POST['encounter']) ? $_POST['encounter'] : $_GET['encounter'];
+            $ub04id = isset($_POST['ub04id']) ? $_POST['ub04id'] : $_GET['ub04id'];
+            saveTemplate($encounter, $pid, $ub04id, $dispose);
+            exit("done");
+        } elseif ($dispose == "reset_claim") {
+            $pid = isset($_POST['pid']) ? $_POST['pid'] : $_GET['pid'];
+            $encounter = isset($_POST['encounter']) ? $_POST['encounter'] : $_GET['encounter'];
+            // clear claim first otherwise get ub04 returns cuurent version.
+            //
+            $flg = exist_ub04_claim($pid, $encounter, true);
+            if ($flg === true) {
+                BillingUtilities::updateClaim(false, $pid, $encounter, -1, -1, -1, -1, '', 'ub04', -1, 0, "");
+            }
+            $ub04id = get_ub04_array($pid, $encounter);
+            $ub04id = json_encode($ub04id);
 
-        echo $ub04id;
-        exit();
-    }
-    die(xlt('Do not know what to do!'));
+            echo $ub04id;
+            exit();
+        }
+        die(xlt('Do not know what to do!'));
+    }
 }
 
 function get_payer_defaults($payerid)
@@ -78,6 +80,7 @@
 
 function saveTemplate($encounter, $pid, $ub04id, $action = 'form')
 {
+    global $isAuthorized;
     if ($action != 'batch_save') {
         $ub04id = json_encode($ub04id);
         $isAuthorized = true;
@@ -97,6 +100,8 @@
 
 function buildTemplate(string $pid = null, string $encounter = null, $htmlin, string $action = null, &$log)
 {
+    global $srcdir, $isAuthorized;
+
     if (!$action) {
         $action = 'form';
     }
@@ -106,7 +111,7 @@
 
     $isAuthorized = true;
     ob_start();
-    require(dirname(__file__) . "/ub04_form.php");
+    require $srcdir . "/../interface/billing/ub04_form.php";
     $htmlin = ob_get_clean();
     $isAuthorized = false;
 
Index: interface/billing/ub04_form.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/billing/ub04_form.php b/interface/billing/ub04_form.php
--- a/interface/billing/ub04_form.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/interface/billing/ub04_form.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -12,9 +12,12 @@
  * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
  */
 
+require_once("./ub04_dispose.php");
+
 /* $isAuthorized tells us if the form is for user UI or claim processing and provides another security check */
+global $isAuthorized;
 if ($isAuthorized !== true) {
-    require_once("./ub04_dispose.php");
+    ub04_dispose();
     $isAuthorized = 0;
     $pid = $_REQUEST['pid'] ? $_REQUEST['pid'] : '0';
     $encounter = $_REQUEST['enc'] ? $_REQUEST['enc'] : '0';
@@ -29,7 +32,7 @@
         exit(xlt("Sorry! Not Authorized."));
     }
 } else {
-    $imgurl = "../../../../public/images";
+    $imgurl = $GLOBALS['webroot'] . "/public/images";
 }
 
 use OpenEMR\Core\Header;
@@ -359,7 +362,7 @@
     });
     ub04idSave = JSON.stringify(ub04id);
     var qstr = param({ handler: 'edit_save',pid:pid,encounter:encounter,action:action,ub04id:ub04idSave });
-    location.href='ub04_dispose.php?'+qstr;
+    location.href='ub04_submit.php?'+qstr;
 }
 
 function postClaim(action)
@@ -385,7 +388,7 @@
     var cj = JSON.stringify(c);
     ub04idSave = JSON.stringify(ub04id);
     var xhr = new XMLHttpRequest();
-    xhr.open('POST', 'ub04_dispose.php');
+    xhr.open('POST', 'ub04_submit.php');
     xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
     xhr.onload = function() {
         if (xhr.status === 200) {
@@ -434,7 +437,7 @@
     }
     $.ajax({
         type: 'GET',
-        url: 'ub04_dispose.php',
+        url: 'ub04_submit.php',
         data: {handler:'reset_claim',pid:pid,encounter:encounter},
         dataType: 'json',
         success: function( rtn ) {
Index: interface/billing/ub04_submit.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/billing/ub04_submit.php b/interface/billing/ub04_submit.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/interface/billing/ub04_submit.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,19 @@
+<?php
+
+/**
+ * UB04 Submit
+ *
+ * UThis is used as an endpoint URL by the UI to call into the ub04 functions
+ *
+ * @package OpenEMR
+ * @link    http://www.open-emr.org
+ * @author  Jerry Padgett <sjpadgett@gmail.com>
+ * @author  Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+require_once("../globals.php");
+require_once './ub04_dispose.php';
+
+ub04_dispose();
Index: interface/main/tabs/menu/menus/standard.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/main/tabs/menu/menus/standard.json b/interface/main/tabs/menu/menus/standard.json
--- a/interface/main/tabs/menu/menus/standard.json	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/interface/main/tabs/menu/menus/standard.json	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -501,6 +501,27 @@
           "eob"
         ],
         "global_req": "enable_edihistory_in_left_menu"
+      },
+      {
+        "label": "Claim File Tracker",
+        "menu_id": "biltrk0",
+        "target": "biltrk",
+        "url": "/interface/billing/billing_tracker.php",
+        "children": [],
+        "requirement": 0,
+        "acl_req": [
+            [
+                "acct",
+                "eob",
+                "write"
+            ],
+            [
+                "acct",
+                "bill",
+                "write"
+            ]
+        ],
+        "global_req": "auto_sftp_claims_to_x12_partner"
       }
     ],
     "requirement": 0,
Index: interface/super/edit_globals.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/interface/super/edit_globals.php b/interface/super/edit_globals.php
--- a/interface/super/edit_globals.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/interface/super/edit_globals.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -113,6 +113,14 @@
     $phimail_active = empty($GLOBALS['phimail_enable']) ? '0' : '1';
     $phimail_interval = max(0, (int) $GLOBALS['phimail_interval']);
     updateBackgroundService('phimail', $phimail_active, $phimail_interval);
+
+    // When auto SFTP is enabled in globals, set up background task to run every minute
+    // to check for claims in the 'waiting' status.
+    // See library/billing_sftp_service.php for the entry point to this service.
+    // It is very lightweight if there is no work to do, so running every minute should
+    // be OK to provider users with the best experience.
+    $auto_sftp_x12 = empty($GLOBALS['auto_sftp_claims_to_x12_partner']) ? '0' : '1';
+    updateBackgroundService('X12_SFTP', $auto_sftp_x12, 1);
 }
 ?>
 <!DOCTYPE html>
Index: library/ajax/billing_tracker_ajax.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/library/ajax/billing_tracker_ajax.php b/library/ajax/billing_tracker_ajax.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/library/ajax/billing_tracker_ajax.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,42 @@
+<?php
+
+/**
+ * Ajax endpoint for interface/billing/billing_tracker.php,
+ * which is the interface that provides tracking information for a claim batch
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+require_once __DIR__ . "/../../interface/globals.php";
+
+use OpenEMR\Billing\BillingProcessor\X12RemoteTracker;
+use OpenEMR\Common\Csrf\CsrfUtils;
+
+// verify csrf
+if (!CsrfUtils::verifyCsrfToken($_GET["csrf_token_form"])) {
+    CsrfUtils::csrfNotVerified();
+}
+
+$remoteTracker = new X12RemoteTracker();
+$claim_files = $remoteTracker->fetchAll();
+$response = new stdClass();
+$response->data = [];
+foreach ($claim_files as $claim_file) {
+    $element = new stdClass();
+    $element->x12_partner_id = text($claim_file['x12_partner_id']);
+    $element->x12_partner_name = text($claim_file['name']);
+    $element->x12_filename = text($claim_file['x12_filename']);
+    $element->status = xl($claim_file['status']);
+    $element->created_at = oeFormatDateTime($claim_file['created_at']);
+    $element->updated_at = oeFormatDateTime($claim_file['updated_at']);
+    $element->claims = json_decode($claim_file['claims']);
+    $element->messages = json_decode($claim_file['messages']);
+    $response->data[] = $element;
+}
+
+echo json_encode($response);
+exit();
Index: library/billing_sftp_service.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/library/billing_sftp_service.php b/library/billing_sftp_service.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/library/billing_sftp_service.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,27 @@
+<?php
+
+/**
+ * Executes the background service for billing, which sends EDI claims
+ * directly to the x-12 partner (if enabled)
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+use OpenEMR\Billing\BillingProcessor\X12RemoteTracker;
+
+/**
+ * This function is called by background services,
+ * reads the x12_remote_tracker table and sends
+ * files to x12 partners that are in the 'waiting'
+ * status.
+ */
+function start_X12_SFTP()
+{
+    if ($GLOBALS['auto_sftp_claims_to_x12_partner']) {
+        X12RemoteTracker::sftpSendWaitingFiles();
+    }
+}
Index: library/classes/X12Partner.class.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/library/classes/X12Partner.class.php b/library/classes/X12Partner.class.php
--- a/library/classes/X12Partner.class.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/library/classes/X12Partner.class.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -3,6 +3,13 @@
 /**
  * class X12Partner
  *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
  */
 
 use OpenEMR\Common\ORDataObject\ORDataObject;
@@ -12,6 +19,7 @@
 
     var $id;
     var $name;
+    var $x12_submitter_name; // Submitter name for TPA
     var $id_number;
     var $x12_isa01; //
     var $x12_isa02; //
@@ -31,6 +39,14 @@
     var $processing_format_array;
     var $x12_gs03; // Application Sender's Code. If this isn't set then we will use the $x12_receiver_id(ISA08).
 
+    //for submitting claims via sftp
+    var $x12_sftp_login;
+    var $x12_sftp_pass;
+    var $x12_sftp_host;
+    var $x12_sftp_port;
+    var $x12_sftp_local_dir;
+    var $x12_sftp_remote_dir;
+
     /**
      * Constructor sets all Insurance attributes to their default value
      */
@@ -85,6 +101,81 @@
         return $this->name;
     }
 
+    function get_x12_submitter_name()
+    {
+        return $this->x12_submitter_name;
+    }
+
+    function set_x12_submitter_name($string)
+    {
+        $this->x12_submitter_name = $string;
+    }
+
+    /**
+     * SFTP credentials for direct submit to x-12 partners.
+     *
+     * @param $string
+     */
+    function set_x12_sftp_login($string)
+    {
+        $this->x12_sftp_login = $string;
+    }
+
+    function get_x12_sftp_login()
+    {
+        return $this->x12_sftp_login;
+    }
+
+    function set_x12_sftp_pass($string)
+    {
+        $this->x12_sftp_pass = $string;
+    }
+
+    function get_x12_sftp_pass()
+    {
+        return $this->x12_sftp_pass;
+    }
+
+    function set_x12_sftp_host($string)
+    {
+        $this->x12_sftp_host = $string;
+    }
+
+    function get_x12_sftp_host()
+    {
+        return $this->x12_sftp_host;
+    }
+
+    function set_x12_sftp_port($string)
+    {
+        $this->x12_sftp_port = $string;
+    }
+
+    function get_x12_sftp_port()
+    {
+        return $this->x12_sftp_port;
+    }
+
+    function set_x12_sftp_local_dir($string)
+    {
+        $this->x12_sftp_local_dir = $string;
+    }
+
+    function get_x12_sftp_local_dir()
+    {
+        return $this->x12_sftp_local_dir;
+    }
+
+    function set_x12_sftp_remote_dir($string)
+    {
+        $this->x12_sftp_remote_dir = $string;
+    }
+
+    function get_x12_sftp_remote_dir()
+    {
+        return $this->x12_sftp_remote_dir;
+    }
+
     function set_name($string)
     {
             $this->name = $string;
Index: library/globals.inc.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/library/globals.inc.php b/library/globals.inc.php
--- a/library/globals.inc.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/library/globals.inc.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -1365,7 +1365,22 @@
             'bool',                           // data type
             '0',                              // default
             xl('Enable percent-based price levels')
-        )
+        ),
+
+        'gen_x12_based_on_ins_co' => array(
+            xl('Generate X-12 Based On Insurance Company'),
+            'bool',                           // data type
+            '0',                              // default = false
+            xl('For sending claims directly to insurance company, based on X12 Partner Settings')
+        ),
+
+        'auto_sftp_claims_to_x12_partner' => array(
+            xl('Automatically SFTP Claims To X12 Partner'),
+            'bool',                           // data type
+            '0',                              // default = false
+            xl('For automatically sending claims that are generated in EDI directory to the X12 partner using SFTP credentials X12 Partner Settings')
+        ),
+
     ),
 
     // E-Sign Tab
Index: sql/6_0_0-to-6_1_0_upgrade.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/sql/6_0_0-to-6_1_0_upgrade.sql b/sql/6_0_0-to-6_1_0_upgrade.sql
--- a/sql/6_0_0-to-6_1_0_upgrade.sql	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/sql/6_0_0-to-6_1_0_upgrade.sql	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -136,6 +136,56 @@
 ALTER TABLE `facility` ADD `weno_id` VARCHAR(10) DEFAULT NULL;
 #EndIf
 
+#IfMissingColumn x12_partners x12_gs03
+ALTER TABLE `x12_partners` ADD COLUMN `x12_gs03` varchar(15) DEFAULT NULL;
+#EndIf
+
+#IfMissingColumn x12_partners x12_submitter_name
+ALTER TABLE `x12_partners` ADD COLUMN `x12_submitter_name` varchar(255) DEFAULT NULL;
+#EndIf
+
+#IfMissingColumn x12_partners x12_sftp_login
+ALTER TABLE `x12_partners` ADD COLUMN `x12_sftp_login` varchar(255) DEFAULT NULL;
+#EndIf
+
+#IfMissingColumn x12_partners x12_sftp_pass
+ALTER TABLE `x12_partners` ADD COLUMN `x12_sftp_pass` varchar(255) DEFAULT NULL;
+#EndIf
+
+#IfMissingColumn x12_partners x12_sftp_host
+ALTER TABLE `x12_partners` ADD COLUMN `x12_sftp_host` varchar(255) DEFAULT NULL;
+#EndIf
+
+#IfMissingColumn x12_partners x12_sftp_port
+ALTER TABLE `x12_partners` ADD COLUMN `x12_sftp_port` varchar(15) DEFAULT NULL;
+#EndIf
+
+#IfMissingColumn x12_partners x12_sftp_local_dir
+ALTER TABLE `x12_partners` ADD COLUMN `x12_sftp_local_dir` varchar(255) DEFAULT NULL;
+#EndIf
+
+#IfMissingColumn x12_partners x12_sftp_remote_dir
+ALTER TABLE `x12_partners` ADD COLUMN `x12_sftp_remote_dir` varchar(255) DEFAULT NULL;
+#EndIf
+
+#IfNotRow background_services name X12_SFTP
+INSERT INTO `background_services` (`name`, `title`, `active`, `running`, `next_run`, `execute_interval`, `function`, `require_once`, `sort_order`) VALUES
+('X12_SFTP', 'SFTP Claims to X12 Partner Service', 0, 0, '2021-01-18 11:25:10', 1, 'start_X12_SFTP', '/library/billing_sftp_service.php', 100);
+#EndIf
+
+#IfNotTable x12_remote_tracker
+CREATE TABLE `x12_remote_tracker` (
+`id` bigint(20) NOT NULL AUTO_INCREMENT,
+`x12_partner_id` int(11) NOT NULL,
+`x12_filename` varchar(255) NOT NULL,
+`status` varchar(255) NOT NULL,
+`claims` text,
+`messages` text,
+`created_at` datetime DEFAULT NULL,
+`updated_at` datetime DEFAULT NULL,
+PRIMARY KEY (`id`)
+) ENGINE=InnoDB;
+
 #IfNotRow2D list_options list_id lists option_id Procedure_Billing
 INSERT INTO list_options (list_id,option_id,title, seq, is_default, option_value) VALUES ('lists','Procedure_Billing','Procedure Billing',0, 1, 0);
 INSERT INTO list_options (list_id,option_id,title,seq,is_default,activity) VALUES ('Procedure_Billing','T','Third-Party',10,1,1);
@@ -198,4 +248,3 @@
 #IfMissingColumn procedure_answers procedure_code
 ALTER TABLE `procedure_answers` ADD `procedure_code` VARCHAR(31) DEFAULT NULL;
 #EndIf
-
Index: sql/database.sql
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/sql/database.sql b/sql/database.sql
--- a/sql/database.sql	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/sql/database.sql	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -184,7 +184,8 @@
 ('phimail', 'phiMail Direct Messaging Service', 5, 'phimail_check', '/library/direct_message_check.inc', 100);
 INSERT INTO `background_services` (`name`, `title`, `active`, `running`, `next_run`, `execute_interval`, `function`, `require_once`, `sort_order`) VALUES
 ('MedEx', 'MedEx Messaging Service', 0, 0, '2017-05-09 17:39:10', 0, 'start_MedEx', '/library/MedEx/MedEx_background.php', 100);
-
+INSERT INTO `background_services` (`name`, `title`, `active`, `running`, `next_run`, `execute_interval`, `function`, `require_once`, `sort_order`) VALUES
+('X12_SFTP', 'SFTP Claims to X12 Partner Service', 0, 0, '2021-01-18 11:25:10', 1, 'start_X12_SFTP', '/library/billing_sftp_service.php', 100);
 -- --------------------------------------------------------
 
 --
@@ -8507,6 +8508,14 @@
   `x12_gs02`  varchar(15) NOT NULL DEFAULT '',
   `x12_per06` varchar(80) NOT NULL DEFAULT '',
   `x12_dtp03` char(1)     NOT NULL DEFAULT 'A',
+  `x12_gs03` varchar(15) DEFAULT NULL,
+  `x12_submitter_name` varchar(255) DEFAULT NULL,
+  `x12_sftp_login` varchar(255) DEFAULT NULL,
+  `x12_sftp_pass` varchar(255) DEFAULT NULL,
+  `x12_sftp_host` varchar(255) DEFAULT NULL,
+  `x12_sftp_port` varchar(255) DEFAULT NULL,
+  `x12_sftp_local_dir` varchar(255) DEFAULT NULL,
+  `x12_sftp_remote_dir` varchar(255) DEFAULT NULL,
   PRIMARY KEY  (`id`)
 ) ENGINE=InnoDB;
 
@@ -12309,3 +12318,16 @@
 KEY `accounts_id` (`user_id`),
 KEY `clients_id` (`client_id`)
 ) ENGINE=InnoDB;
+
+DROP TABLE IF EXISTS `x12_remote_tracker`;
+CREATE TABLE `x12_remote_tracker` (
+`id` bigint(20) NOT NULL AUTO_INCREMENT,
+`x12_partner_id` int(11) NOT NULL,
+`x12_filename` varchar(255) NOT NULL,
+`status` varchar(255) NOT NULL,
+`claims` text,
+`messages` text,
+`created_at` datetime DEFAULT NULL,
+`updated_at` datetime DEFAULT NULL,
+PRIMARY KEY (`id`)
+) ENGINE=InnoDB;
Index: src/Billing/BillingProcessor/BillingClaim.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/BillingClaim.php b/src/Billing/BillingProcessor/BillingClaim.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/BillingClaim.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,232 @@
+<?php
+
+/**
+ * This class represents an individual claim, as submit by the
+ * user through the Billing Manager and carries the claim's
+ * state through the processing process.
+ *
+ * If a developer needs to pass additional claim data for an individual
+ * claim to processing tasks, this is a place to add it.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+class BillingClaim implements \JsonSerializable
+{
+    const STATUS_LEAVE_UNCHANGED = -1;
+    const STATUS_LEAVE_UNBILLED = 1;
+    const STATUS_MARK_AS_BILLED = 2;
+
+    const BILL_PROCESS_LEAVE_UNCHANGED = -1;
+    const BILL_PROCESS_OPEN = 0;
+    const BILL_PROCESS_IN_PROGRESS = 1;
+    const BILL_PROCESS_BILLED = 2;
+
+    /**
+     * NOT the database id in billing table,
+     * but representation of claim using the format
+     * pid-encounter
+     *
+     * @var
+     */
+    protected $id;
+
+    /**
+     * Encounter ID
+     * @var mixed|string
+     */
+    protected $encounter;
+
+    /**
+     * Patient's pid
+     *
+     * @var mixed|string
+     */
+    protected $pid;
+
+    /**
+     * x-12 partner ID
+     *
+     * @var
+     */
+    protected $partner;
+
+    /**
+     * Insurance company ID
+     * @var false|string
+     */
+    protected $payor_id;
+
+    /**
+     * Primary, Secondary or Tertiary insurance
+     *
+     * @var
+     */
+    protected $payor_type;
+
+    /**
+     * Options for $payor_type
+     */
+    const PRIMARY = 1;
+    const SECONDARY = 2;
+    const TERTIARY = 3;
+    const UNKNOWN = 0;
+
+    /**
+     * Indicator for which processing format was selected for x-12
+     * partner. Doesn't appear to have any affect on output format
+     * other than to indicate what was selected and store with the claim
+     * in billing table.
+     *
+     * @var mixed|string
+     */
+    protected $target;
+
+    /**
+     * If this is the last claim in the processing queue, the this
+     * is true otherwise it's false. It is set by the BillingProcessor
+     * object while preparing claims.
+     *
+     * @bool
+     */
+    protected $is_last;
+
+    public function __construct($claimId, $partner_and_payor)
+    {
+        // Assume this is not the last claim in the "loop" unless explicitly set.
+        $this->is_last = false;
+
+        // The encounter and PID are in the claimId separated by '-' so parse them out
+        $ta = explode("-", $claimId);
+        $this->id = $claimId;
+        $this->pid = $ta[0];
+        $this->encounter = $ta[1];
+
+        $this->partner = $partner_and_payor['partner'];
+
+        // The payor ID is in the 'payer' part, the first character is the payer type
+        $this->payor_id = substr($partner_and_payor['payer'], 1);
+
+        // The payor type comes in on the payor ID part as a single character prefix
+        $payor_type_char = substr(strtoupper($partner_and_payor['payer']), 0, 1);
+        if ($payor_type_char == 'P') {
+            $this->payor_type = self::PRIMARY;
+        } elseif ($payor_type_char == 'S') {
+            $this->payor_type = self::SECONDARY;
+        } elseif ($payor_type_char == 'T') {
+            $this->payor_type = self::TERTIARY;
+        } else {
+            $this->payor_type = self::UNKNOWN;
+        }
+
+        // Fetch the "target" which is essentially just an indicator for which x-12 partner was used
+        $sql = "SELECT x.processing_format from x12_partners as x where x.id =?";
+        $result = sqlQuery($sql, [$this->getPartner()]);
+        $target = "x12";
+        if (!empty($result['processing_format'])) {
+            $target = $result['processing_format'];
+        }
+        $this->target = $target;
+    }
+
+    /**
+     * @return mixed
+     */
+    public function getId()
+    {
+        return $this->id;
+    }
+
+    /**
+     * @param mixed $id
+     */
+    public function setId($id): void
+    {
+        $this->id = $id;
+    }
+
+    /**
+     * @return mixed|string
+     */
+    public function getEncounter(): string
+    {
+        return $this->encounter;
+    }
+
+    /**
+     * @return mixed|string
+     */
+    public function getPid(): string
+    {
+        return $this->pid;
+    }
+
+    /**
+     * @return mixed
+     */
+    public function getPartner()
+    {
+        return $this->partner;
+    }
+
+    /**
+     * @return false|string
+     */
+    public function getPayorId()
+    {
+        return $this->payor_id;
+    }
+
+    /**
+     * @return mixed
+     */
+    public function getPayorType()
+    {
+        return $this->payor_type;
+    }
+
+    /**
+     * @return mixed|string
+     */
+    public function getTarget(): string
+    {
+        return $this->target;
+    }
+
+    /**
+     * @param mixed|string $target
+     */
+    public function setTarget(string $target): void
+    {
+        $this->target = $target;
+    }
+
+
+    /**
+     * @return mixed
+     */
+    public function getIsLast()
+    {
+        return $this->is_last;
+    }
+
+    /**
+     * @param mixed $is_last
+     */
+    public function setIsLast($is_last): void
+    {
+        $this->is_last = $is_last;
+    }
+
+    public function jsonSerialize()
+    {
+        $vars = get_object_vars($this);
+        return $vars;
+    }
+}
Index: src/Billing/BillingProcessor/BillingClaimBatch.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/BillingClaimBatch.php b/src/Billing/BillingProcessor/BillingClaimBatch.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/BillingClaimBatch.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,257 @@
+<?php
+
+/**
+ * This class represents a claim batch file that may have
+ * many claims written to it.
+ *
+ * Though many of the functions are specific to x-12 format,
+ * this class also handles the PDF
+ *
+ * It's job is to manage the state of the filename, location and
+ * writing the file to disk. In the case of X-12 it also manages
+ * the claim separators and the trailing indicators.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+class BillingClaimBatch
+{
+    protected $bat_type = ''; // will be edi or hcfa
+    protected $bat_sendid = '';
+    protected $bat_recvid = '';
+    protected $bat_content = '';
+    protected $bat_gscount = 0;
+    protected $bat_stcount = 0;
+    protected $bat_time;
+    protected $bat_hhmm;
+    protected $bat_yymmdd;
+    protected $bat_yyyymmdd;
+    // Seconds since 1/1/1970 00:00:00 GMT will be our interchange control number
+    // but since limited to 9 char must be without leading 1
+    protected $bat_icn;
+    protected $bat_filename;
+    protected $bat_filedir;
+
+    /**
+     * Array of claims contained in this batch
+     *
+     * @var array
+     */
+    protected $claims = [];
+
+    public function __construct($ext = '.txt')
+    {
+        $this->bat_type = ''; // will be edi or hcfa
+        $this->bat_sendid = '';
+        $this->bat_recvid = '';
+        $this->bat_content = '';
+        $this->bat_gscount = 0;
+        $this->bat_stcount = 0;
+        $this->bat_time = time();
+        $this->bat_hhmm = date('Hi', $this->bat_time);
+        $this->bat_yymmdd = date('ymd', $this->bat_time);
+        $this->bat_yyyymmdd = date('Ymd', $this->bat_time);
+        // Seconds since 1/1/1970 00:00:00 GMT will be our interchange control number
+        // but since limited to 9 char must be without leading 1
+        $this->bat_icn = substr((string)$this->bat_time, 1, 9);
+        $this->bat_filename = date("Y-m-d-His", $this->bat_time) . "-batch" . $ext;
+        $this->bat_filedir = $GLOBALS['OE_SITE_DIR'] . DIRECTORY_SEPARATOR . "documents" . DIRECTORY_SEPARATOR . "edi";
+    }
+
+    /**
+     * @return array
+     */
+    public function getClaims(): array
+    {
+        return $this->claims;
+    }
+
+    /**
+     * @param array $claims
+     */
+    public function setClaims(array $claims): void
+    {
+        $this->claims = $claims;
+    }
+
+    /**
+     * @param array $claims
+     */
+    public function addClaim($claim): void
+    {
+        $this->claims[] = $claim;
+    }
+
+    /**
+     * @return string
+     */
+    public function getBatContent(): string
+    {
+        return $this->bat_content;
+    }
+
+    /**
+     * @return string
+     */
+    public function getBatFiledir(): string
+    {
+        return $this->bat_filedir;
+    }
+
+    /**
+     * @param string $bat_filedir
+     */
+    public function setBatFiledir(string $bat_filedir): void
+    {
+        $this->bat_filedir = $bat_filedir;
+    }
+
+    /**
+     * @return string
+     */
+    public function getBatFilename(): string
+    {
+        return $this->bat_filename;
+    }
+
+    /**
+     * @param string $bat_filename
+     */
+    public function setBatFilename(string $bat_filename): void
+    {
+        $this->bat_filename = $bat_filename;
+    }
+
+    /**
+     * Write the batch file to disk, and if enabled, queue the file
+     * to be written to remote SFTP server.
+     *
+     * In the case of the "normal" generate x12 (not per-insco) we
+     * only generate one batch file, so we need to send it to all
+     * of the x-12 partners that were found during billing process.
+     * This will usually only ever have one element, but just in case
+     * There are more than one x-12 partner configured and input through
+     * billing manger, we handle the array case.
+     *
+     */
+    public function write_batch_file()
+    {
+        $success = true;
+        // If a writable edi directory exists, log the batch to it.
+        // I guarantee you'll be glad we did this. :-)
+        if ($this->bat_filedir !== false) {
+            $fh = fopen($this->bat_filedir . DIRECTORY_SEPARATOR . $this->bat_filename, 'a');
+            if ($fh) {
+                fwrite($fh, $this->bat_content);
+                fclose($fh);
+            } else {
+                $success = false;
+            }
+        }
+
+        // If we are automatically uploading claims to X12 partners, do that here right after we
+        // write the 'official' batch file
+        if (
+            true === $success &&
+            $GLOBALS['auto_sftp_claims_to_x12_partner']
+        ) {
+            $unique_x12_partners = $this->extractUniqueX12PartnersFromClaims($this->claims);
+            if (is_array($unique_x12_partners)) {
+                // If this is an array, queue the batchfile to send to all x-12 partners
+                foreach ($unique_x12_partners as $x12_partner_id) {
+                    X12RemoteTracker::create([
+                        'x12_partner_id' => $x12_partner_id,
+                        'x12_filename' => $this->bat_filename,
+                        'status' => X12RemoteTracker::STATUS_WAITING,
+                        'claims' => json_encode($this->claims)
+                    ]);
+                }
+            }
+        }
+
+        return $success;
+    }
+
+    protected function extractUniqueX12PartnersFromClaims($claims)
+    {
+        $unique_x12_partners = [];
+        foreach ($claims as $claim) {
+            if (!in_array($claim->getPartner(), $unique_x12_partners)) {
+                $unique_x12_partners[] = $claim->getPartner();
+            }
+        }
+        return $unique_x12_partners;
+    }
+
+    public function append_claim(&$segs)
+    {
+        foreach ($segs as $seg) {
+            if (!$seg) {
+                continue;
+            }
+            $elems = explode('*', $seg);
+            if ($elems[0] == 'ISA') {
+                if (!$this->bat_content) {
+                    $bat_sendid = trim($elems[6]);
+                    $bat_recvid = trim($elems[8]);
+                    $bat_sender = (!empty($GS02)) ? $GS02 : $bat_sendid;
+                    $this->bat_content = substr($seg, 0, 70) . "$this->bat_yymmdd*$this->bat_hhmm*" . $elems[11] . "*" . $elems[12] . "*$this->bat_icn*" . $elems[14] . "*" . $elems[15] . "*:~";
+                }
+                continue;
+            } elseif (!$this->bat_content) {
+                die("Error:<br />\nInput must begin with 'ISA'; " . "found '" . text($elems[0]) . "' instead");
+            }
+            if ($elems[0] == 'GS') {
+                if ($this->bat_gscount == 0) {
+                    ++$this->bat_gscount;
+                    $this->bat_content .= "GS*HC*" . $elems[2] . "*" . $elems[3] . "*$this->bat_yyyymmdd*$this->bat_hhmm*1*X*" . $elems[8] . "~";
+                }
+                continue;
+            }
+            if ($elems[0] == 'ST') {
+                ++$this->bat_stcount;
+                $bat_st_02 = sprintf("%04d", $this->bat_stcount);
+                $this->bat_content .= "ST*837*" . $bat_st_02;
+                if (!empty($elems[3])) {
+                    $this->bat_content .= "*" . $elems[3];
+                }
+
+                $this->bat_content .= "~";
+                continue;
+            }
+
+            if ($elems[0] == 'BHT') {
+                // needle is set in OpenEMR\Billing\X125010837P
+                $this->bat_content .= substr_replace($seg, '*' . $this->bat_icn . $bat_st_02 . '*', strpos($seg, '*0123*'), 6);
+                $this->bat_content .= "~";
+                continue;
+            }
+
+            if ($elems[0] == 'SE') {
+                $this->bat_content .= sprintf("SE*%d*%04d~", $elems[1], $this->bat_stcount);
+                continue;
+            }
+
+            if ($elems[0] == 'GE' || $elems[0] == 'IEA') {
+                continue;
+            }
+
+            $this->bat_content .= $seg . '~';
+        }
+    }
+
+    public function append_claim_close()
+    {
+        if ($this->bat_gscount) {
+            $this->bat_content .= "GE*$this->bat_stcount*1~";
+        }
+
+        $this->bat_content .= "IEA*$this->bat_gscount*$this->bat_icn~";
+    }
+}
Index: src/Billing/BillingProcessor/BillingLogger.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/BillingLogger.php b/src/Billing/BillingProcessor/BillingLogger.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/BillingLogger.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,119 @@
+<?php
+
+/**
+ * These are logging functions that were extracted from the original
+ * billing_process.php function and placed here.
+ *
+ * Each Processing Task that writes to the log can 'use' the trait
+ * WritesToBillingLog which helps the task implement the LoggerInterface.
+ *
+ * That trait will keep a reference of this object, which is passed all
+ * throughout the billing process, so everything writes to the same log.
+ *
+ * At the end of the billing process, the BillingLogger instance is
+ * returned to billing_process.php to write any log messages to the screen.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Brady Miller <brady.g.miller@gmail.com>
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Daniel Pflieger <daniel@growlingflea.com>
+ * @author    Terry Hill <terry@lilysystems.com>
+ * @author    Jerry Padgett <sjpadgett@gmail.com>
+ * @author    Stephen Waite <stephen.waite@cmsvt.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Daniel Pflieger <daniel@growlingflea.com>
+ * @copyright Copyright (c) 2014-2020 Brady Miller <brady.g.miller@gmail.com>
+ * @copyright Copyright (c) 2016 Terry Hill <terry@lillysystems.com>
+ * @copyright Copyright (c) 2017-2020 Jerry Padgett <sjpadgett@gmail.com>
+ * @copyright Copyright (c) 2018-2020 Stephen Waite <stephen.waite@cmsvt.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+use OpenEMR\Common\Crypto\CryptoGen;
+
+class BillingLogger
+{
+    /**
+     * Contains an array of status messages that accumulate
+     * through the billing process
+     *
+     * @var array
+     */
+    protected $bill_info = [];
+
+    /**
+     * Contains a string that represents the results from formatting
+     * x-12 claims. This is what you see when you click the 'Logs' button
+     * on the result modal.
+     *
+     * @var false|string
+     */
+    protected $hlog;
+
+    /**
+     * Callback function that is executed after the billing_process.php page
+     * has rendered.
+     *
+     * @var callable
+     */
+    protected $onLogCompleteCallback;
+
+    public function __construct()
+    {
+        if ($GLOBALS['billing_log_option'] == 1) {
+            // Set up crypto object
+            $cryptoGen = new CryptoGen();
+
+            if (file_exists($GLOBALS['OE_SITE_DIR'] . "/documents/edi/process_bills.log")) {
+                $this->hlog = file_get_contents($GLOBALS['OE_SITE_DIR'] . "/documents/edi/process_bills.log");
+            }
+            if ($cryptoGen->cryptCheckStandard($this->hlog)) {
+                $this->hlog = $cryptoGen->decryptStandard($this->hlog, null, 'database');
+            }
+        } else { // ($GLOBALS['billing_log_option'] == 2)
+            $this->hlog = '';
+        }
+    }
+
+    public function setLogCompleteCallback(callable $onLogCompleteCallback)
+    {
+        $this->onLogCompleteCallback = $onLogCompleteCallback;
+    }
+
+    /**
+     * Called when log is done writing
+     *
+     * @return false|mixed
+     */
+    public function onLogComplete()
+    {
+        if (isset($this->onLogCompleteCallback)) {
+            call_user_func($this->onLogCompleteCallback);
+        }
+
+        return false;
+    }
+
+    public function printToScreen($message)
+    {
+        $this->bill_info[] = $message;
+    }
+
+    public function bill_info()
+    {
+        return $this->bill_info;
+    }
+
+    public function appendToLog($message)
+    {
+        $this->hlog .= $message;
+    }
+
+    public function hlog()
+    {
+        return $this->hlog;
+    }
+}
Index: src/Billing/BillingProcessor/BillingProcessor.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/BillingProcessor.php b/src/Billing/BillingProcessor/BillingProcessor.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/BillingProcessor.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,197 @@
+<?php
+
+/**
+ * This class is the billing processor.
+ *
+ * The billing processor takes the input from the UI's Billing Manager
+ * screen, and converts the user input into an executable task object. That happens
+ * in the buildProcessingTaskFromPost() method. The object that is returned is
+ * an instance of ProcessingTaskInterface which is responsible for processing
+ * all of the claims in the group of claims sent from the UI.
+ *
+ * There are many classes that implement this interface for different types of
+ * processing and formatting of the submitted claims. For example TaskReopen simply
+ * re-opens all of the claims, where GeneratorX12 creates multiple claim batch files.
+ *
+ * Each ProcessingTaskInterface implementation has three methods.
+ *  - setup($context) called before claim loop to do any setup of the processing task
+ *  - execute(BatchClaim $claim) called on each claim, where the task can add to a batch file, or whatever
+ *  - complete($context) called after the claim loop to generate any output, or clean up
+ *
+ * This file is a refacoting of the original billing_process.php file which was
+ * becoming increasingly cluttered and ridden with logic errors because of the complexity
+ * of the looping and branching. This pattern allows each processing task to own it's
+ * class and not be mixed with others.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Brady Miller <brady.g.miller@gmail.com>
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Daniel Pflieger <daniel@growlingflea.com>
+ * @author    Terry Hill <terry@lilysystems.com>
+ * @author    Jerry Padgett <sjpadgett@gmail.com>
+ * @author    Stephen Waite <stephen.waite@cmsvt.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Daniel Pflieger <daniel@growlingflea.com>
+ * @copyright Copyright (c) 2014-2020 Brady Miller <brady.g.miller@gmail.com>
+ * @copyright Copyright (c) 2016 Terry Hill <terry@lillysystems.com>
+ * @copyright Copyright (c) 2017-2020 Jerry Padgett <sjpadgett@gmail.com>
+ * @copyright Copyright (c) 2018-2020 Stephen Waite <stephen.waite@cmsvt.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+use OpenEMR\Billing\BillingProcessor\Tasks;
+
+class BillingProcessor
+{
+    /**
+     * Post from the billing manager form
+     * @var
+     */
+    protected $post;
+
+    /**
+     * The following constants are the options for processing tasks, which are the actions
+     * applied to the checked claims on the billing manager screen
+     */
+    const VALIDATE_ONLY = 'validate-only';
+    const VALIDATE_AND_CLEAR = 'validate-and-clear';
+    const NORMAL = 'normal';
+
+    public function __construct($post)
+    {
+        $this->post = $post;
+    }
+
+    /**
+     * This is the entry-point of claim-processing called in billing_process.php
+     */
+    public function execute()
+    {
+        // Use the user's input parameters to build the appropriate processing task
+        $processing_task = $this->buildProcessingTaskFromPost($this->post);
+
+        // Based on UI form input, get the claims we actually need to bill
+        $claims = $this->prepareClaims();
+
+        // What task are we running, as directed by the user. Process the claims using
+        // each Processing Task's execute method
+        $this->processClaims($processing_task, $claims);
+
+        // Return our logger instance so any non-claim-specific data
+        // can be written to the screen like notification, alerts, status, etc.
+        return $processing_task->getLogger();
+    }
+
+    protected function prepareClaims()
+    {
+        $claims = [];
+        // Build the claims we actually want to process from the post
+        // The form pots all claims whether they were selected or not, and we
+        // just want the claims that were selected by the user, which have 'bill'
+        // index set on their array
+        foreach ($this->post['claims'] as $claimId => $partner_and_payor) {
+            if (isset($partner_and_payor['bill'])) {
+                // The format coming in from POST is like this:
+                // [ encounter-pid => [ 'partner' => partnerId, 'payor' => 'p'.payorId ], ... ]
+                // Since the format is cryptic, we use the BillingClaim constructor to parse that into meaningful
+                // attributes
+                $billingClaim = new BillingClaim($claimId, $partner_and_payor);
+                $claims[] = $billingClaim;
+            }
+        }
+
+        return $claims;
+    }
+
+    protected function processClaims(ProcessingTaskInterface $processingTask, array $claims)
+    {
+        // Call setup on our processing task. If the task is a file-generator,
+        // this calls setup on the generator (to set up batch file, etc)
+        $processingTask->setup([
+            'claims' => $claims,
+            'post' => $this->post
+        ]);
+
+        // Go through each claim and process it while organizing them into batches
+        foreach ($claims as $claim) {
+            // Call the execute method on the task we created below based on user input
+            // If the task is generating a file, one of the Generator* file's execute methods is called
+            $processingTask->execute($claim);
+        }
+
+        // Call the task's complete method so it can produce it's output
+        // and do any clean-up
+        $processingTask->complete([
+            'claims' => $claims,
+            'post' => $this->post
+        ]);
+    }
+
+    protected function buildProcessingTaskFromPost($post)
+    {
+        // Depending on which type of process we are running, create the appropriate
+        // processing task object to process the claims and produce output (if any).
+        // Determine which processing task the user wants us to run based on the input
+        // on the billing manager form. In the case of the Generator tasks that create
+        // an output file, if the user selects validate only, we don't do
+        // any writing or create a batch to send, we just perform validation
+        // Normal operation will submit generate the files and submit
+        $processing_task = null;
+        if (isset($post['bn_reopen'])) {
+            $processing_task = new Tasks\TaskReopen();
+        } else if (isset($post['bn_external'])) {
+            $processing_task = new Tasks\TaskMarkAsClear();
+        } else if ($GLOBALS['gen_x12_based_on_ins_co'] && isset($post['bn_x12'])) {
+            $processing_task = new Tasks\GeneratorX12Direct($this->extractAction());
+        } else if ($GLOBALS['gen_x12_based_on_ins_co'] && isset($post['bn_x12_encounter'])) {
+            $processing_task = new Tasks\GeneratorX12Direct($this->extractAction(), true);
+        } else if (isset($post['bn_x12'])) {
+            $processing_task = new Tasks\GeneratorX12($this->extractAction());
+        } else if (isset($post['bn_x12_encounter'])) {
+            $processing_task = new Tasks\GeneratorX12($this->extractAction(), true);
+        } else if (isset($post['bn_process_hcfa'])) {
+            $processing_task = new Tasks\GeneratorHCFA_PDF($this->extractAction());
+        } else if (isset($post['bn_process_hcfa_form'])) {
+            $processing_task = new Tasks\GeneratorHCFA_PDF_IMG($this->extractAction());
+        } else if (isset($post['bn_ub04_x12'])) {
+            $processing_task = new Tasks\GeneratorUB04X12($this->extractAction());
+        } else if (isset($post['bn_process_ub04_form'])) {
+            $processing_task = new Tasks\GeneratorUB04Form_PDF($this->extractAction());
+        } else if (isset($post['bn_external'])) {
+            $processing_task = new Tasks\GeneratorExternal($this->extractAction());
+        }
+
+        // If the processing task can write to the billing log, let's set it's log
+        // instance. The default implementation of the LoggerInterface and the way
+        // this is usually implemented on tasks is the trait Traits\WritesToBillingLog
+        if ($processing_task instanceof LoggerInterface) {
+            $logger = new BillingLogger();
+            $processing_task->setLogger($logger);
+        }
+
+        return $processing_task;
+    }
+
+    /**
+     * Get the 'action' the user wants us to run based on UI input passed
+     * to us in the POST array
+     *
+     * @return string|null
+     */
+    protected function extractAction()
+    {
+        $action = null;
+        if (isset($this->post['btn-clear'])) {
+            $action = self::VALIDATE_AND_CLEAR;
+        } else if (isset($this->post['btn-validate'])) {
+            $action = self::VALIDATE_ONLY;
+        } else if (isset($this->post['btn-continue'])) {
+            $action = self::NORMAL;
+        }
+
+        return $action;
+    }
+}
Index: src/Billing/BillingProcessor/GeneratorCanValidateInterface.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/GeneratorCanValidateInterface.php b/src/Billing/BillingProcessor/GeneratorCanValidateInterface.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/GeneratorCanValidateInterface.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,23 @@
+<?php
+
+/**
+ * Interface that a generator can implement if it can respond to the
+ * user input selected actions of "validate only" and "validate and clear"
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+interface GeneratorCanValidateInterface
+{
+    public function validateOnly(BillingClaim $claim);
+
+    public function validateAndClear(BillingClaim $claim);
+
+    public function completeToScreen(array $context);
+}
Index: src/Billing/BillingProcessor/GeneratorInterface.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/GeneratorInterface.php b/src/Billing/BillingProcessor/GeneratorInterface.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/GeneratorInterface.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,25 @@
+<?php
+
+/**
+ * Interface that all processing tasks "that generate output files"
+ * should implement. This is an extension of the processing task interface.
+ *
+ * The additional methods relate to generation of the file.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+interface GeneratorInterface extends ProcessingTaskInterface
+{
+    public function setAction($action);
+
+    public function generate(BillingClaim $claim);
+
+    public function completeToFile(array $context);
+}
Index: src/Billing/BillingProcessor/LoggerInterface.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/LoggerInterface.php b/src/Billing/BillingProcessor/LoggerInterface.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/LoggerInterface.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,26 @@
+<?php
+
+/**
+ * Interface that allows processing tasks to write to billing log.
+ *
+ * The default implementation is in the trait Trait\WritesToBillingLog
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+interface LoggerInterface
+{
+    public function getLogger();
+
+    public function setLogger(BillingLogger $logger);
+
+    public function printToScreen($message);
+
+    public function appendToLog($message);
+}
Index: src/Billing/BillingProcessor/ProcessingTaskInterface.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/ProcessingTaskInterface.php b/src/Billing/BillingProcessor/ProcessingTaskInterface.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/ProcessingTaskInterface.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,22 @@
+<?php
+
+/**
+ * Interface that all processing tasks must implement
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+interface ProcessingTaskInterface
+{
+    public function setup(array $context);
+
+    public function execute(BillingClaim $claim);
+
+    public function complete(array $context);
+}
Index: src/Billing/BillingProcessor/Tasks/AbstractGenerator.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/AbstractGenerator.php b/src/Billing/BillingProcessor/Tasks/AbstractGenerator.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/AbstractGenerator.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,134 @@
+<?php
+
+/**
+ * This class represents the abstract implementation of GeneratorInterface
+ *
+ * The class implements the execute() method of the ProcessingTaskInterface
+ * and further breaks down the task depending on the action that is being
+ * run by the user.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\BillingProcessor;
+use OpenEMR\Billing\BillingProcessor\GeneratorCanValidateInterface;
+use OpenEMR\Common\Csrf\CsrfUtils;
+
+abstract class AbstractGenerator extends AbstractProcessingTask
+{
+    protected $action = null;
+
+    public function __construct($action)
+    {
+        $this->action = $action;
+    }
+
+    /**
+     * @return mixed
+     */
+    public function getAction()
+    {
+        return $this->action;
+    }
+
+    /**
+     * @param mixed $action
+     */
+    public function setAction($action): void
+    {
+        $this->action = $action;
+    }
+
+    /**
+     * This abstract class for generators implements the execute method
+     * so we can further hone exactly which operation we want to run.
+     *
+     * This helps reduce conditional statements in the generator classes
+     * by checking the action here and calling the appropriate method.
+     *
+     * If needed the individual generator can override this method and
+     * take control of the entire execute() process.
+     *
+     * If the generator doesn't implement validation, and there's
+     * no action specified, just run generate()
+     *
+     * @param BillingClaim $claim
+     */
+    public function execute(BillingClaim $claim)
+    {
+        if ($this instanceof GeneratorCanValidateInterface) {
+            if ($this->getAction() === BillingProcessor::VALIDATE_ONLY) {
+                $this->validateOnly($claim);
+            } else if ($this->getAction() === BillingProcessor::VALIDATE_AND_CLEAR) {
+                $this->validateAndClear($claim);
+            }
+        }
+
+        if (
+            $this->getAction() === BillingProcessor::NORMAL ||
+            $this->getAction() === null
+        ) {
+            $this->generate($claim);
+        }
+    }
+
+    /**
+     * This AbstractGenerator captures the complete method so we
+     * can filter by action and call the appropriate method
+     * on the child generator.
+     *
+     * If we are validating, just print to screen for the user,
+     * but if we are running 'normal' action, we'll complete to
+     * file and write our batch file to EDI directory(ies).
+     *
+     * If the generator doesn't implement validation, and there's
+     * no action specified, just run completeToFile()
+     *
+     * @param array $context
+     */
+    public function complete(array $context)
+    {
+        if ($this instanceof GeneratorCanValidateInterface) {
+            if (
+                $this->getAction() === BillingProcessor::VALIDATE_ONLY ||
+                $this->getAction() === BillingProcessor::VALIDATE_AND_CLEAR
+            ) {
+                $this->completeToScreen($context);
+            }
+        }
+
+        if (
+            $this->getAction() === BillingProcessor::NORMAL ||
+            $this->getAction() === null
+        ) {
+            $this->completeToFile($context);
+        }
+    }
+
+    /**
+     * This is a helper function for generators that produce a file
+     * as output, and need to initiate a file download for the
+     * user. This prints javascript that will call the get_claim_file.php
+     * endpoint and initiate the download.
+     *
+     * @param $filename
+     * @param $location
+     * @param false $delete
+     */
+    public function printDownloadClaimFileJS($filename, $location = '', $delete = false)
+    {
+        $url = $GLOBALS['webroot'] . '/interface/billing/get_claim_file.php?' .
+            'key=' . urlencode($filename) .
+            '&location=' . urlencode($location) .
+            '&delete=' . urlencode($delete) .
+            '&csrf_token_form=' . urlencode(CsrfUtils::collectCsrfToken());
+        echo "<script type='text/JavaScript'>window.location = " . js_escape($url) . "</script>";
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/AbstractProcessingTask.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/AbstractProcessingTask.php b/src/Billing/BillingProcessor/Tasks/AbstractProcessingTask.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/AbstractProcessingTask.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,38 @@
+<?php
+
+/**
+ * This class represents the abstract implementation of ProcessingTaskInterface
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+
+abstract class AbstractProcessingTask
+{
+    /**
+     * Mark claim as 'billed' available to all children of
+     * AbstractProcessingTask
+     *
+     * @param BillingClaim $claim
+     * @return mixed
+     */
+    public function clearClaim(BillingClaim $claim)
+    {
+        $tmp = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            2
+        ); // $sql .= " billed = 1, ";
+        return $tmp;
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorExternal.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorExternal.php b/src/Billing/BillingProcessor/Tasks/GeneratorExternal.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorExternal.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,50 @@
+<?php
+
+/**
+ * This class represents the task that will write claims to an external
+ * CSV file
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+
+class GeneratorExternal extends AbstractGenerator implements GeneratorInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    protected $be;
+
+    public function setup($context = null)
+    {
+        global $webserver_root;
+        $EXPORT_INC = "$webserver_root/custom/BillingExport.php";
+        if (file_exists($EXPORT_INC)) {
+            include_once($EXPORT_INC);
+            $BILLING_EXPORT = true;
+        }
+        $this->be = new \BillingExport();
+    }
+
+    public function generate(BillingClaim $claim)
+    {
+        // Writes this claim row to the csv file on disk
+        $this->be->addClaim($claim->getPid(), $claim->getEncounter());
+        return $this->clearClaim($claim);
+    }
+
+    public function completeToFile($context = null)
+    {
+        // Close external billing file.
+        $this->be->close();
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF.php b/src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,220 @@
+<?php
+
+/**
+ * This class represents the task that compiles claims into
+ * a HCFA form batch. This prints the claim data only, with no
+ * form fields (no background image) that are present on the HCFA 1500 paper form.
+ *
+ * The *other* HCFA generator will print the data over an image of
+ * the paper form fields if enabled in globals.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\GeneratorCanValidateInterface;
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\BillingClaimBatch;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+use OpenEMR\Billing\BillingUtilities;
+use OpenEMR\Billing\Hcfa1500;
+
+class GeneratorHCFA_PDF extends AbstractGenerator implements GeneratorInterface, GeneratorCanValidateInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    /**
+     * Instance of the Cezpdf object for writing
+     * @Cezpdf
+     */
+    protected $pdf;
+
+    /**
+     * Our billing claim batch for tracking the filename and other
+     * generic claim batch things
+     *
+     * @BillingClaimBatch
+     */
+    protected $batch;
+
+    /**
+     * When we run the execute function on each claim, we don't want
+     * to create a new page the first time. The instantiation of the PDF
+     * object "comes with" a canvas to write to, so the first claim, we
+     * don't need to create one. On subsequent claims, we do so we initialize
+     * this to false, and then set to true after the first claim.
+     *
+     * @bool
+     */
+    protected $createNewPage;
+
+    /**
+     * This function is called by the BillingProcessor before the main
+     * claim loop starts.
+     *
+     * Here we set up our PDF canvas and our batch file.
+     *
+     * @param array $context
+     */
+    public function setup(array $context)
+    {
+        $post = $context['post'];
+        $this->pdf = new \Cezpdf('LETTER');
+        $this->pdf->ezSetMargins(trim($post['top_margin']) + 0, 0, trim($post['left_margin']) + 0, 0);
+        $this->pdf->selectFont('Courier');
+
+        // This is to tell our execute method not to create a new page the first claim
+        $this->createNewPage = false;
+
+        // Instantiate mainly for the filename creation, we're not tracking text segments
+        // since we're generating a PDF, which is managed in this object
+        $this->batch = new BillingClaimBatch('.pdf');
+    }
+
+    /**
+     * Do the work to append the given claim to the PDF document we're
+     * working on generating
+     *
+     * @param BillingClaim $claim
+     */
+    protected function updateBatch(BillingClaim $claim)
+    {
+        // Do the actual claim processing
+        $log = '';
+        $hcfa = new Hcfa1500();
+        $lines = $hcfa->genHcfa1500($claim->getPid(), $claim->getEncounter(), $log);
+        $this->appendToLog($log);
+        $alines = explode("\014", $lines); // form feeds may separate pages
+        foreach ($alines as $tmplines) {
+            // The first claim we don't create a new page.
+            if ($this->createNewPage) {
+                $this->pdf->ezNewPage();
+            } else {
+                $this->createNewPage = true;
+            }
+            $this->pdf->ezSetY($this->pdf->ez['pageHeight'] - $this->pdf->ez['topMargin']);
+            $this->pdf->ezText($tmplines, 12, array(
+                'justification' => 'left',
+                'leading' => 12
+            ));
+        }
+    }
+
+    /**
+     *
+     * Do validation, mark claim as billed and tell the billing table
+     * that the claim will be written to the given batch file name
+     *
+     * @param BillingClaim $claim
+     */
+    public function generate(BillingClaim $claim)
+    {
+        // Validate and mark as 'billed'
+        $this->validateAndClear($claim);
+
+        // Finalize the claim
+        if (!BillingUtilities::updateClaim(false, $claim->getPid(), $claim->getEncounter(), -1, -1, 2, 2, $this->batch->getBatFilename())) {
+            $this->printToScreen(xl("Internal error: claim ") . $claim->getId() . xl(" not found!") . "\n");
+        } else {
+            $this->printToScreen(xl("Successfully processed claim") . ": " . $claim->getId());
+        }
+    }
+
+    /**
+     * When user chooses "validate only" we just build the PDF
+     *
+     * @param BillingClaim $claim
+     */
+    public function validateOnly(BillingClaim $claim)
+    {
+        $this->updateBatch($claim);
+        $this->printToScreen(xl("Successfully Validated claim") . ": " . $claim->getId());
+    }
+
+    /**
+     * When the user chooses "validate and clear" we build the PDF
+     * and mark the claim as 'billed'
+     *
+     * @param BillingClaim $claim
+     */
+    public function validateAndClear(BillingClaim $claim)
+    {
+        $this->validateOnly($claim);
+
+        // This is a validation pass
+        $tmp = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            BillingClaim::STATUS_MARK_AS_BILLED, // status == 2 means
+            BillingClaim::BILL_PROCESS_IN_PROGRESS, // bill_process == 1 means??
+            '', // process_file
+            'hcfa'
+        );
+
+        $this->printToScreen(xl("Successfully marked claim") . ": " . $claim->getId() . xl(" as billed"));
+    }
+
+    /**
+     * This method is called when the user clicks "validate" or "validate and clear",
+     * and writes the HCFA file to the temporary directory.
+     *
+     * @param array $context
+     */
+    public function completeToScreen(array $context)
+    {
+        // If we are just validating, make a temp file
+        $tmp_claim_file = $GLOBALS['temporary_files_dir'] .
+            DIRECTORY_SEPARATOR .
+            $this->batch->getBatFilename();
+        file_put_contents($tmp_claim_file, $this->pdf->ezOutput());
+
+        // If we are just validating, the output should be a PDF presented
+        // to the user, but we don't save to the edi/ directory.
+        // This just writes to a tmp file, serves to user and then removes tmp file
+        $this->logger->setLogCompleteCallback(function () {
+            // This is the callback function passed to the logger, called when the
+            // result screen is finished rendering. This prints some JS that will
+            // start the download of the 'temporary' HCFA pdf after messages have been printed to the
+            // screen. The delete flag tells get_claim_file.php endpoint to delete the file after
+            // download. The location string tells get_claim_file.php that the file is in
+            // the globally-configured tmp directory.
+            $this->printDownloadClaimFileJS($this->batch->getBatFilename(), 'tmp', true);
+        });
+    }
+
+    /**
+     * This method is called when the user clicks "continue" and initiates
+     * 'normal' operation.
+     *
+     * Write the HCFA file to the edi directory.
+     *
+     * @param array $context
+     */
+    public function completeToFile(array $context)
+    {
+        // If a writable edi directory exists (and it should), write the pdf to it.
+        $fh = @fopen($GLOBALS['OE_SITE_DIR'] . "/documents/edi/{$this->batch->getBatFilename()}", 'a');
+        if ($fh) {
+            fwrite($fh, $this->pdf->ezOutput());
+            fclose($fh);
+        }
+
+        // Tell the billing_process.php script to initiate a download of this file
+        // that's in the edi directory
+        $this->logger->setLogCompleteCallback($this, function () {
+            // This uses our parent's method to print the JS that automatically initiates
+            // the download of this file, after the screen bill_log messages have printed
+            $this->printDownloadClaimFileJS($this->batch->getBatFilename());
+        });
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF_IMG.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF_IMG.php b/src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF_IMG.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorHCFA_PDF_IMG.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,61 @@
+<?php
+
+/**
+ * This class represents the task that compiles claims into a HCFA 1500
+ * PDF over the image of the actual CMS HCFA 1500 form.
+ *
+ * This generator will be run in favor of the Tasks\GeneratorHCFA_PDF
+ * if the setting in Globals > Billing is set for "Prints the CMS 1500 on the Preprinted form"
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Brady Miller <brady.g.miller@gmail.com>
+ * @author    Jerry Padgett <sjpadgett@gmail.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2014-2020 Brady Miller <brady.g.miller@gmail.com>
+ * @copyright Copyright (c) 2017-2020 Jerry Padgett <sjpadgett@gmail.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\GeneratorCanValidateInterface;
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\Hcfa1500;
+
+class GeneratorHCFA_PDF_IMG extends GeneratorHCFA_PDF implements GeneratorInterface, GeneratorCanValidateInterface, LoggerInterface
+{
+    /**
+     * The only difference between this and the parent PDF generator
+     * is that this overlays the data on an image of the HCFA 1500
+     * claim form.
+     *
+     * Whether this action is available is configured in Globals > Billing
+     * withe checkbox "Prints the CMS 1500 on the Preprinted form"
+     *
+     * @param BillingClaim $claim
+     */
+    protected function updateBatch(BillingClaim $claim)
+    {
+        $log = '';
+        $hcfa = new Hcfa1500();
+        $lines = $hcfa->genHcfa1500($claim->getPid(), $claim->getEncounter(), $log);
+        $hcfa_image = $GLOBALS['images_static_absolute'] . "/cms1500.png";
+        $this->appendToLog($log);
+        $alines = explode("\014", $lines); // form feeds may separate pages
+        foreach ($alines as $tmplines) {
+            if ($claim_count++) {
+                $this->pdf->ezNewPage();
+            }
+            $this->pdf->ezSetY($this->pdf->ez['pageHeight'] - $this->pdf->ez['topMargin']);
+            $this->pdf->addPngFromFile("$hcfa_image", 0, 0, 612, 792);
+            $this->pdf->ezText($tmplines, 12, array(
+                'justification' => 'left',
+                'leading' => 12
+            ));
+        }
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorUB04Form_PDF.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorUB04Form_PDF.php b/src/Billing/BillingProcessor/Tasks/GeneratorUB04Form_PDF.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorUB04Form_PDF.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,88 @@
+<?php
+
+/**
+ * This class represents the task that compiles claims into a UB04 PDF
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Brady Miller <brady.g.miller@gmail.com>
+ * @author    Jerry Padgett <sjpadgett@gmail.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2014-2020 Brady Miller <brady.g.miller@gmail.com>
+ * @copyright Copyright (c) 2017-2020 Jerry Padgett <sjpadgett@gmail.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\BillingClaimBatch;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+use OpenEMR\Billing\BillingUtilities;
+
+require_once __DIR__ . '/../../../../interface/billing/ub04_dispose.php';
+
+class GeneratorUB04Form_PDF extends AbstractGenerator implements GeneratorInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    // These two are specific to UB04
+    protected $template = array();
+    protected $ub04id = array();
+    protected $batch;
+
+    public function setup(array $context)
+    {
+        $this->batch = new BillingClaimBatch('.pdf');
+
+        // This was called at top of old billing_process.php so call in setup()
+        ub04_dispose();
+    }
+
+    /**
+     * Called on each claim in the claim file loop
+     *
+     * @param BillingClaim $claim
+     */
+    public function generate(BillingClaim $claim)
+    {
+        $this->ub04id = get_ub04_array($claim->getPid(), $claim->getEncounter());
+        $ub_save = json_encode($this->ub04id);
+        $tmp = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            2,
+            1,
+            '',
+            'ub04',
+            -1,
+            0,
+            $ub_save
+        );
+
+        $log = "";
+        $this->template[] = buildTemplate($claim->getPid(), $claim->getEncounter(), "", "", $log);
+        $this->appendToLog($log);
+
+        if (!BillingUtilities::updateClaim(false, $claim->getPid(), $claim->getEncounter(), -1, -1, 2, 2, $this->batch->getBatFilename(), 'ub04', -1, 0, json_encode($this->ub04id))) {
+            $this->printToScreen(xl("Internal error: claim ") . $claim->getId() . xl(" not found!") . "\n");
+        }
+    }
+
+    /**
+     * Called after claim file loop
+     *
+     * @param array $context
+     */
+    public function completeToFile(array $context)
+    {
+        ub04Dispose('download', $this->template, $this->batch->getBatFilename(), 'form');
+        exit();
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorUB04NoForm.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorUB04NoForm.php b/src/Billing/BillingProcessor/Tasks/GeneratorUB04NoForm.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorUB04NoForm.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,61 @@
+<?php
+
+/**
+ * This class represents the task that compiles claims into a UB04 form
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Brady Miller <brady.g.miller@gmail.com>
+ * @author    Jerry Padgett <sjpadgett@gmail.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2014-2020 Brady Miller <brady.g.miller@gmail.com>
+ * @copyright Copyright (c) 2017-2020 Jerry Padgett <sjpadgett@gmail.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\BillingClaimBatch;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+use OpenEMR\Billing\BillingUtilities;
+
+require_once __DIR__ . '/../../../../interface/billing/ub04_dispose.php';
+
+class GeneratorUB04NoForm extends AbstractGenerator implements GeneratorInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    // These two are specific to UB04
+    protected $template = array();
+    protected $ub04id = array();
+    protected $batch;
+
+    public function setup(array $context)
+    {
+        $this->batch = new BillingClaimBatch('.pdf');
+
+        // This was called at top of old billing_process.php so call in setup()
+        ub04_dispose();
+    }
+
+    public function generate(BillingClaim $claim)
+    {
+        $log = "";
+        $this->template[] = buildTemplate($claim->getPid(), $claim->getEncounter(), "", "", $log);
+        $this->appendToLog($log);
+
+        if (!BillingUtilities::updateClaim(false, $claim->getPid(), $claim->getEncounter(), -1, -1, 2, 2, $this->batch->getBatFilename(), 'ub04', -1, 0, json_encode($this->ub04id))) {
+            $this->printToScreen(xl("Internal error: claim ") . $claim->getId() . xl(" not found!") . "\n");
+        }
+    }
+
+    public function completeToFile(array $context)
+    {
+        ub04Dispose('download', $this->template, $this->batch->getBatFilename(), 'noform');
+        exit();
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorUB04X12.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorUB04X12.php b/src/Billing/BillingProcessor/Tasks/GeneratorUB04X12.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorUB04X12.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,141 @@
+<?php
+
+/**
+ * This class represents the task that compiles claims into a UB04 X12 batch file
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Brady Miller <brady.g.miller@gmail.com>
+ * @author    Jerry Padgett <sjpadgett@gmail.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2014-2020 Brady Miller <brady.g.miller@gmail.com>
+ * @copyright Copyright (c) 2017-2020 Jerry Padgett <sjpadgett@gmail.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\GeneratorCanValidateInterface;
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\BillingClaimBatch;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+use OpenEMR\Billing\BillingUtilities;
+use OpenEMR\Billing\X125010837I;
+
+require_once __DIR__ . '/../../../../interface/billing/ub04_dispose.php';
+
+class GeneratorUB04X12 extends AbstractGenerator implements GeneratorInterface, GeneratorCanValidateInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    // These two are specific to UB04
+    protected $template = array();
+    protected $ub04id = array();
+
+    protected $batch;
+
+    protected function updateBatch(BillingClaim $claim)
+    {
+        // Do the UB04 processing
+        $log = '';
+        $segs = explode("~\n", X125010837I::generateX12837I($claim->getPid(), $claim->getEncounter(), $log, $this->ub04id));
+        $this->appendToLog($log);
+        $this->batch->append_claim($segs);
+
+        // Store the claims that are in this claims batch, because
+        // if remote SFTP is enabled, we'll need the x12 partner ID to look up SFTP credentials
+        $this->batch->addClaim($claim);
+    }
+
+    public function setup(array $context)
+    {
+        $this->batch = new BillingClaimBatch('.txt');
+
+        // This was called at top of old billing_process.php so call in setup()
+        ub04_dispose();
+    }
+
+    public function validateOnly(BillingClaim $claim)
+    {
+        return $this->updateBatch($claim);
+    }
+
+    public function validateAndClear(BillingClaim $claim)
+    {
+        $this->ub04id = get_ub04_array($claim->getPid(), $claim->getEncounter());
+        $ub_save = json_encode($this->ub04id);
+        $tmp = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            BillingClaim::STATUS_MARK_AS_BILLED,
+            BillingClaim::BILL_PROCESS_IN_PROGRESS,
+            '',
+            $claim->getTarget(),
+            $claim->getPartner() . '-837I',
+            0,
+            $ub_save
+        );
+
+        return $this->updateBatch($claim);
+    }
+
+    /**
+     * In running the 'normal' action, this method is called
+     * by AbstractGenerator's execute() method.
+     *
+     * It marks the claim as billed and writes batch filename to
+     * the billing table.
+     *
+     * @param BillingClaim $claim
+     */
+    public function generate(BillingClaim $claim)
+    {
+        $this->validateAndClear();
+
+        $tmp = BillingUtilities::updateClaim(
+            false,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            -1,
+            -1,
+            2,
+            2,
+            $this->batch->getBatFilename(),
+            'X12-837I',
+            -1,
+            0,
+            json_encode($this->ub04id)
+        );
+
+        // If we had an error, print to screen
+        if (!$tmp) {
+            $this->printToScreen(xl("Internal error: claim ") . $claim->getId() . xl(" not found!") . "\n");
+        }
+    }
+
+    public function completeToScreen(array $context)
+    {
+        $this->batch->append_claim_close();
+
+        $format_bat = str_replace('~', PHP_EOL, $this->batch->getBatContent());
+        $wrap = "<!DOCTYPE html><html><head></head><body><div style='overflow: hidden;'><pre>" . text($format_bat) . "</pre></div></body></html>";
+        echo $wrap;
+    }
+
+    public function completeToFile(array $context)
+    {
+        $this->batch->append_claim_close();
+        $success = $this->batch->write_batch_file();
+        if ($success) {
+            $this->printToScreen(xl('X-12 Generated Successfully'));
+        } else {
+            $this->printToScreen(xl('Error Generating Batch File'));
+        }
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorX12.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorX12.php b/src/Billing/BillingProcessor/Tasks/GeneratorX12.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorX12.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,199 @@
+<?php
+
+/**
+ * This class represents the task that compiles claims into an X12 batch file
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Brady Miller <brady.g.miller@gmail.com>
+ * @author    Daniel Pflieger <daniel@growlingflea.com>
+ * @author    Terry Hill <terry@lilysystems.com>
+ * @author    Jerry Padgett <sjpadgett@gmail.com>
+ * @author    Stephen Waite <stephen.waite@cmsvt.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Daniel Pflieger <daniel@growlingflea.com>
+ * @copyright Copyright (c) 2014-2020 Brady Miller <brady.g.miller@gmail.com>
+ * @copyright Copyright (c) 2016 Terry Hill <terry@lillysystems.com>
+ * @copyright Copyright (c) 2017-2020 Jerry Padgett <sjpadgett@gmail.com>
+ * @copyright Copyright (c) 2018-2020 Stephen Waite <stephen.waite@cmsvt.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\GeneratorCanValidateInterface;
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\BillingClaimBatch;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+use OpenEMR\Billing\BillingUtilities;
+use OpenEMR\Billing\X125010837P;
+
+class GeneratorX12 extends AbstractGenerator implements GeneratorInterface, GeneratorCanValidateInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    /**
+     * If "Allow Encounter Claims" is enabled, this allows the claims to use
+     * the alternate payor ID on the claim and sets the claims to report,
+     * not chargeable. ie: RP = reporting, CH = chargeable
+     *
+     * @var bool|mixed
+     */
+    protected $encounter_claim = false;
+
+    /**
+     * @var BillingClaimBatch
+     */
+    protected $batch;
+
+    public function __construct($action, $encounter_claim = false)
+    {
+        parent::__construct($action);
+        $this->encounter_claim = $encounter_claim;
+    }
+
+    /**
+     * This function is called for both validation and claim file generation.
+     *
+     * It calls the x-12 formatting function to format the individual claim
+     * and appends the claim to the batch file.
+     *
+     * @param BillingClaim $claim
+     */
+    protected function updateBatchFile(BillingClaim $claim)
+    {
+        // Generate the file
+        $log = '';
+        $segs = explode("~\n", X125010837P::genX12837P($claim->getPid(), $claim->getEncounter(), $log, $this->encounter_claim));
+        $this->appendToLog($log);
+        $this->batch->append_claim($segs);
+
+        // Store the claims that are in this claims batch, because
+        // if remote SFTP is enabled, we'll need the x12 partner ID to look up SFTP credentials
+        $this->batch->addClaim($claim);
+    }
+
+    /**
+     * This function is called before main claim loop to set up this
+     * generator object.
+     *
+     * @param array $context
+     */
+    public function setup(array $context)
+    {
+        $this->batch = new BillingClaimBatch('.txt');
+    }
+
+    /**
+     * In running the validate-only action, this method is called
+     * by AbstractGenerator's execute() method.
+     *
+     * @param BillingClaim $claim
+     */
+    public function validateOnly(BillingClaim $claim)
+    {
+        $this->updateBatchFile($claim);
+    }
+
+    /**
+     * In running the validate-and-clear action, this method is called
+     * by AbstractGenerator's execute() method.
+     *
+     * It marks the claim as billed, but doesn't write the final
+     * batch claim file to the edi directory.
+     *
+     * @param BillingClaim $claim
+     */
+    public function validateAndClear(BillingClaim $claim)
+    {
+        $return = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            BillingClaim::STATUS_MARK_AS_BILLED,
+            BillingClaim::BILL_PROCESS_IN_PROGRESS, // bill_process == 1 means??
+            '', // process_file
+            $claim->getTarget(),
+            $claim->getPartner()
+        );
+
+        // Update the batch file content with this claim's data
+        $this->updateBatchFile($claim);
+    }
+
+    /**
+     * In running the 'normal' action, this method is called
+     * by AbstractGenerator's execute() method.
+     *
+     * It marks the claim as billed and writes batch filename to
+     * the billing table.
+     *
+     * @param BillingClaim $claim
+     */
+    public function generate(BillingClaim $claim)
+    {
+        $tmp = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            BillingClaim::STATUS_MARK_AS_BILLED,
+            BillingClaim::BILL_PROCESS_IN_PROGRESS, // bill_process == 1 means??
+            '', // process_file
+            $claim->getTarget(),
+            $claim->getPartner()
+        );
+
+        // Update the batch file content with this claim's data
+        $this->updateBatchFile($claim);
+
+        // After we save the claim, update it with the filename (don't create a new revision)
+        if (!BillingUtilities::updateClaim(false, $claim->getPid(), $claim->getEncounter(), -1, -1, 2, 2, $this->batch->getBatFilename())) {
+            $this->printToScreen(xl("Internal error: claim ") . $claim->getId() . xl(" not found!") . "\n");
+        }
+    }
+
+    /**
+     * Complete the file and write formatted content to screen.
+     *
+     * In running the validate-only, or validate-and-clear action, this method is called
+     * by AbstractGenerator's complete() method.
+     *
+     * @param array $context
+     */
+    public function completeToScreen(array $context)
+    {
+        $this->batch->append_claim_close();
+        // If we're validating only, or clearing and validating, don't write to our EDI directory
+        // Just send to the browser in that case for the end-user to review.
+        $format_bat = str_replace('~', PHP_EOL, $this->batch->getBatContent());
+        $wrap = "<!DOCTYPE html><html><head></head><body><div style='overflow: hidden;'><pre>" . text($format_bat) . "</pre></div></body></html>";
+        echo $wrap;
+        exit();
+    }
+
+    /**
+     * Complete the file and write formatted content to the edi directory.
+     *
+     * When running 'normal' action, this method is called
+     * by AbstractGenerator's complete() method.
+     *
+     * @param array $context
+     */
+    public function completeToFile(array $context)
+    {
+        $this->batch->append_claim_close();
+        $success = $this->batch->write_batch_file();
+        if ($success) {
+            $this->printToScreen(xl('X-12 Generated Successfully'));
+        } else {
+            $this->printToScreen(xl('Error Generating Batch File'));
+        }
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/GeneratorX12Direct.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/GeneratorX12Direct.php b/src/Billing/BillingProcessor/Tasks/GeneratorX12Direct.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/GeneratorX12Direct.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,313 @@
+<?php
+
+/**
+ * This class represents the task that compiles claims into
+ * x-12 batch files, one for each insurance/x-12 pair.
+ *
+ * This task will be run in favor of Task\GeneratorX12 if
+ * the global is enabled "Generate X-12 Based On Insurance Company"
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @author    Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\GeneratorCanValidateInterface;
+use OpenEMR\Billing\BillingProcessor\GeneratorInterface;
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\BillingClaimBatch;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+use OpenEMR\Billing\BillingUtilities;
+use OpenEMR\Billing\X125010837P;
+use OpenEMR\Common\Csrf\CsrfUtils;
+
+class GeneratorX12Direct extends AbstractGenerator implements GeneratorInterface, GeneratorCanValidateInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    /**
+     * If "Allow Encounter Claims" is enabled, this allows the claims to use
+     * the alternate payor ID on the claim and sets the claims to report,
+     * not chargeable. ie: RP = reporting, CH = chargeable
+     *
+     * @var bool|mixed
+     */
+    protected $encounter_claim = false;
+
+    /**
+     * An array of batches, one for each x-12 partner, indexed by partner id
+     *
+     * @var array
+     */
+    protected $x12_partner_batches = [];
+
+    /**
+     * An array of x-12 partners, indexed by partner id
+     *
+     * @var array
+     */
+    protected $x12_partners = [];
+
+    public function __construct($action, $encounter_claim = false)
+    {
+        parent::__construct($action);
+        $this->encounter_claim = $encounter_claim;
+    }
+
+    /**
+     * In the direct-billing setup method, we need to make sure that
+     * the directories are created for our x-12 partners because
+     * we save one batch file for each z-12 partner.
+     *
+     * We also set up a BillingClaimBatch for each x-12 partner in case
+     * we have any claims to write to them in this group of claims.
+     *
+     * @param $context
+     */
+    public function setup(array $context)
+    {
+        // We have to prepare our batches here
+        // Get all of our x-12 partners and make sure we have
+        // directories to write to for them
+        $result = sqlStatement("SELECT * from x12_partners");
+        while ($row = sqlFetchArray($result)) {
+            $has_dir = true;
+            if (!isset($row['x12_sftp_local_dir'])) {
+                // Local Directory not set
+                $has_dir = false;
+                $this->printToScreen(xl("No directory for X12 partner " . $row['name']));
+            } else if (
+                isset($row['x12_sftp_local_dir']) &&
+                !is_dir($row['x12_sftp_local_dir'])
+            ) {
+                // If the local directory doesn't exist, attempt to create it
+                $has_dir = mkdir($row['x12_sftp_local_dir'], '644', true);
+                if (false === $has_dir) {
+                    $this->printToScreen(xl("Could not create directory for X12 partner " . $row['name']));
+                }
+            }
+
+            $batch = new BillingClaimBatch();
+            $filename = $batch->getBatFilename();
+            $filename = str_replace('batch', 'batch-p' . $row['id'], $filename);
+            $batch->setBatFilename($filename);
+
+            // Only set the batch file directory if we have a valid directory
+            if ($has_dir) {
+                $batch->setBatFiledir($row['x12_sftp_local_dir']);
+            }
+
+            // Store the x-12 partner's data in case we need to reference it (like need the Name or something)
+            $this->x12_partners[$row['id']] = $row;
+
+            // Store the directory in an associative array with the partner ID as the index
+            $this->x12_partner_batches[$row['id']] = $batch;
+
+            // Look through the claims and set is_last on each one that
+            // is the last for this x-12 partner
+            foreach ($context['claims'] as $claim) {
+                if ($claim->getPartner() === $row['id']) {
+                    $lastClaim = $claim;
+                }
+            }
+            $lastClaim->setIsLast(true);
+        }
+    }
+
+    /**
+     * In validate-only mode, we just build the batch and print to screen,
+     * the claim remains unaltered in the database.
+     *
+     * @param BillingClaim $claim
+     */
+    public function validateOnly(BillingClaim $claim)
+    {
+        $this->updateBatchFile($claim);
+    }
+
+    /**
+     * In validate-and-clear mode, we mark the claim as 'billed'
+     * and build the batch file.
+     *
+     * @param BillingClaim $claim
+     * @return mixed
+     */
+    public function validateAndClear(BillingClaim $claim)
+    {
+        $return = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            BillingClaim::STATUS_MARK_AS_BILLED,
+            BillingClaim::BILL_PROCESS_IN_PROGRESS, // bill_process == 1 means??
+            '', // process_file
+            $claim->getTarget(),
+            $claim->getPartner()
+        );
+
+        // Return the batch we updated (depending on x-12 partner)
+        return $this->updateBatchFile($claim);
+    }
+
+    /**
+     * This is the 'normal' mode, where we validate and clear each claim,
+     * and also complete it and write the batch file to the database.
+     *
+     * @param BillingClaim $claim
+     */
+    public function generate(BillingClaim $claim)
+    {
+        // If we are doing final billing (normal) or validate and mark-as-billed,
+        // Use the claim to update the appropriate batch file (depends on x-12 partner)
+        // and return the batch we updated
+        $batch = $this->validateAndClear($claim);
+
+        if (!BillingUtilities::updateClaim(false, $claim->getPid(), $claim->getEncounter(), -1, -1, 2, 2, $batch->getBatFilename())) {
+            $this->printToScreen(xl("Internal error: claim ") . $claim->getId() . xl(" not found!") . "\n");
+        }
+    }
+
+    /**
+     * This is where the batch formatting work happens on each claim. This generator
+     * uses the TR3 format which has a different claim loop than the other
+     * gen_x12 function.
+     *
+     * @param BillingClaim $claim
+     * @return mixed
+     */
+    protected function updateBatchFile(BillingClaim $claim)
+    {
+        // Get the correct batch file using the X-12 partner ID
+        $batch = $this->x12_partner_batches[$claim->getPartner()];
+
+        // Tell our batch that we've processed this claim
+        $batch->addClaim($claim);
+
+        // Use the tr3 format to output for direct-submission to insurance companies
+        $log = '';
+        $is_last_claim = $claim->getIsLast();
+        $segs = explode("~\n", X125010837P::gen_x12_837_tr3($claim->getPid(), $claim->getEncounter(), $log, $this->encounter_claim, $is_last_claim));
+        $this->appendToLog($log);
+        $batch->append_claim($segs);
+
+        return $batch;
+    }
+
+    /**
+     * Complete the file and write formatted content to the edi directory.
+     *
+     * When running 'normal' action, this method is called
+     * by AbstractGenerator's complete() method.
+     *
+     * We call finish with a closure that
+     *
+     * @param array $context
+     */
+    public function completeToFile(array $context)
+    {
+        $this->finish($context, function ($context) {
+
+            // Get the created_batches from the finish method
+            $created_batches = $context['created_batches'];
+
+            // In the "normal" operation, we have written the batch files to disk above, and
+            // need to build a presentation for the user to download them.
+            $html = "<!DOCTYPE html><html><head></head><body><div style='overflow: hidden;'>";
+
+            // If the global is enabled to SFTP claim files, tell the user
+            if ($GLOBALS['auto_sftp_claims_to_x12_partner']) {
+                $html .= "<div class='alert alert-primary' role='alert'>" . xlt("Sending Claims via STFP. Check status on the `Claim File Tracker`") . "</div>";
+            }
+
+            // Build the download URLs for our claim files so we can present them to the
+            // user for download.
+            $html .= "<ul class='list-group'>";
+            foreach ($created_batches as $x12_partner_id => $created_batch) {
+                // This is the final, validated claim, write to the edi location for this x12 partner
+                $created_batch->write_batch_file($x12_partner_id);
+                $x12_partner_name = text($this->x12_partners[$x12_partner_id]['name']);
+                // For the modal, build a list of downloads
+                $file = $created_batch->getBatFilename();
+                $url = $GLOBALS['webroot'] . '/interface/billing/get_claim_file.php?' .
+                    'key=' . urlencode($file) .
+                    '&partner=' . urlencode($x12_partner_id) .
+                    '&csrf_token_form=' . urlencode(CsrfUtils::collectCsrfToken());
+                $html .=
+                    "<li class='list-group-item d-flex justify-content-between align-items-center'>
+                        <a href='" . attr($url) . "'>" . text($file) . "</a>
+                        <span class='badge badge-primary badge-pill'>" . text($x12_partner_name) . "</span>
+                    </li>";
+            }
+            $html .= "</ul>";
+            $html .= "</div></body></html>";
+
+            echo $html;
+        });
+    }
+
+    public function completeToScreen(array $context)
+    {
+        $this->finish($context, function ($context) {
+
+            // Get the format_bat string from the finish method
+            $format_bat = $context['format_bat'];
+
+            // if validating (sending to screen for user)
+            $wrap = "<!DOCTYPE html><html><head></head><body><div style='overflow: hidden;'><pre>" . text($format_bat) . "</pre></div></body></html>";
+            echo $wrap;
+            exit();
+        });
+    }
+
+    /**
+     * This is the common finish function to both completeToFile (normal)
+     * and completeToScreen (validation). We pass the callback to let the
+     * caller specify what we do after we finish up.
+     *
+     * This uses the generator's 'action' attribute to decide whether
+     * to generate the edi file or not. If we're in NORMAL mode, generate the
+     * file.
+     *
+     * @param array $context
+     * @param callable $callback
+     */
+    protected function finish(array $context, callable $callback)
+    {
+        $format_bat = "";
+        $created_batches = [];
+        // Loop through all of the X12 batch files we've created, one per x-12 partner,
+        // and depending on the action we're running, either write the final claim
+        // to disk, or format the content for printing to the screen.
+        foreach ($this->x12_partner_batches as $x12_partner_id => $x12_partner_batch) {
+            // If we didn't write any claims for this X12 partner
+            // don't append the closing lines or write the claim file or do anything else
+            if (empty($x12_partner_batch->getBatContent())) {
+                continue;
+            }
+
+            $x12_partner_batch->append_claim_close();
+
+            // Write the batch content to formatted string for presenting to user
+            $format_bat .= str_replace('~', PHP_EOL, $x12_partner_batch->getBatContent()) . "\n";
+
+            // Store all the batches we create with the x12-partner ID as index
+            // so we can pass them to the callback
+            $created_batches[$x12_partner_id] = $x12_partner_batch;
+        }
+
+        // Call the callback with new context
+        $callback([
+            'created_batches' => $created_batches,
+            'format_bat' => $format_bat
+        ]);
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/TaskMarkAsClear.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/TaskMarkAsClear.php b/src/Billing/BillingProcessor/Tasks/TaskMarkAsClear.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/TaskMarkAsClear.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,39 @@
+<?php
+
+/**
+ * This implementation of processing task marks all claims as 'cleared' or 'billed' (same thing)
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\ProcessingTaskInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+
+class TaskMarkAsClear extends AbstractProcessingTask implements ProcessingTaskInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    public function setup(array $context)
+    {
+        // nothing to do
+    }
+
+    public function execute(BillingClaim $claim)
+    {
+        $this->appendToScreen(xl("Claim ") . $claim->getId() . xl(" was marked as billed only.") . "\n");
+        return $this->clearClaim($claim);
+    }
+
+    public function complete(array $context)
+    {
+        // nothing to do
+    }
+}
Index: src/Billing/BillingProcessor/Tasks/TaskReopen.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Tasks/TaskReopen.php b/src/Billing/BillingProcessor/Tasks/TaskReopen.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Tasks/TaskReopen.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,49 @@
+<?php
+
+/**
+ * This implementation of processing task re-opens all claims
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Tasks;
+
+use OpenEMR\Billing\BillingProcessor\LoggerInterface;
+use OpenEMR\Billing\BillingProcessor\ProcessingTaskInterface;
+use OpenEMR\Billing\BillingProcessor\BillingClaim;
+use OpenEMR\Billing\BillingProcessor\Traits\WritesToBillingLog;
+use OpenEMR\Billing\BillingUtilities;
+
+class TaskReopen extends AbstractProcessingTask implements ProcessingTaskInterface, LoggerInterface
+{
+    use WritesToBillingLog;
+
+    public function setup(array $context)
+    {
+        // nothing to do
+    }
+
+    public function execute(BillingClaim $claim)
+    {
+        $this->printToScreen("Opening claim");
+        $tmp = BillingUtilities::updateClaim(
+            true,
+            $claim->getPid(),
+            $claim->getEncounter(),
+            $claim->getPayorId(),
+            $claim->getPayorType(),
+            1,
+            0 // Set 'billed' flag to '0' to re-open claim
+        );
+        return $tmp;
+    }
+
+    public function complete(array $context)
+    {
+        // nothing to do
+    }
+}
Index: src/Billing/BillingProcessor/Traits/WritesToBillingLog.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/Traits/WritesToBillingLog.php b/src/Billing/BillingProcessor/Traits/WritesToBillingLog.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/Traits/WritesToBillingLog.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,43 @@
+<?php
+
+/**
+ * This implementation of LoggerInterface for use in processing tasks.
+ *
+ * The logger is set on the processing task in the BillingProcessor method
+ * buildProcessingTaskFromPost()
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor\Traits;
+
+use OpenEMR\Billing\BillingProcessor\BillingLogger;
+
+trait WritesToBillingLog
+{
+    protected $logger;
+
+    public function getLogger()
+    {
+        return $this->logger;
+    }
+
+    public function setLogger(BillingLogger $logger)
+    {
+        $this->logger = $logger;
+    }
+
+    public function printToScreen($message)
+    {
+        $this->logger->printToScreen($message);
+    }
+
+    public function appendToLog($message)
+    {
+        $this->logger->appendToLog($message);
+    }
+}
Index: src/Billing/BillingProcessor/X12RemoteTracker.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingProcessor/X12RemoteTracker.php b/src/Billing/BillingProcessor/X12RemoteTracker.php
new file mode 100644
--- /dev/null	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
+++ b/src/Billing/BillingProcessor/X12RemoteTracker.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -0,0 +1,223 @@
+<?php
+
+/**
+ * Model that provides tracking information for a run of claim processing using
+ * the billing manager. Each run is saved as an entry in the billing_tracker_batch
+ * table.
+ *
+ * @package   OpenEMR
+ * @link      http://www.open-emr.org
+ * @author    Ken Chapple <ken@mi-squared.com>
+ * @copyright Copyright (c) 2021 Ken Chapple <ken@mi-squared.com>
+ * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ */
+
+namespace OpenEMR\Billing\BillingProcessor;
+
+use OpenEMR\Common\Crypto\CryptoGen;
+use OpenEMR\Services\BaseService;
+use phpseclib\Net\SFTP;
+
+class X12RemoteTracker extends BaseService
+{
+    const STATUS_WAITING = 'waiting';
+    const STATUS_PARAMETER_ERROR = 'parameter-error';
+    const STATUS_CLAIM_FILE_ERROR = 'claim-file-error';
+    const STATUS_LOGIN_ERROR = 'login-error';
+    const STATUS_CHDIR_ERROR = 'chdir-error';
+    const STATUS_IN_PROGRESS = 'in-progress';
+    const STATUS_UPLOAD_ERRROR = 'upload-error';
+    const STATUS_SUCCESS = 'success';
+
+    const TABLE_NAME = 'x12_remote_tracker';
+
+    protected static $x12_partner_field_keys = [
+        'x12_sftp_host' => 'X12 SFTP Host',
+        'x12_sftp_port' => 'X12 SFTP Port',
+        'x12_sftp_login' => 'X12 SFTP Login',
+        'x12_sftp_pass' => 'X12 SFTP Password',
+        'x12_sftp_remote_dir' => 'X12 SFTP Remote Dir',
+        'x12_sftp_local_dir' => 'X12 SFTP Local Dir',
+    ];
+
+    const SELECT = "SELECT R.id, R.x12_filename, R.status, R.messages, R.claims, R.created_at, R.updated_at,
+       P.name, P.id AS x12_partner_id, P.x12_sftp_host, P.x12_sftp_port, P.x12_sftp_login, P.x12_sftp_pass,
+       P.x12_sftp_remote_dir, P.x12_sftp_local_dir FROM x12_remote_tracker R";
+
+    protected $validationMessages = [];
+
+    public function __construct()
+    {
+        parent::__construct(self::TABLE_NAME);
+    }
+
+    public static function sftpSendWaitingFiles()
+    {
+        $remoteTracker = new X12RemoteTracker();
+        $x12_remotes = $remoteTracker->fetchByStatus(self::STATUS_WAITING);
+        $x12_remote['messages'] = [];
+        $cryptoGen = new CryptoGen();
+        foreach ($x12_remotes as $x12_remote) {
+            // Make sure required parameters are filled in on the X12 partner form, otherwise, log a message
+            if (false === $remoteTracker->validateSFTPCredentials($x12_remote)) {
+                // there was a problem, get messages, log them and continue
+                $x12_remote['status'] = self::STATUS_PARAMETER_ERROR;
+                $x12_remote['messages'] = array_merge($x12_remote['messages'], $remoteTracker->validationMessages);
+                $remoteTracker->update($x12_remote);
+                continue;
+            }
+
+            // Make sure local claim file exists and can we have permission to read it
+            // We try both the SFTP directory and the edi root directry
+            $claim_file = $x12_remote['x12_sftp_local_dir'] . $x12_remote['x12_filename'];
+            if (!file_exists($claim_file)) {
+                $claim_file = $GLOBALS['OE_SITE_DIR'] . "/documents/edi/" . $x12_remote['x12_filename'];
+            }
+
+            $claim_file_contents = file_get_contents($claim_file);
+            if (false === $claim_file_contents) {
+                $x12_remote['status'] = self::STATUS_CLAIM_FILE_ERROR;
+                $x12_remote['messages'][] = "Could not open local claim file: `$claim_file`";
+                $remoteTracker->update($x12_remote);
+                continue;
+            }
+
+            // Attempt to login
+            $sftp = new SFTP($x12_remote['x12_sftp_host'], $x12_remote['x12_sftp_port']);
+            $decrypted_password = $cryptoGen->decryptStandard($x12_remote['x12_sftp_pass']);
+            if (false === $sftp->login($x12_remote['x12_sftp_login'], $decrypted_password)) {
+                $x12_remote['status'] = self::STATUS_LOGIN_ERROR;
+                $x12_remote['messages'][] = "Invalid Username or Password.";
+                $x12_remote['messages'] = array_merge($x12_remote['messages'], $sftp->getSFTPErrors());
+                $remoteTracker->update($x12_remote);
+                continue;
+            }
+
+            if (false === $sftp->chdir($x12_remote['x12_sftp_remote_dir'])) {
+                $x12_remote['status'] = self::STATUS_CHDIR_ERROR;
+                $x12_remote['messages'][] = "Could not change to SFTP remote DIR.";
+                $x12_remote['messages'] = array_merge($x12_remote['messages'], $sftp->getSFTPErrors());
+                $remoteTracker->update($x12_remote);
+                continue;
+            }
+
+            // Change status from waiting to in-progress
+            $x12_remote['status'] = self::STATUS_IN_PROGRESS;
+            $remoteTracker->update($x12_remote);
+
+            // Upload the file
+            if (false === $sftp->put($x12_remote['x12_filename'], $claim_file_contents)) {
+                $x12_remote['status'] = self::STATUS_UPLOAD_ERRROR;
+                $x12_remote['messages'][] = "Could not upload file.";
+                $x12_remote['messages'] = array_merge($x12_remote['messages'], $sftp->getSFTPErrors());
+                $remoteTracker->update($x12_remote);
+            }
+
+            // Change status from waiting to in-progress
+            $x12_remote['status'] = self::STATUS_SUCCESS;
+            $remoteTracker->update($x12_remote);
+
+            // Disconnect from the remote server
+            $sftp->disconnect();
+        }
+    }
+
+    protected function validateSFTPCredentials($credentials)
+    {
+        $this->validationMessages = [];
+        $valid = true;
+        foreach (self::$x12_partner_field_keys as $key => $label) {
+            if (empty($credentials[$key])) {
+                $this->validationMessages[] = "`$label` is required";
+                $valid = false;
+            }
+        }
+        return $valid;
+    }
+
+    public static function create($fields)
+    {
+        $fields['created_at'] = date('Y-m-d h:i:s');
+        $fields['updated_at'] = date('Y-m-d h:i:s');
+        $remoteTracker = new X12RemoteTracker();
+        return $remoteTracker->insert($fields);
+    }
+
+    public function insert($fields)
+    {
+        $setQueryPart = $this->buildInsertColumns($fields);
+        $sql = " INSERT INTO x12_remote_tracker SET ";
+        $sql .= $setQueryPart['set'];
+
+        $results = sqlInsert(
+            $sql,
+            $setQueryPart['bind']
+        );
+
+        return $results;
+    }
+
+    public function update($fields)
+    {
+        if (is_array($fields['messages'])) {
+            $fields['messages'] = json_encode($fields['messages']);
+        }
+        $fields['updated_at'] = date('Y-m-d h:i:s');
+        $query = $this->buildUpdateColumns($fields);
+        $sql = "UPDATE x12_remote_tracker SET ";
+        $sql .= $query['set'];
+        $sql .= "WHERE id = ?";
+        array_push($query['bind'], $fields['id']);
+        $results = sqlStatement($sql, $query['bind']);
+        return $results;
+    }
+
+    protected function onlyRealFields($passed_in)
+    {
+        $realFields = [];
+        foreach ($passed_in as $key => $value) {
+            if (in_array($key, $this->getFields())) {
+                $realFields[$key] = $value;
+            }
+        }
+        return $realFields;
+    }
+
+    protected function buildInsertColumns($passed_in = array())
+    {
+        return parent::buildInsertColumns($this->onlyRealFields($passed_in));
+    }
+
+    protected function buildUpdateColumns($passed_in = array())
+    {
+        return parent::buildUpdateColumns($this->onlyRealFields($passed_in));
+    }
+
+    /**
+     * Get the remote tracking entries by their status with the newest first
+     *
+     * @param string $status
+     * @return array
+     */
+    public function fetchByStatus($status = self::STATUS_WAITING)
+    {
+        $waiting = self::selectHelper(self::SELECT, [
+            'join' => "JOIN x12_partners P ON P.id = R.x12_partner_id",
+            'where' => "WHERE `status` = ?",
+            'order' => 'ORDER BY R.created_at DESC',
+            'data' => [$status]
+        ]);
+
+        return $waiting;
+    }
+
+    public function fetchAll()
+    {
+        $all = self::selectHelper(self::SELECT, [
+            'join' => "JOIN x12_partners P ON P.id = R.x12_partner_id",
+            'order' => 'ORDER BY R.updated_at DESC'
+        ]);
+
+        return $all;
+    }
+}
Index: src/Billing/BillingReport.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/BillingReport.php b/src/Billing/BillingReport.php
--- a/src/Billing/BillingReport.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/src/Billing/BillingReport.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -71,13 +71,13 @@
                     $query_part .= ' AND ' . "(insurance_data.provider = '0' or insurance_data.date > form_encounter.date)";
                 } elseif (strpos($criteria_value, "form_encounter.date|between|") !== false) {
                     $elements = explode('|', $criteria_value);
-                    $query_part .= ' AND ' . "(form_encounter.date between '" . add_escape_custom($elements[1]) . "' and '" . add_escape_custom($elements[2]) . "')";
+                    $query_part .= ' AND ' . "(form_encounter.date between '" . add_escape_custom($elements[2]) . "' and '" . add_escape_custom($elements[3]) . "')";
                 } elseif (strpos($criteria_value, "billing.date|between|") !== false) {
                     $elements = explode('|', $criteria_value);
-                    $query_part .= ' AND ' . "(billing.date between '" . add_escape_custom($elements[1]) . "' and '" . add_escape_custom($elements[2]) . "')";
+                    $query_part .= ' AND ' . "(billing.date between '" . add_escape_custom($elements[2]) . "' and '" . add_escape_custom($elements[3]) . "')";
                 } elseif (strpos($criteria_value, "claims.process_time|between|") !== false) {
                     $elements = explode('|', $criteria_value);
-                    $query_part .= ' AND ' . "(claims.process_time between '" . add_escape_custom($elements[1]) . "' and '" . add_escape_custom($elements[2]) . "')";
+                    $query_part .= ' AND ' . "(claims.process_time between '" . add_escape_custom($elements[2]) . "' and '" . add_escape_custom($elements[3]) . "')";
                 } else {
                     $elements = explode('|', $criteria_value);
                     $criteriaItemsWhitelist = [
Index: src/Billing/Claim.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/Claim.php b/src/Billing/Claim.php
--- a/src/Billing/Claim.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/src/Billing/Claim.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -603,6 +603,17 @@
         }
     }
 
+//***MS Add - since we are a TPA we need to include this
+    public function x12_submitter_name()
+    {
+        $tmp = $this->x12_partner['x12_submitter_name'];
+        while (strlen($tmp) < 15) {
+            $tmp .= " ";
+        }
+
+        return $tmp;
+    }
+
     public function x12gsreceiverid()
     {
         $tmp = ($this->x12_partner['x12_receiver_id'] ?? '');
Index: src/Billing/X125010837P.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Billing/X125010837P.php b/src/Billing/X125010837P.php
--- a/src/Billing/X125010837P.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/src/Billing/X125010837P.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -7,8 +7,10 @@
  * @package OpenEMR
  * @author Rod Roark <rod@sunsetsystems.com>
  * @author Stephen Waite <stephen.waite@cmsvt.com>
+ * @author Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
  * @copyright Copyright (c) 2009 Rod Roark <rod@sunsetsystems.com>
  * @copyright Copyright (c) 2018-2019 Stephen Waite <stephen.waite@cmsvt.com>
+ * @copyright Copyright (c) 2021 Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
  * @link https://github.com/openemr/openemr/tree/master
  * @license https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
  */
@@ -604,8 +606,10 @@
             "*" . $claim->onsetDate() .
             "~\n";
         } elseif (
-            $claim->miscOnsetDate() && ($claim->miscOnsetDate() !== $claim->serviceDate())
-            && ($claim->box14Qualifier()) && ($claim->miscOnsetDateValid())
+            $claim->miscOnsetDate()
+            && $claim->miscOnsetDate() !== $claim->serviceDate()
+            && ($claim->box14Qualifier())
+            && ($claim->miscOnsetDateValid())
         ) {
             ++$edicount;
             $out .= "DTP" .
@@ -1215,7 +1219,7 @@
                 }
             }
 
-            # needed for epstd
+            // needed for epstd
             if ($claim->epsdtFlag()) {
                 $out .= "*" .
                 "*" .
@@ -1289,9 +1293,9 @@
             // Segment PS1 (Purchased Service Information) omitted.
             // Segment HCP (Line Pricing/Repricing Information) omitted.
 
-        // Loop 2410, Drug Information. Medicaid insurers seem to want this
-        // with HCPCS codes.
-        //
+            // Loop 2410, Drug Information. Medicaid insurers seem to want this
+            // with HCPCS codes.
+            //
             $ndc = $claim->cptNDCID($prockey);
 
             if ($ndc) {
@@ -1320,9 +1324,9 @@
             }
 
 
-        // Loop 2420A, Rendering Provider (service-specific).
-        // Used if the rendering provider for this service line is different
-        // from that in loop 2310B.
+            // Loop 2420A, Rendering Provider (service-specific).
+            // Used if the rendering provider for this service line is different
+            // from that in loop 2310B.
 
             if ($claim->providerNPI() != $claim->providerNPI($prockey)) {
                 ++$edicount;
@@ -1464,15 +1468,1515 @@
         "*" . "0021" .
         "~\n";
 
+        $out .= "GE" .        // GE Trailer
+        "*" . "1" .
+        "*" . "1" .
+        "~\n";
+
+        $out .= "IEA" .       // IEA Trailer
+        "*" . "1" .
+        "*" . "000000001" .
+        "~\n";
+
+        // Remove any trailing empty fields (delimiters) from each segment.
+        $out = preg_replace('/\*+~/', '~', $out);
+
+        $log .= "\n";
+        return $out;
+    }
+
+    /**
+     * This function processes claims and outputs "TR3" format,
+     * for multiple billing providers per claim. This format is the typical
+     * format accepted by insurance companies, and allows OpenEMR to submit
+     * claims directly to insurance compainies without a clearing house.
+     *
+     * @author Daniel Pflieger <daniel@mi-squared.com>, <daniel@growlingflea.com>
+     *
+     * @param  $pid
+     * @param  $encounter
+     * @param  $log
+     * @param  false $encounter_claim
+     * @param  $SEFLAG
+     * @return string|string[]|null
+     */
+    public static function gen_x12_837_tr3($pid, $encounter, &$log, $encounter_claim = false, $SEFLAG)
+    {
+        $today = time();
+        $out = '';
+        $claim = new Claim($pid, $encounter);
+        //Here we set up the variables that will help us keep one billing provider loop per file
+        global $HLcount, $HLBillingPayToProvider, $edicount, $STFLAG;
+        $HLcount = isset($HLcount) ? $HLcount : 0;
+        $edicount = isset($edicount) ? $edicount : 0;
+
+        $log .= "Generating claims directly to ins companies with tr3 function $pid" . "-" . $encounter . " for " .
+            $claim->patientFirstName() . ' ' .
+            $claim->patientMiddleName() . ' ' .
+            $claim->patientLastName() . ' on ' .
+            date('Y-m-d H:i', $today) . ".\n";
+
+        $out .= "ISA" .
+            "*" . $claim->x12gsisa01() .
+            "*" . $claim->x12gsisa02() .
+            "*" . $claim->x12gsisa03() .
+            "*" . $claim->x12gsisa04() .
+            "*" . $claim->x12gsisa05() .
+            "*" . $claim->x12gssenderid() .
+            "*" . $claim->x12gsisa07() .
+            "*" . $claim->x12gsreceiverid() .
+            "*" . "030911" .  // dummy data replace by billing_process.php
+            "*" . "1630" . // ditto
+            "*" . "^" .
+            "*" . "00501" .
+            "*" . "000000001" .
+            "*" . $claim->x12gsisa14() .
+            "*" . $claim->x12gsisa15() .
+            "*:" .
+            "~\n";
+
+        $out .= "GS" .
+            "*" . "HC" .
+            "*" . $claim->x12gsgs02() .
+            "*" . trim($claim->x12gs03()) .
+            "*" . date('Ymd', $today) .
+            "*" . date('Hi', $today) .
+            "*" . "1" .
+            "*" . "X" .
+            "*" . $claim->x12gsversionstring() .
+            "~\n";
+
+        //we only want one transaction set for medi-cal
+        if ($HLcount == 0) { //***TR3 brackets close at 2000B
+            ++$edicount;
+            $out .= "ST" .
+                "*" . "837" .
+                "*" . "0021" .
+                "*" . $claim->x12gsversionstring() .
+                "~\n";
+
+            $STFLAG = true;
+
+            ++$edicount;
+            $out .= "BHT" .
+                "*" . "0019" .                             // 0019 is required here
+                "*" . "00" .                               // 00 = original transmission
+                "*" . "0123" .                             // reference identification
+                "*" . date('Ymd', $today) .           // transaction creation date
+                "*" . date('Hi', $today) .            // transaction creation time
+                "*" . ($encounter_claim ? "RP" : "CH") .  // RP = reporting, CH = chargeable
+                "~\n";
+
+            ++$edicount;
+            if ($claim->federalIdType() == "SY") { // check entity type for NM*102 1 == person, 2 == non-person entity
+                $firstName = $claim->providerFirstName();
+                $lastName = $claim->providerLastName();
+                $middleName = $claim->providerMiddleName();
+                $suffixName = $claim->providerSuffixName();
+                $out .= "NM1" . // Loop 1000A Submitter
+                    "*" . "41" .
+                    "*" . "1" .
+                    "*" . $lastName .
+                    "*" . $firstName .
+                    "*" . $middleName .
+                    "*" . // Name Prefix not used
+                    "*" . $suffixName .
+                    "*" . "46";
+            } else {
+                $billingFacilityName = substr($claim->billingFacilityName(), 0, 60);
+                if ($billingFacilityName == '') {
+                    $log .= "*** billing facility name in 1000A loop is empty\n";
+                }
+                $out .= "NM1" .
+                    "*" . "41" .
+                    "*" . "2" .
+                    "*" . $billingFacilityName .
+                    "*" .
+                    "*" .
+                    "*" .
+                    "*" .
+                    "*" . "46";
+            }
+            $out .= "*" . $claim->billingFacilityETIN();
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "PER" . // Loop 1000A, Submitter EDI contact information
+                "*" . "IC" .
+                "*" . $claim->billingContactName() .
+                "*" . "TE" .
+                "*" . $claim->billingContactPhone() .
+                "*" . "EM" .
+                "*" . $claim->billingContactEmail();
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "NM1" . // Loop 1000B Receiver
+                "*" . "40" .
+                "*" . "2" .
+                "*" . $claim->clearingHouseName() .
+                "*" .
+                "*" .
+                "*" .
+                "*" .
+                "*" . "46" .
+                "*" . $claim->clearingHouseETIN() .
+                "~\n";
+
+            ++$HLcount;
+
+            // if HL count = 1
+
+            if ($HLcount == 1) { //***TR3 Add (this is where we do the HL loop
+                ++$edicount;
+                $out .= "HL" . // Loop 2000A Billing/Pay-To Provider HL Loop
+                "*" . $HLcount .
+                "*" .
+                "*" . "20" .
+                "*" . "1" . // 1 indicates there are child segments
+                "~\n";
+
+                $HLBillingPayToProvider = $HLcount; //***TR3 Modify - HL count numbers are different for TR3 since only one provider per loop
+
+                // Situational PRV segment for provider taxonomy.
+                if ($claim->facilityTaxonomy()) {
+                    ++$edicount;
+                    $out .= "PRV" .
+                    "*" . "BI" .
+                    "*" . "PXC" .
+                    "*" . $claim->facilityTaxonomy() .
+                    "~\n";
+                }
+
+                // Situational CUR segment (foreign currency information) omitted here.
+                ++$edicount;
+                if ($claim->federalIdType() == "SY") { // check for entity type like in 1000A
+                    $firstName = $claim->providerFirstName();
+                    $lastName = $claim->providerLastName();
+                    $middleName = $claim->providerMiddleName();
+                    $out .= "NM1" .
+                    "*" . "85" .
+                    "*" . "1" .
+                    "*" . $lastName .
+                    "*" . $firstName .
+                    "*" . $middleName .
+                    "*" . // Name Prefix not used
+                    "*";
+                } else {
+                    $billingFacilityName = substr($claim->billingFacilityName(), 0, 60);
+                    if ($billingFacilityName == '') {
+                        $log .= "*** billing facility name in 2010A loop is empty.\n";
+                    }
+                    $out .= "NM1" . // Loop 2010AA Billing Provider
+                    "*" . "85" .
+                    "*" . "2" .
+                    "*" . $billingFacilityName .
+                    "*" .
+                    "*" .
+                    "*" .
+                    "*";
+                }
+                if ($claim->billingFacilityNPI()) {
+                    $out .= "*XX*" . $claim->billingFacilityNPI();
+                } else {
+                    $log .= "*** Billing facility has no NPI.\n";
+                }
+                $out .= "~\n";
+
+                ++$edicount;
+                $out .= "N3" .
+                "*";
+                if ($claim->billingFacilityStreet()) {
+                    $out .= $claim->billingFacilityStreet();
+                } else {
+                    $log .= "*** Billing facility has no street.\n";
+                }
+                $out .= "~\n";
+
+                ++$edicount;
+                $out .= "N4" .
+                "*";
+                if ($claim->billingFacilityCity()) {
+                    $out .= $claim->billingFacilityCity();
+                } else {
+                    $log .= "*** Billing facility has no city.\n";
+                }
+                $out .= "*";
+                if ($claim->billingFacilityState()) {
+                    $out .= $claim->billingFacilityState();
+                } else {
+                    $log .= "*** Billing facility has no state.\n";
+                }
+                $out .= "*";
+                if ($claim->x12Zip($claim->billingFacilityZip())) {
+                    $out .= $claim->x12Zip($claim->billingFacilityZip());
+                } else {
+                    $log .= "*** Billing facility has no zip.\n";
+                }
+                $out .= "~\n";
+
+                if ($claim->billingFacilityNPI() && $claim->billingFacilityETIN()) {
+                    ++$edicount;
+                    $out .= "REF";
+                    if ($claim->federalIdType()) {
+                        $out .= "*" . $claim->federalIdType();
+                    } else {
+                        $out .= "*EI"; // For dealing with the situation before adding TaxId type In facility.
+                    }
+                    $out .= "*" . $claim->billingFacilityETIN() . "~\n";
+                } else {
+                    $log .= "*** No billing facility NPI and/or ETIN.\n";
+                }
+                if ($claim->providerNumberType() && $claim->providerNumber() && !$claim->billingFacilityNPI()) {
+                    ++$edicount;
+                    $out .= "REF" .
+                    "*" . $claim->providerNumberType() .
+                    "*" . $claim->providerNumber() .
+                    "~\n";
+                } else if ($claim->providerNumber() && !$claim->providerNumberType()) {
+                    $log .= "*** Payer-specific provider insurance number is present but has no type assigned.\n";
+                }
+
+                // Situational PER*1C segment omitted.
+
+                // Pay-To Address defaults to billing provider and is no longer required in 5010 but may be useful
+                if ($claim->pay_to_provider != '') {
+                    ++$edicount;
+                    $billingFacilityName = substr($claim->billingFacilityName(), 0, 60);
+                    $out .= "NM1" .       // Loop 2010AB Pay-To Provider
+                    "*" . "87" .
+                    "*" . "2" .
+                    "*" . $billingFacilityName .
+                    "*" .
+                    "*" .
+                    "*" .
+                    "*";
+                    if ($claim->billingFacilityNPI()) {
+                        $out .= "*XX*" . $claim->billingFacilityNPI();
+                    } else {
+                        $log .= "*** Pay to provider has no NPI.\n";
+                    }
+                    $out .= "~\n";
+
+                    ++$edicount;
+                    $out .= "N3" .
+                    "*";
+                    if ($claim->billingFacilityStreet()) {
+                        $out .= $claim->billingFacilityStreet();
+                    } else {
+                        $log .= "*** Pay to provider has no street.\n";
+                    }
+                    $out .= "~\n";
+
+                    ++$edicount;
+                    $out .= "N4" .
+                    "*";
+                    if ($claim->billingFacilityCity()) {
+                        $out .= $claim->billingFacilityCity();
+                    } else {
+                        $log .= "*** Pay to provider has no city.\n";
+                    }
+                    $out .= "*";
+                    if ($claim->billingFacilityState()) {
+                        $out .= $claim->billingFacilityState();
+                    } else {
+                        $log .= "*** Pay to provider has no state.\n";
+                    }
+                    $out .= "*";
+                    if ($claim->x12Zip($claim->billingFacilityZip())) {
+                        $out .= $claim->x12Zip($claim->billingFacilityZip());
+                    } else {
+                        $log .= "*** Pay to provider has no zip.\n";
+                    }
+                    $out .= "~\n";
+                }
+            } //***MS Add (end HL Loop)
+
+            // Loop 2010AC Pay-To Plan Name omitted.  Includes:
+            // NM1*PE, N3, N4, REF*2U, REF*EI
+        }//***TR3
+        $PatientHL = $claim->isSelfOfInsured() ? 0 : 1;
+
+        //More changes that ensure we get one provider per loop
+        $HLcount++; //***TR3 Modify
+        $HLSubscriber = $HLcount; //***TR3 Modify
+
+        ++$edicount;
+        $out .= "HL" .        // Loop 2000B Subscriber HL Loop
+            "*" . $HLSubscriber .
+            "*" . $HLBillingPayToProvider .
+            "*" . "22" .
+            "*" . $PatientHL .
+            "~\n";
+
+        if (!$claim->payerSequence()) {
+            $log .= "*** Error: Insurance information is missing!\n";
+        }
+
+        ++$edicount;
+        $out .= "SBR" .    // Subscriber Information
+            "*" . $claim->payerSequence() .
+            "*" . ($claim->isSelfOfInsured() ? '18' : '') .
+            "*" . $claim->groupNumber() .
+            "*" . ($claim->groupNumber() ? '' : $claim->groupName()) . // if groupNumber no groupName
+            "*" . $claim->insuredTypeCode() . // applies for secondary medicare
+            "*" .
+            "*" .
+            "*" .
+            "*" . $claim->claimType() .
+            "~\n";
+
+        // Segment PAT omitted.
+
+        ++$edicount;
+        $out .= "NM1" .       // Loop 2010BA Subscriber
+            "*" . "IL" .
+            "*" . "1"; // 1 = person, 2 = non-person
+        if ($claim->insuredLastName()) {
+            $out .= "*" .
+                $claim->insuredLastName();
+        } else {
+            $log .= "*** Missing insured last name.\n";
+        }
+        $out .= "*";
+        if ($claim->insuredFirstName()) {
+            $out .= $claim->insuredFirstName();
+        } else {
+            $log .= "*** Missing insured first name.\n";
+        }
+        $out .= "*" .
+            $claim->insuredMiddleName() .
+            "*" .
+            "*" . // Name Suffix not used
+            "*" . "MI" .
+            // "MI" = Member Identification Number
+            // "II" = Standard Unique Health Identifier, "Required if the
+            //        HIPAA Individual Patient Identifier is mandated use."
+            //        Here we presume that is not true yet.
+            "*";
+        if ($claim->policyNumber()) {
+            $out .= $claim->policyNumber();
+        } else {
+            $log .= "*** Missing policy number.\n";
+        }
+        $out .= "~\n";
+
+        // For 5010, further subscriber info is sent only if they are the patient.
+        if ($claim->isSelfOfInsured()) {
+            ++$edicount;
+            $out .= "N3" .
+                "*";
+            if ($claim->insuredStreet()) {
+                $out .= $claim->insuredStreet();
+            } else {
+                $log .= "*** Missing insured street.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "N4" .
+                "*";
+            if ($claim->insuredCity()) {
+                $out .= $claim->insuredCity();
+            } else {
+                $log .= "*** Missing insured city.\n";
+            }
+            $out .= "*";
+            if ($claim->insuredState()) {
+                $out .= $claim->insuredState();
+            } else {
+                $log .= "*** Missing insured state.\n";
+            }
+            $out .= "*";
+            if ($claim->x12Zip($claim->insuredZip())) {
+                $out .= $claim->x12Zip($claim->insuredZip());
+            } else {
+                $log .= "*** Missing insured zip.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "DMG" .
+                "*" .
+                "D8" .
+                "*";
+            if ($claim->insuredDOB()) {
+                $out .= $claim->insuredDOB();
+            } else {
+                $log .= "*** Missing insured DOB.\n";
+            }
+            $out .= "*";
+            if ($claim->insuredSex()) {
+                $out .= $claim->insuredSex();
+            } else {
+                $log .= "*** Missing insured sex.\n";
+            }
+            $out .= "~\n";
+        }
+
+        // Segment REF*SY (Subscriber Secondary Identification) omitted.
+        // Segment REF*Y4 (Property and Casualty Claim Number) omitted.
+        // Segment PER*IC (Property and Casualty Subscriber Contact Information) omitted.
+
+        ++$edicount;
+        $payerName = substr($claim->payerName(), 0, 60);
+        $out .= "NM1" .       // Loop 2010BB Payer
+            "*" . "PR" .
+            "*" . "2" .
+            "*";
+        if ($payerName) {
+            $out .= $payerName;
+        } else {
+            $log .= "*** Missing payer name.\n";
+        }
+        $out .= "*" .
+            "*" .
+            "*" .
+            "*" .
+            "*" . "PI" .
+            "*" . ($encounter_claim ? $claim->payerAltID() : $claim->payerID());
+        if (!$claim->payerID()) {
+            $log .= "*** Payer ID is missing for payer '";
+        }
+        $out .= "~\n";
+
+        ++$edicount;
+        $out .= "N3" .
+            "*";
+        if ($claim->payerStreet()) {
+            $out .= $claim->payerStreet();
+        } else {
+            $log .= "*** Missing payer street.\n";
+        }
+        $out .= "~\n";
+
+        ++$edicount;
+        $out .= "N4" .
+            "*";
+        if ($claim->payerCity()) {
+            $out .= $claim->payerCity();
+        } else {
+            $log .= "*** Missing payer city.\n";
+        }
+        $out .= "*";
+        if ($claim->payerState()) {
+            $out .= $claim->payerState();
+        } else {
+            $log .= "*** Missing payer state.\n";
+        }
+        $out .= "*";
+        if ($claim->x12Zip($claim->payerZip())) {
+            $out .= $claim->x12Zip($claim->payerZip());
+        } else {
+            $log .= "*** Missing payer zip.\n";
+        }
+        $out .= "~\n";
+
+        // Segment REF (Payer Secondary Identification) omitted.
+        // Segment REF (Billing Provider Secondary Identification) omitted.
+
+        if (!$claim->isSelfOfInsured()) {
+            ++$edicount;
+            $out .= "HL" .        // Loop 2000C Patient Information
+                "*" . $HLcount .
+                "*" . $HLSubscriber .
+                "*" . "23" .
+                "*" . "0" .
+                "~\n";
+
+            $HLcount++;
+            ++$edicount;
+            $out .= "PAT" .
+                "*" . $claim->insuredRelationship() .
+                "~\n";
+
+            ++$edicount;
+            $out .= "NM1" .       // Loop 2010CA Patient
+                "*" . "QC" .
+                "*" . "1" .
+                "*";
+            if ($claim->patientLastName()) {
+                $out .= $claim->patientLastName();
+            } else {
+                $log .= "*** Missing patient last name.\n";
+            }
+            $out .=  "*";
+            if ($claim->patientFirstName()) {
+                $out .= $claim->patientFirstName();
+            } else {
+                $log .= "*** Missing patient first name.\n";
+            }
+            if ($claim->patientMiddleName() !== '') {
+                $out .= "*" . $claim->patientMiddleName();
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "N3" .
+                "*";
+            if ($claim->patientStreet()) {
+                $out .= $claim->patientStreet();
+            } else {
+                $log .= "*** Missing patient street.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "N4" .
+                "*";
+            if ($claim->patientCity()) {
+                $out .= $claim->patientCity();
+            } else {
+                $log .= "*** Missing patient city.\n";
+            }
+            $out .= "*";
+            if ($claim->patientState()) {
+                $out .= $claim->patientState();
+            } else {
+                $log .= "*** Missing patient state.\n";
+            }
+            $out .= "*";
+            if ($claim->x12Zip($claim->patientZip())) {
+                $out .= $claim->x12Zip($claim->patientZip());
+            } else {
+                $log .= "*** Missing patient zip.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "DMG" .
+                "*" . "D8" .
+                "*";
+            if ($claim->patientDOB()) {
+                $out .= $claim->patientDOB();
+            } else {
+                $log .= "*** Missing patient DOB.\n";
+            }
+            $out .= "*";
+            if ($claim->patientSex()) {
+                $out .= $claim->patientSex();
+            } else {
+                $log .= "*** Missing patient sex.\n";
+            }
+            $out .= "~\n";
+
+            // Segment REF*Y4 (Property and Casualty Claim Number) omitted.
+            // Segment REF (Property and Casualty Patient Identifier) omitted.
+            // Segment PER (Property and Casualty Patient Contact Information) omitted.
+        } // end of patient different from insured
+
+        $proccount = $claim->procCount();
+        $clm_total_charges = 0;
+        for ($prockey = 0; $prockey < $proccount; ++$prockey) {
+            $clm_total_charges += $claim->cptCharges($prockey);
+        }
+        if (!$clm_total_charges) {
+            $log .= "*** This claim has no charges!\n";
+        }
+
+        ++$edicount;
+        $out .= "CLM" .    // Loop 2300 Claim
+            "*" . $pid . "-" . $encounter .
+            "*" . sprintf("%.2f", $clm_total_charges) .
+            "*" .
+            "*" .
+            "*" . sprintf('%02d', $claim->facilityPOS()) . ":" . "B" . ":" . $claim->frequencyTypeCode() .
+            "*" . "Y" .
+            "*" . "A" .
+            "*" . ($claim->billingFacilityAssignment() ? 'Y' : 'N') .
+            "*" . "Y" .
+            "~\n";
+
+        // above is for historical use of encounter onset date, now in misc_billing_options
+        // Segment DTP*431 (Onset of Current Symptoms or Illness)
+        // Segment DTP*484 (Last Menstrual Period Date)
+
+        if (
+            $claim->onsetDate()
+            && $claim->onsetDate() !== $claim->serviceDate()
+            && $claim->onsetDateValid()
+        ) {
+            ++$edicount;
+            $out .= "DTP" .       // Date of Onset
+                "*" . "431" .
+                "*" . "D8" .
+                "*" . $claim->onsetDate() .
+                "~\n";
+        } else if (
+            $claim->miscOnsetDate()
+            && $claim->miscOnsetDate() !== $claim->serviceDate()
+            && $claim->box14Qualifier()
+            && $claim->miscOnsetDateValid()
+        ) {
+            ++$edicount;
+            $out .= "DTP" .
+                "*" . $claim->box14Qualifier() .
+                "*" . "D8" .
+                "*" . $claim->miscOnsetDate() .
+                "~\n";
+        }
+
+        // Segment DTP*304 (Last Seen Date)
+        // Segment DTP*453 (Acute Manifestation Date)
+        // Segment DTP*439 (Accident Date)
+        // Segment DTP*455 (Last X-Ray Date)
+        // Segment DTP*471 (Hearing and Vision Prescription Date)
+        // Segment DTP*314 (Disability) omitted.
+        // Segment DTP*360 (Initial Disability Period Start) omitted.
+        // Segment DTP*361 (Initial Disability Period End) omitted.
+        // Segment DTP*297 (Last Worked Date)
+        // Segment DTP*296 (Authorized Return to Work Date)
+
+        // Segment DTP*454 (Initial Treatment Date)
+
+        if ($claim->dateInitialTreatment() && ($claim->box15Qualifier()) && ($claim->dateInitialTreatmentValid())) {
+            ++$edicount;
+            $out .= "DTP" .       // Date Last Seen
+                "*" . $claim->box15Qualifier() .
+                "*" . "D8" .
+                "*" . $claim->dateInitialTreatment() .
+                "~\n";
+        }
+
+        if (strcmp($claim->facilityPOS(), '21') == 0 && $claim->onsetDateValid()) {
+            ++$edicount;
+            $out .= "DTP" .     // Date of Hospitalization
+                "*" . "435" .
+                "*" . "D8" .
+                "*" . $claim->onsetDate() .
+                "~\n";
+        }
+
+        // above is for historical use of encounter onset date, now in misc_billing_options
+        if (strcmp($claim->facilityPOS(), '21') == 0 && $claim->hospitalizedFromDateValid()) {
+            ++$edicount;
+            $out .= "DTP" .     // Date of Admission
+                "*" . "435" .
+                "*" . "D8" .
+                "*" . $claim->hospitalizedFrom() .
+                "~\n";
+        }
+
+        // Segment DTP*096 (Discharge Date)
+        if (strcmp($claim->facilityPOS(), '21') == 0 && $claim->hospitalizedToDateValid()) {
+            ++$edicount;
+            $out .= "DTP" .     // Date of Discharge
+                "*" . "96" .
+                "*" . "D8" .
+                "*" . $claim->hospitalizedTo() .
+                "~\n";
+        }
+
+        // Segments DTP (Assumed and Relinquished Care Dates) omitted.
+        // Segment DTP*444 (Property and Casualty Date of First Contact) omitted.
+        // Segment DTP*050 (Repricer Received Date) omitted.
+        // Segment PWK (Claim Supplemental Information) omitted.
+        // Segment CN1 (Contract Information) omitted.
+
+        $patientpaid = $claim->patientPaidAmount();
+        if ($patientpaid != 0) {
+            ++$edicount;
+            $out .= "AMT" .     // Patient paid amount. Page 190/220.
+                "*" . "F5" .
+                "*" . $patientpaid .
+                "~\n";
+        }
+
+        // Segment REF*4N (Service Authorization Exception Code) omitted.
+        // Segment REF*F5 (Mandatory Medicare Crossover Indicator) omitted.
+        // Segment REF*EW (Mammography Certification Number) omitted.
+        // Segment REF*9F (Referral Number) omitted.
+
+        if ($claim->priorAuth()) {
+            ++$edicount;
+            $out .= "REF" .     // Prior Authorization Number
+                "*" . "G1" .
+                "*" . $claim->priorAuth() .
+                "~\n";
+        }
+
+        // Segment REF*F8 Payer Claim Control Number for claim re-submission.icn_resubmission_number
+        if (trim($claim->billing_options['icn_resubmission_number']) > 3) {
+            ++$edicount;
+            error_log("Method 1: " . errorLogEscape($claim->billing_options['icn_resubmission_number']), 0);
+            $out .= "REF" .
+                "*" . "F8" .
+                "*" . $claim->icnResubmissionNumber() .
+                "~\n";
+        }
+
+        if ($claim->cliaCode() && ($claim->claimType() === 'MB')) {
+            // Required by Medicare when in-house labs are done.
+            ++$edicount;
+            $out .= "REF" .     // Clinical Laboratory Improvement Amendment Number
+                "*" . "X4" .
+                "*" . $claim->cliaCode() .
+                "~\n";
+        }
+
+        // Segment REF*9A (Repriced Claim Number) omitted.
+        // Segment REF*9C (Adjusted Repriced Claim Number) omitted.
+        // Segment REF*LX (Investigational Device Exemption Number) omitted.
+        // Segment REF*D9 (Claim Identifier for Transmission Intermediaries) omitted.
+        // Segment REF*EA (Medical Record Number) omitted.
+        // Segment REF*P4 (Demonstration Project Identifier) omitted.
+        // Segment REF*1J (Care Plan Oversight) omitted.
+        // Segment K3 (File Information) omitted.
+        if ($claim->additionalNotes()) {
+            // Claim note.
+            ++$edicount;
+            $out .= "NTE" .     // comments box 19
+                "*" . "ADD" .
+                "*" . $claim->additionalNotes() .
+                "~\n";
+        }
+
+        // Segment CR1 (Ambulance Transport Information) omitted.
+        // Segment CR2 (Spinal Manipulation Service Information) omitted.
+        // Segment CRC (Ambulance Certification) omitted.
+        // Segment CRC (Patient Condition Information: Vision) omitted.
+        // Segment CRC (Homebound Indicator) omitted.
+        // Segment CRC (EPSDT Referral).
+        if ($claim->epsdtFlag()) {
+            ++$edicount;
+            $out .= "CRC" .
+                "*" . "ZZ" .
+                "*" . "Y" .
+                "*" . $claim->medicaidReferralCode() .
+                "~\n";
+        }
+
+        // Diagnoses, up to $max_per_seg per HI segment.
+        $max_per_seg = 12;
+        $da = $claim->diagArray();
+        if ($claim->diagtype == "ICD9") {
+            $diag_type_code = 'BK';
+        } else {
+            $diag_type_code = 'ABK';
+        }
+        $tmp = 0;
+        foreach ($da as $diag) {
+            if ($tmp % $max_per_seg == 0) {
+                if ($tmp) {
+                    $out .= "~\n";
+                }
+                ++$edicount;
+                $out .= "HI";         // Health Diagnosis Codes
+            }
+            $out .= "*" . $diag_type_code . ":" . $diag;
+            if ($claim->diagtype == "ICD9") {
+                $diag_type_code = 'BF';
+            } else {
+                $diag_type_code = 'ABF';
+            }
+            ++$tmp;
+        }
+
+        if ($tmp) {
+            $out .= "~\n";
+        }
+
+        // Segment HI*BP (Anesthesia Related Procedure) omitted.
+        // Segment HI*BG (Condition Information) omitted.
+        // Segment HCP (Claim Pricing/Repricing Information) omitted.
+        if ($claim->referrerLastName()) {
+            // Medicare requires referring provider's name and NPI.
+            ++$edicount;
+            $out .= "NM1" .     // Loop 2310A Referring Provider
+                "*" . "DN" .
+                "*" . "1" .
+                "*";
+            if ($claim->referrerLastName()) {
+                $out .= $claim->referrerLastName();
+            } else {
+                $log .= "*** Missing referrer last name.\n";
+            }
+            $out .= "*";
+            if ($claim->referrerFirstName()) {
+                $out .= $claim->referrerFirstName();
+            } else {
+                $log .= "*** Missing referrer first name.\n";
+            }
+            $out .= "*" .
+                $claim->referrerMiddleName() .
+                "*" .
+                "*";
+            if ($claim->referrerNPI()) {
+                $out .=
+                    "*" . "XX" .
+                    "*" . $claim->referrerNPI();
+            } else {
+                $log .= "*** Referring provider has no NPI.\n";
+            }
+            $out .= "~\n";
+        }
+
+        // Per the implementation guide lines, only include this information if it is different
+        // than the Loop 2010AA information
+        if ($claim->providerNPIValid() && ($claim->billingFacilityNPI() !== $claim->providerNPI())) {
+            ++$edicount;
+            $out .= "NM1" .       // Loop 2310B Rendering Provider
+                "*" . "82" .
+                "*" . "1" .
+                "*";
+            if ($claim->providerLastName()) {
+                $out .= $claim->providerLastName();
+            } else {
+                $log .= "*** Missing provider last name.\n";
+            }
+            $out .= "*";
+            if ($claim->providerFirstName()) {
+                $out .= $claim->providerFirstName();
+            } else {
+                $log .= "*** Missing provider first name.\n";
+            }
+            $out .= "*" .
+                $claim->providerMiddleName() .
+                "*" .
+                "*";
+            if ($claim->providerNPI()) {
+                $out .=
+                    "*" . "XX" .
+                    "*" . $claim->providerNPI();
+            } else {
+                $log .= "*** Rendering provider has no NPI.\n";
+            }
+            $out .= "~\n";
+
+            if ($claim->providerTaxonomy()) {
+                ++$edicount;
+                $out .= "PRV" .
+                    "*" . "PE" . // Performing provider
+                    "*" . "PXC" .
+                    "*" . $claim->providerTaxonomy() .
+                    "~\n";
+            } else {
+                $log .= "*** Performing provider has no taxonomy code.\n";
+            }
+        } else {
+            $log .= "*** Rendering provider is billing under a group.\n";
+        }
+        if (!$claim->providerNPIValid()) {
+            // If the loop was skipped because the provider NPI was invalid, generate a warning for the log.
+            $log .= "*** Skipping 2310B because " . $claim->providerLastName() . "," . $claim->providerFirstName() . " has invalid NPI.\n";
+        }
+
+        if (!$claim->providerNPI() && in_array($claim->providerNumberType(), array('0B', '1G', 'G2', 'LU'))) {
+            if ($claim->providerNumber()) {
+                ++$edicount;
+                $out .= "REF" .
+                    "*" . $claim->providerNumberType() .
+                    "*" . $claim->providerNumber() .
+                    "~\n";
+            }
+        }
+        // End of Loop 2310B
+
+        // Loop 2310C is omitted in the case of home visits (POS=12).
+        if ($claim->facilityPOS() != 12 && ($claim->facilityNPI() != $claim->billingFacilityNPI())) {
+            ++$edicount;
+            $out .= "NM1" .       // Loop 2310C Service Location
+                "*" . "77" .
+                "*" . "2";
+            $facilityName = substr($claim->facilityName(), 0, 60);
+            if ($claim->facilityName() || $claim->facilityNPI() || $claim->facilityETIN()) {
+                $out .=
+                    "*" . $facilityName;
+            } else {
+                $log .= "*** Check for invalid facility name, NPI, and/or tax id.\n";
+            }
+            if ($claim->facilityNPI() || $claim->facilityETIN()) {
+                $out .=
+                    "*" .
+                    "*" .
+                    "*" .
+                    "*";
+                if ($claim->facilityNPI()) {
+                    $out .=
+                        "*" . "XX" . "*" . $claim->facilityNPI();
+                } else {
+                    $out .=
+                        "*" . "24" . "*" . $claim->facilityETIN();
+                }
+                if (!$claim->facilityNPI()) {
+                    $log .= "*** Service location has no NPI.\n";
+                }
+            }
+
+            $out .= "~\n";
+            if ($claim->facilityStreet()) {
+                ++$edicount;
+                $out .= "N3" .
+                    "*" . $claim->facilityStreet() .
+                    "~\n";
+            } else {
+                $log .= "*** Missing service facility street.\n";
+            }
+
+            ++$edicount;
+            $out .= "N4" .
+                "*";
+            if ($claim->facilityCity()) {
+                $out .= $claim->facilityCity();
+            } else {
+                $log .= "*** Missing service facility city.\n";
+            }
+            $out .= "*";
+            if ($claim->facilityState()) {
+                $out .= $claim->facilityState();
+            } else {
+                $log .= "*** Missing service facility state.\n";
+            }
+            $out .= "*";
+            if ($claim->x12Zip($claim->facilityZip())) {
+                $out .= $claim->x12Zip($claim->facilityZip());
+            } else {
+                $log .= "*** Missing service facility zip.\n";
+            }
+            $out .= "~\n";
+        }
+        // Segment REF (Service Facility Location Secondary Identification) omitted.
+        // Segment PER (Service Facility Contact Information) omitted.
+
+        // Loop 2310D, Supervising Provider
+        if (! empty($claim->supervisorLastName())) {
+            ++$edicount;
+            $out .= "NM1" .
+                "*" . "DQ" . // Supervising Physician
+                "*" . "1" .  // Person
+                "*" . $claim->supervisorLastName() .
+                "*" . $claim->supervisorFirstName() .
+                "*" . $claim->supervisorMiddleName() .
+                "*" .   // NM106 not used
+                "*";    // Name Suffix not used
+            if ($claim->supervisorNPI()) {
+                $out .=
+                    "*" . "XX" .
+                    "*" . $claim->supervisorNPI();
+            } else {
+                $log .= "*** Supervising Provider has no NPI.\n";
+            }
+            $out .= "~\n";
+
+            if ($claim->supervisorNumber()) {
+                ++$edicount;
+                $out .= "REF" .
+                    "*" . $claim->supervisorNumberType() .
+                    "*" . $claim->supervisorNumber() .
+                    "~\n";
+            }
+        }
+
+        // Segments NM1*PW, N3, N4 (Ambulance Pick-Up Location) omitted.
+        // Segments NM1*45, N3, N4 (Ambulance Drop-Off Location) omitted.
+
+        // Loops 2320 and 2330, other subscriber/payer information.
+        // Remember that insurance index 0 is always for the payer being billed
+        // by this claim, and 1 and above are always for the "other" payers.
+
+        for ($ins = 1; $ins < $claim->payerCount(); ++$ins) {
+            $tmp1 = $claim->claimType($ins);
+            $tmp2 = 'C1'; // Here a kludge. See page 321.
+            if ($tmp1 === 'CI') {
+                $tmp2 = 'C1';
+            }
+            if ($tmp1 === 'AM') {
+                $tmp2 = 'AP';
+            }
+            if ($tmp1 === 'HM') {
+                $tmp2 = 'HM';
+            }
+            if ($tmp1 === 'MB') {
+                $tmp2 = 'MB';
+            }
+            if ($tmp1 === 'MC') {
+                $tmp2 = 'MC';
+            }
+            if ($tmp1 === '09') {
+                $tmp2 = 'PP';
+            }
+
+            ++$edicount;
+            $out .= "SBR" . // Loop 2320, Subscriber Information - page 297/318
+                "*" . $claim->payerSequence($ins) .
+                "*" . $claim->insuredRelationship($ins) .
+                "*" . $claim->groupNumber($ins) .
+                "*" . ($claim->groupNumber() ? '' : $claim->groupName()) .
+                "*" . $claim->insuredTypeCode($ins) .
+                "*" .
+                "*" .
+                "*" .
+                "*" . $claim->claimType($ins) .
+                "~\n";
+
+            // Things that apply only to previous payers, not future payers.
+            if ($claim->payerSequence($ins) < $claim->payerSequence()) {
+                // Generate claim-level adjustments.
+                $aarr = $claim->payerAdjustments($ins);
+                foreach ($aarr as $a) {
+                    ++$edicount;
+                    $out .= "CAS" . // Previous payer's claim-level adjustments. Page 301/323.
+                        "*" . $a[1] .
+                        "*" . $a[2] .
+                        "*" . $a[3] .
+                        "~\n";
+                }
+
+                $payerpaid = $claim->payerTotals($ins);
+                ++$edicount;
+                $out .= "AMT" . // Previous payer's paid amount. Page 307/332.
+                    "*" . "D" .
+                    "*" . $payerpaid[1] .
+                    "~\n";
+                // Segment AMT*A8 (COB Total Non-Covered Amount) omitted.
+                // Segment AMT*EAF (Remaining Patient Liability) omitted.
+            }   // End of things that apply only to previous payers.
+
+            ++$edicount;
+            $out .= "OI" .  // Other Insurance Coverage Information. Page 310/344.
+                "*" .
+                "*" .
+                "*" . ($claim->billingFacilityAssignment($ins) ? 'Y' : 'N') .
+                // For this next item, the 5010 example in the spec does not match its
+                // description.  So this might be wrong.
+                "*" .
+                "*" .
+                "*" .
+                "Y" .
+                "~\n";
+
+            // Segment MOA (Medicare Outpatient Adjudication) omitted.
+            ++$edicount;
+            $out .= "NM1" . // Loop 2330A Subscriber info for other insco. Page 315/350.
+                "*" . "IL" .
+                "*" . "1" .
+                "*";
+            if ($claim->insuredLastName($ins)) {
+                $out .= $claim->insuredLastName($ins);
+            } else {
+                $log .= "*** Missing other insco insured last name.\n";
+            }
+            $out .= "*";
+            if ($claim->insuredFirstName($ins)) {
+                $out .= $claim->insuredFirstName($ins);
+            } else {
+                $log .= "*** Missing other insco insured first name.\n";
+            }
+            $out .= "*" .
+                $claim->insuredMiddleName($ins) .
+                "*" .
+                "*" .
+                "*" . "MI" .
+                "*";
+            if ($claim->policyNumber($ins)) {
+                $out .= $claim->policyNumber($ins);
+            } else {
+                $log .= "*** Missing other insco policy number.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "N3" .
+                "*";
+            if ($claim->insuredStreet($ins)) {
+                $out .= $claim->insuredStreet($ins);
+            } else {
+                $log .= "*** Missing other insco insured street.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "N4" .
+                "*";
+            if ($claim->insuredCity($ins)) {
+                $out .= $claim->insuredCity($ins);
+            } else {
+                $log .= "*** Missing other insco insured city.\n";
+            }
+            $out .= "*";
+            if ($claim->insuredState($ins)) {
+                $out .= $claim->insuredState($ins);
+            } else {
+                $log .= "*** Missing other insco insured state.\n";
+            }
+            $out .= "*";
+            if ($claim->x12Zip($claim->insuredZip($ins))) {
+                $out .= $claim->x12Zip($claim->insuredZip($ins));
+            } else {
+                $log .= "*** Missing other insco insured zip.\n";
+            }
+            $out .= "~\n";
+
+            // Segment REF (Other Subscriber Secondary Identification) omitted.
+            ++$edicount;
+            $payerName = substr($claim->payerName($ins), 0, 60);
+            $out .= "NM1" . // Loop 2330B Payer info for other insco. Page 322/359.
+                "*" . "PR" .
+                "*" . "2" .
+                "*";
+            if ($payerName) {
+                $out .= $payerName;
+            } else {
+                $log .= "*** Missing other insco payer name.\n";
+            }
+            $out .= "*" .
+                "*" .
+                "*" .
+                "*" .
+                "*" . "PI" .
+                "*";
+            if ($claim->payerID($ins)) {
+                $out .= $claim->payerID($ins);
+            } else {
+                $log .= "*** Missing other insco payer id.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "N3" .
+                "*";
+            if ($claim->payerStreet($ins)) {
+                $out .= $claim->payerStreet($ins);
+            } else {
+                $log .= "*** Missing other insco street.\n";
+            }
+            $out .= "~\n";
+
+            ++$edicount;
+            $out .= "N4" .
+                "*";
+            if ($claim->payerCity($ins)) {
+                $out .= $claim->payerCity($ins);
+            } else {
+                $log .= "*** Missing other insco city.\n";
+            }
+            $out .= "*";
+            if ($claim->payerState($ins)) {
+                $out .= $claim->payerState($ins);
+            } else {
+                $log .= "*** Missing other payer state.\n";
+            }
+            $out .= "*";
+            if ($claim->x12Zip($claim->payerZip($ins))) {
+                $out .= $claim->x12Zip($claim->payerZip($ins));
+            } else {
+                $log .= "*** Missing other payer zip.\n";
+            }
+            $out .= "~\n";
+
+            // Segment DTP*573 (Claim Check or Remittance Date) omitted.
+            // Segment REF (Other Payer Secondary Identifier) omitted.
+            // Segment REF*G1 (Other Payer Prior Authorization Number) omitted.
+            // Segment REF*9F (Other Payer Referral Number) omitted.
+            // Segment REF*T4 (Other Payer Claim Adjustment Indicator) omitted.
+            // Segment REF*F8 (Other Payer Claim Control Number) omitted.
+            // Segment NM1 (Other Payer Referring Provider) omitted.
+            // Segment REF (Other Payer Referring Provider Secondary Identification) omitted.
+            // Segment NM1 (Other Payer Rendering Provider) omitted.
+            // Segment REF (Other Payer Rendering Provider Secondary Identification) omitted.
+            // Segment NM1 (Other Payer Service Facility Location) omitted.
+            // Segment REF (Other Payer Service Facility Location Secondary Identification) omitted.
+            // Segment NM1 (Other Payer Supervising Provider) omitted.
+            // Segment REF (Other Payer Supervising Provider Secondary Identification) omitted.
+            // Segment NM1 (Other Payer Billing Provider) omitted.
+            // Segment REF (Other Payer Billing Provider Secondary Identification) omitted.
+        } // End loops 2320/2330*.
+
+        $loopcount = 0;
+
+        // Loop 2400 Procedure Loop.
+        //
+
+        for ($prockey = 0; $prockey < $proccount; ++$prockey) {
+            ++$loopcount;
+            ++$edicount;
+            $out .= "LX" .      // Segment LX, Service Line. Page 398.
+                "*" . $loopcount .
+                "~\n";
+
+            ++$edicount;
+            $out .= "SV1" .     // Segment SV1, Professional Service. Page 400.
+                "*" . "HC:" . $claim->cptKey($prockey) .
+                "*" . sprintf('%.2f', $claim->cptCharges($prockey)) .
+                "*" . "UN" .
+                "*" . $claim->cptUnits($prockey) .
+                "*" .
+                "*" .
+                "*";
+            $dia = $claim->diagIndexArray($prockey);
+            $i = 0;
+            foreach ($dia as $dindex) {
+                if ($i) {
+                    $out .= ':';
+                }
+
+                $out .= $dindex;
+                if (++$i >= 4) {
+                    break;
+                }
+            }
+
+            // needed for epstd
+            if ($claim->epsdtFlag()) {
+                $out .= "*" .
+                    "*" .
+                    "*" .
+                    "*" . "Y" .
+                    "~\n";
+            } else {
+                $out .= "~\n";
+            }
+
+            if (!$claim->cptCharges($prockey)) {
+                $log .= "*** Procedure '" . $claim->cptKey($prockey) . "' has no charges!\n";
+            }
+
+            if (empty($dia)) {
+                $log .= "*** Procedure '" . $claim->cptKey($prockey) . "' is not justified!\n";
+            }
+
+            // Segment SV5 (Durable Medical Equipment Service) omitted.
+            // Segment PWK01 (Line Supplemental Information) omitted.
+            // Segment CR1 (Ambulance Transport Information) omitted.
+            // Segment CR3 (Durable Medical Equipment Certification) omitted.
+            // Segment CRC (Ambulance Certification) omitted.
+            // Segment CRC (Hospice Employee Indicator) omitted.
+            // Segment CRC (Condition Indicator / Durable Medical Equipment) omitted.
+
+            ++$edicount;
+            $out .= "DTP" .     // Date of Service. Page 435.
+                "*" . "472" .
+                "*" . "D8" .
+                "*" . $claim->serviceDate() .
+                "~\n";
+
+            $testnote = rtrim($claim->cptNotecodes($prockey));
+            if (!empty($testnote)) {
+                ++$edicount;
+                $out .= "NTE" .     // Explain Unusual Circumstances.
+                    "*" . "ADD" .
+                    "*" . $claim->cptNotecodes($prockey) .
+                    "~\n";
+            }
+
+            // Segment DTP*471 (Prescription Date) omitted.
+            // Segment DTP*607 (Revision/Recertification Date) omitted.
+            // Segment DTP*463 (Begin Therapy Date) omitted.
+            // Segment DTP*461 (Last Certification Date) omitted.
+            // Segment DTP*304 (Last Seen Date) omitted.
+            // Segment DTP (Test Date) omitted.
+            // Segment DTP*011 (Shipped Date) omitted.
+            // Segment DTP*455 (Last X-Ray Date) omitted.
+            // Segment DTP*454 (Initial Treatment Date) omitted.
+            // Segment QTY (Ambulance Patient Count) omitted.
+            // Segment QTY (Obstetric Anesthesia Additional Units) omitted.
+            // Segment MEA (Test Result) omitted.
+            // Segment CN1 (Contract Information) omitted.
+            // Segment REF*9B (Repriced Line Item Reference Number) omitted.
+            // Segment REF*9D (Adjusted Repriced Line Item Reference Number) omitted.
+            // Segment REF*G1 (Prior Authorization) omitted.
+            // Segment REF*6R (Line Item Control Number) omitted.
+            //   (Really oughta have this for robust 835 posting!)
+            // Segment REF*EW (Mammography Certification Number) omitted.
+            // Segment REF*X4 (CLIA Number) omitted.
+            // Segment REF*F4 (Referring CLIA Facility Identification) omitted.
+            // Segment REF*BT (Immunization Batch Number) omitted.
+            // Segment REF*9F (Referral Number) omitted.
+            // Segment AMT*T (Sales Tax Amount) omitted.
+            // Segment AMT*F4 (Postage Claimed Amount) omitted.
+            // Segment K3 (File Information) omitted.
+            // Segment NTE (Line Note) omitted.
+            // Segment NTE (Third Party Organization Notes) omitted.
+            // Segment PS1 (Purchased Service Information) omitted.
+            // Segment HCP (Line Pricing/Repricing Information) omitted.
+
+            // Loop 2410, Drug Information. Medicaid insurers seem to want this
+            // with HCPCS codes.
+            //
+            $ndc = $claim->cptNDCID($prockey);
+
+            if ($ndc) {
+                ++$edicount;
+                $out .= "LIN" . // Drug Identification. Page 500+ (Addendum pg 71).
+                    "*" .         // Per addendum, LIN01 is not used.
+                    "*" . "N4" .
+                    "*" . $ndc .
+                    "~\n";
+
+                if (!preg_match('/^\d\d\d\d\d-\d\d\d\d-\d\d$/', $ndc, $tmp) && !preg_match('/^\d{11}$/', $ndc)) {
+                    $log .= "*** NDC code '$ndc' has invalid format!\n";
+                }
+
+                ++$edicount;
+                $out .= "CTP" . // Drug Pricing. Page 500+ (Addendum pg 74).
+                    "*" .
+                    "*" .
+                    "*" .
+                    "*" . $claim->cptNDCQuantity($prockey) .
+                    "*" . $claim->cptNDCUOM($prockey) .
+                    // Note: 5010 documents "ME" (Milligrams) as an additional unit of measure.
+                    "~\n";
+
+                // Segment REF (Prescription or Compound Drug Association Number) omitted.
+            }
+
+
+            // Loop 2420A, Rendering Provider (service-specific).
+            // Used if the rendering provider for this service line is different
+            // from that in loop 2310B.
+
+            if ($claim->providerNPI() != $claim->providerNPI($prockey)) {
+                ++$edicount;
+                $out .= "NM1" .       // Loop 2420A Rendering Provider
+                    "*" . "82" .
+                    "*" . "1" .
+                    "*" . $claim->providerLastName($prockey) .
+                    "*" . $claim->providerFirstName($prockey) .
+                    "*" . $claim->providerMiddleName($prockey) .
+                    "*" .
+                    "*";
+                if ($claim->providerNPI($prockey)) {
+                    $out .=
+                        "*" . "XX" .
+                        "*" . $claim->providerNPI($prockey);
+                } else {
+                    $log .= "*** Rendering provider has no NPI.\n";
+                }
+                $out .= "~\n";
+
+                // Segment PRV*PE (Rendering Provider Specialty Information) .
+
+                if ($claim->providerTaxonomy($prockey)) {
+                    ++$edicount;
+                    $out .= "PRV" .
+                        "*" . "PE" . // PErforming provider
+                        "*" . "PXC" .
+                        "*" . $claim->providerTaxonomy($prockey) .
+                        "~\n";
+                }
+
+                // Segment REF (Rendering Provider Secondary Identification).
+                // REF*1C is required here for the Medicare provider number if NPI was
+                // specified in NM109.  Not sure if other payers require anything here.
+
+                if ($claim->providerNumberType($prockey) == "G2") {
+                    ++$edicount; $out .= "REF" . "*" . $claim->providerNumberType($prockey) .
+                        "*" . $claim->providerNumber($prockey) . "~\n";
+                }
+            } // end provider exception
+
+            // Segment NM1 (Loop 2420B Purchased Service Provider Name) omitted.
+            // Segment REF (Loop 2420B Purchased Service Provider Secondary Identification) omitted.
+            // Segment NM1,N3,N4 (Loop 2420C Service Facility Location) omitted.
+            // Segment REF (Loop 2420C Service Facility Location Secondary Identification) omitted.
+            // Segment NM1 (Loop 2420D Supervising Provider Name) omitted.
+            // Segment REF (Loop 2420D Supervising Provider Secondary Identification) omitted.
+
+            // Loop 2420E, Ordering Provider omitted.
+
+            // Segment NM1 (Referring Provider Name) omitted.
+            // Segment REF (Referring Provider Secondary Identification) omitted.
+            // Segments NM1*PW, N3, N4 (Ambulance Pick-Up Location) omitted.
+            // Segments NM1*45, N3, N4 (Ambulance Drop-Off Location) omitted.
+
+            // Loop 2430, adjudication by previous payers.
+
+            for ($ins = 1; $ins < $claim->payerCount(); ++$ins) {
+                if ($claim->payerSequence($ins) > $claim->payerSequence()) {
+                    continue; // payer is future, not previous
+                }
+
+                $payerpaid = $claim->payerTotals($ins, $claim->cptKey($prockey));
+                $aarr = $claim->payerAdjustments($ins, $claim->cptKey($prockey));
+
+                if ($payerpaid[1] == 0 && !count($aarr)) {
+                    $log .= "*** Procedure '" . $claim->cptKey($prockey) .
+                        "' has no payments or adjustments from previous payer!\n";
+                    continue;
+                }
+
+                ++$edicount;
+                $out .= "SVD" . // Service line adjudication. Page 554.
+                    "*" . $claim->payerID($ins) .
+                    "*" . $payerpaid[1] .
+                    "*" . "HC:" . $claim->cptKey($prockey) .
+                    "*" .
+                    "*" . $claim->cptUnits($prockey) .
+                    "~\n";
+
+                $tmpdate = $payerpaid[0];
+                // new logic for putting same adjustment group codes
+                // on the same line
+                $adj_group_code[0] = '';
+                $adj_count = 0;
+                $aarr_count = count($aarr);
+                foreach ($aarr as $a) {
+                    ++$adj_count;
+                    $adj_group_code[$adj_count] = $a[1];
+                    // when the adj group code changes increment edi
+                    // counter and add line ending
+                    if ($adj_group_code[$adj_count] !== $adj_group_code[($adj_count - 1)]) {
+                        // increment when there was a prior segment with the
+                        // same adj group code
+                        if ($adj_count !== 1) {
+                            ++$edicount;
+                            $out .= "~\n";
+                        }
+                        $out .= "CAS" . // Previous payer's line level adjustments. Page 558.
+                            "*" . $a[1] .
+                            "*" . $a[2] .
+                            "*" . $a[3];
+                        if (($aarr_count == 1) || ($adj_count !== 1)) {
+                            ++$edicount;
+                            $out .= "~\n";
+                        }
+                    } else {
+                        $out .= "*" . // since it's the same adj group code don't include it
+                            "*" . $a[2] .
+                            "*" . $a[3];
+                        if ($adj_count == $aarr_count) {
+                            ++$edicount;
+                            $out .= "~\n";
+                        }
+                    }
+                    if (!$tmpdate) {
+                        $tmpdate = $a[0];
+                    }
+                }
+
+                if ($tmpdate) {
+                    ++$edicount;
+                    $out .= "DTP" . // Previous payer's line adjustment date. Page 493/566.
+                        "*" . "573" .
+                        "*" . "D8" .
+                        "*" . $tmpdate .
+                        "~\n";
+                }
+
+                // Segment AMT*EAF (Remaining Patient Liability) omitted.
+                // Segment LQ (Form Identification Code) omitted.
+                // Segment FRM (Supporting Documentation) omitted.
+            } // end loop 2430
+        } // end this procedure
+
+        if ($SEFLAG == true) { //***TR3 Add
+            ++$edicount; //todo: This might have to fo into the SE flag spot //***MS Modify
+
+            $out .= "SE" .        // SE Trailer
+            "*" . $edicount .
+            "*" . "0021" .
+            "~\n";
+        } //***TR3 Add
+
         $out .= "GE" .        // GE Trailer
-        "*" . "1" .
-        "*" . "1" .
-        "~\n";
+            "*" . "1" .
+            "*" . "1" .
+            "~\n";
 
         $out .= "IEA" .       // IEA Trailer
-        "*" . "1" .
-        "*" . "000000001" .
-        "~\n";
+            "*" . "1" .
+            "*" . "000000001" .
+            "~\n";
 
         // Remove any trailing empty fields (delimiters) from each segment.
         $out = preg_replace('/\*+~/', '~', $out);
Index: src/Services/BaseService.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Services/BaseService.php b/src/Services/BaseService.php
--- a/src/Services/BaseService.php	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/src/Services/BaseService.php	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -49,6 +49,26 @@
         $this->autoIncrements = self::getAutoIncrements($table);
     }
 
+    /**
+     * Get the name of our base database table
+     *
+     * @return mixed
+     */
+    public function getTable()
+    {
+        return $this->table;
+    }
+
+    /**
+     * Get the fields/column-names on the database table
+     *
+     * @return array
+     */
+    public function getFields(): array
+    {
+        return $this->fields;
+    }
+
     /**
      * queryFields
      * Build SQL Query for Selecting Fields
Index: templates/x12_partners/general_edit.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/templates/x12_partners/general_edit.html b/templates/x12_partners/general_edit.html
--- a/templates/x12_partners/general_edit.html	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/templates/x12_partners/general_edit.html	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -6,12 +6,19 @@
  * @author    Brady Miller <brady.g.miller@gmail.com>
  * @copyright Copyright (c) 2017 Brady Miller <brady.g.miller@gmail.com>
  * @license   https://github.com/openemr/openemr/blob/master/LICENSE GNU General Public License 3
+ * Modified by Daniel Pflieger at GrowlingFlea Software to handle submitters
  *}
 <form name="x12_partner" method="post" action="{$FORM_ACTION}" class='form-horizontal' onsubmit="return top.restoreSession()">
     <div class="form-row my-sm-2">
         <label for="name" class="col-form-label col-sm-2">{xlt t='Partner Name'}</label>
         <div class="col-sm-8">
             <input type="text" id="name" name="name" class="form-control" value="{$partner->get_name()|attr}" onKeyDown="PreventIt(event)">
+        </div>
+    </div>
+    <div class="form-row my-sm-2">
+        <label for="name" class="col-form-label col-sm-2">{xlt t='Submitter Name (3rd Party Submitter Only)'}</label>
+        <div class="col-sm-8">
+            <input type="text" id="x12_submitter_name" name="x12_submitter_name" class="form-control" value="{$partner->get_x12_submitter_name()|attr}" onKeyDown="PreventIt(event)">
         </div>
     </div>
     <div class="form-row my-sm-2">
@@ -130,6 +137,43 @@
             <input type="text" maxlength="15" id="x12_gs03" name="x12_gs03" class="form-control" value="{$partner->get_x12_gs03()|attr}" onKeyDown="PreventIt(event)">
         </div>
     </div>
+    <div class="form-row my-sm-2">
+        <label for="x12_sftp_login" class="col-form-label col-sm-2">{xlt t='SFTP Login Credentials'}</label>
+        <div class="col-sm-8">
+            <input type="text" maxlength="45" id="x12_sftp_login" name="x12_sftp_login" class="form-control" value="{$partner->get_x12_sftp_login()|attr}" onKeyDown="PreventIt(event)">
+        </div>
+    </div>
+    <div class="form-row my-sm-2">
+        <label for="x12_sftp_pass" class="col-form-label col-sm-2">{xlt t='SFTP Pass Credentials'}</label>
+        <div class="col-sm-8">
+            <input type="password" maxlength="45" id="x12_sftp_pass" name="x12_sftp_pass" class="form-control" value="{$partner->get_x12_sftp_pass()|attr}" onKeyDown="PreventIt(event)">
+        </div>
+    </div>
+    <div class="form-row my-sm-2">
+        <label for="x12_sftp_host" class="col-form-label col-sm-2">{xlt t='SFTP Host'}</label>
+        <div class="col-sm-8">
+            <input type="text" maxlength="15" id="x12_sftp_host" name="x12_sftp_host" class="form-control" value="{$partner->get_x12_sftp_host()|attr}" onKeyDown="PreventIt(event)">
+        </div>
+    </div>
+    <div class="form-row my-sm-2">
+        <label for="x12_sftp_port" class="col-form-label col-sm-2">{xlt t='SFTP Port'}</label>
+        <div class="col-sm-8">
+            <input type="text" maxlength="5" id="x12_sftp_port" name="x12_sftp_port" class="form-control" value="{$partner->get_x12_sftp_port()|attr}" onKeyDown="PreventIt(event)">
+        </div>
+    </div>
+    <div class="form-row my-sm-2">
+        <label for="x12_sftp_local_dir" class="col-form-label col-sm-2">{xlt t='SFTP Local Directory'}</label>
+        <div class="col-sm-8">
+            <input type="text" maxlength="400" id="x12_sftp_local_dir" name="x12_sftp_local_dir" class="form-control" value="{$partner->get_x12_sftp_local_dir()|attr}" onKeyDown="PreventIt(event)">
+        </div>
+    </div>
+    <div class="form-row my-sm-2">
+        <label for="x12_sftp_remote_dir" class="col-form-label col-sm-2">{xlt t='SFTP Remote Directory'}</label>
+        <div class="col-sm-8">
+            <input type="text" maxlength="400" id="x12_sftp_remote_dir" name="x12_sftp_remote_dir" class="form-control" value="{$partner->get_x12_sftp_remote_dir()|attr}" onKeyDown="PreventIt(event)">
+        </div>
+    </div>
+
     <div class="btn-group offset-sm-2">
         <a href="javascript:add_x12();" class="btn btn-secondary btn-save" onclick="top.restoreSession()">
             {xlt t='Save'}
Index: templates/x12_partners/general_list.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/templates/x12_partners/general_list.html b/templates/x12_partners/general_list.html
--- a/templates/x12_partners/general_list.html	(revision 2375db0f8f2e345f1dd36e5c556db30b312fdcc3)
+++ b/templates/x12_partners/general_list.html	(revision e3fa29dc6ec78e3ed2bdbb5539a5aa281b37a2a7)
@@ -7,6 +7,7 @@
       <thead>
       <tr>
           <th>{xlt t='Name'}</th>
+          <th>{xlt t='Submitter Name (If applicable)'}</th>
           <th>{xlt t='Sender ID'}</th>
           <th>{xlt t='Receiver ID'}</th>
           <th>{xlt t='Version'}</th>
@@ -19,6 +20,7 @@
                   {$partner->get_name()|text}&nbsp;
               </a>
           </td>
+          <td>{$partner->get_x12_submitter_name()|text}&nbsp;</td>
           <td>{$partner->get_x12_sender_id()|text}&nbsp;</td>
           <td>{$partner->get_x12_receiver_id()|text}&nbsp;</td>
           <td>{$partner->get_x12_version()|text}&nbsp;</td>
